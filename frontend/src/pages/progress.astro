---
import Layout from '~/layouts/PageLayout.astro';

interface QuestionMeta { name?: string; topic?: string | string[]; difficulty?: number | string; timeLimitSeconds?: number }
interface Attempt {
  questionId: string;
  completedAt?: string;
  timeTakenSeconds?: number | null;
  notes: string;
  question?: QuestionMeta | null;
  difficulty?: number | string | null;
}
interface RawAttempt {
  questionId: string;
  completedAt?: string;
  timestamp?: string;
  lastUpdatedAt?: string;
  timeTakenSeconds?: number;
  timeTaken?: number;
  notes?: string;
  question?: QuestionMeta | null;
  difficulty?: number | string;
}

const BACKEND_BASE = import.meta.env.PUBLIC_BACKEND_URL || 'http://localhost:3001';
let attempts: Attempt[] = [];
let stats: { total: number; topics: Record<string, number> } | null = null;
let TOPIC_LABELS: Record<string, string> = {};

// Note: Server-side rendering will show empty state initially
// Client-side will fetch attempts from database and display loading spinner
// This is intentional to avoid blocking page load

// Load question stats (counts) for progress bars
try {
  const sr = await fetch(`${BACKEND_BASE}/api/questions/stats`);
  if (sr.ok) {
    stats = await sr.json();
  }
  if (stats && stats.topics) {
    const topicsObj = stats.topics; // local alias for non-null assertion clarity
    // Merge Financial Maths variants into a single canonical key 'financial-maths'
    const financialVariants = ['financial-mathematics', 'financial mathematics'];
    let financialMerged = 0;
    financialVariants.forEach(v => {
      if (topicsObj[v]) { financialMerged += topicsObj[v]; delete topicsObj[v]; }
    });
    if (financialMerged) topicsObj['financial-maths'] = (topicsObj['financial-maths'] || 0) + financialMerged;

    // Remove combined Probability-Statistics synthetic grouping (prob-stat variants)
    const probCombined = ['prob-stat','prob stat','probability-statistics','probability statistics'];
  probCombined.forEach(v => { if (topicsObj[v]) delete topicsObj[v]; });

    // Build labels with special mappings, excluding combined group completely
    const toTitle = (slug: string) => slug.split(/[-_ ]+/).map(w => w ? w[0].toUpperCase() + w.slice(1) : '').join(' ');
    const specialLabelMap: Record<string,string> = {
      'financial-maths': 'Financial Maths'
    };
    TOPIC_LABELS = Object.fromEntries(
  Object.keys(topicsObj)
        .filter(k => !probCombined.includes(k.toLowerCase()))
        .map(k => {
          const lower = k.toLowerCase();
          if (specialLabelMap[lower]) return [k, specialLabelMap[lower]];
          if (lower === 'financial-mathematics' || lower === 'financial mathematics') return [k, 'Financial Maths'];
          if (probCombined.includes(lower)) return [k, '']; // shouldn't reach due to filter
          return [k, toTitle(k)];
        })
    );
  }
} catch { /* ignore stats fetch failure */ }

// Sort attempts newest first
attempts.sort((a,b) => {
  const ta = a.completedAt ? new Date(a.completedAt).getTime() : 0;
  const tb = b.completedAt ? new Date(b.completedAt).getTime() : 0;
  return tb - ta;
});

// Precompute display meta to simplify template (avoids complex logic in JSX section)
interface DisplayTopic { slug: string; label: string }
interface AttemptView { a: Attempt; diffLabel: string | null; diffText: string | null; diffClasses: string; topics: DisplayTopic[]; timeLimitSeconds: number | null; overLimit: boolean }
const attemptViews: AttemptView[] = attempts.map(a => {
  const diffRaw = a.difficulty ?? a.question?.difficulty;
  let diffLabel: string | null = null; // original raw label
  let diffText: string | null = null; // normalized Easy / Medium / Hard / Very Hard
  let diffClasses = '';
  if (diffRaw !== undefined && diffRaw !== null && diffRaw !== '') {
    diffLabel = String(diffRaw);
    const num = parseInt(diffLabel, 10);
    if (!isNaN(num)) {
      if (num <= 1) { diffText = 'Easy'; diffClasses = 'bg-green-100 text-green-700 dark:bg-green-900/40 dark:text-green-300'; }
      else if (num === 2) { diffText = 'Medium'; diffClasses = 'bg-orange-100 text-orange-700 dark:bg-orange-900/40 dark:text-orange-300'; }
      else if (num === 3) { diffText = 'Hard'; diffClasses = 'bg-red-100 text-red-700 dark:bg-red-900/40 dark:text-red-300'; }
      else { diffText = 'Very Hard'; diffClasses = 'bg-purple-100 text-purple-700 dark:bg-purple-900/40 dark:text-purple-300'; }
    } else {
      const lower = diffLabel.toLowerCase();
      if (/(^|\b)(easy|low)(\b|$)/.test(lower)) { diffText = 'Easy'; diffClasses = 'bg-green-100 text-green-700 dark:bg-green-900/40 dark:text-green-300'; }
      else if (/(^|\b)(med|medium|moderate)(\b|$)/.test(lower)) { diffText = 'Medium'; diffClasses = 'bg-orange-100 text-orange-700 dark:bg-orange-900/40 dark:text-orange-300'; }
      else if (/(^|\b)(very.?hard|extremely.?hard|veryhard)(\b|$)/.test(lower)) { diffText = 'Very Hard'; diffClasses = 'bg-purple-100 text-purple-700 dark:bg-purple-900/40 dark:text-purple-300'; }
      else { diffText = 'Hard'; diffClasses = 'bg-red-100 text-red-700 dark:bg-red-900/40 dark:text-red-300'; }
    }
  }
  const topicSlugs: string[] = a.question ? (Array.isArray(a.question.topic) ? a.question.topic : [a.question.topic]).filter(Boolean) as string[] : [];
  const canonical = (slug: string) => {
    const lower = slug.toLowerCase();
    if (lower === 'financial-mathematics' || lower === 'financial mathematics') return 'financial-maths';
    if (lower === 'prob-stat' || lower === 'prob stat' || lower === 'probability-statistics' || lower === 'probability statistics') return ''; // drop combined
    return slug;
  };
  const seenLabels = new Set<string>();
  const topics: DisplayTopic[] = [];
  topicSlugs.forEach(raw => {
    const slug = canonical(raw);
    if (!slug) return; // dropped combined group
    const label = TOPIC_LABELS[slug] || slug.split(/[-_ ]+/).map(w=>w? w[0].toUpperCase()+w.slice(1):'').join(' ');
    if (seenLabels.has(label)) return;
    seenLabels.add(label);
    topics.push({ slug, label });
  });
  const timeLimitSeconds = a.question?.timeLimitSeconds ?? null;
  const overLimit = timeLimitSeconds != null && a.timeTakenSeconds != null && a.timeTakenSeconds > timeLimitSeconds;
  return { a, diffLabel, diffText, diffClasses, topics, timeLimitSeconds, overLimit };
});

// Client will optionally augment with local attempts if none from server.
---

<Layout metadata={{ title: 'Your Profile' }}>
  <style>
    /* Custom dropdown styling for rounder appearance */
    #topic-filter option {
      border-radius: 0.5rem;
      padding: 0.5rem;
    }
    
    /* Style the dropdown container for rounded corners */
    #topic-filter {
      border-radius: 0.75rem;
    }
  </style>
  
  <div class="min-h-screen bg-gradient-to-br from-pink-50 via-white to-pink-50 dark:from-slate-900 dark:via-slate-800 dark:to-slate-900">
  <section class="max-w-6xl mx-auto px-4 py-10">
    
    <!-- User Profile Section -->
    <!-- User Profile and Progress Stats - Side by Side -->
    <div class="mb-6 grid grid-cols-1 lg:grid-cols-[1fr_3fr] gap-4 max-w-full overflow-hidden">
      <!-- User Profile Section -->
      <div class="bg-white/70 dark:bg-slate-800/70 backdrop-blur-sm rounded-xl p-4 border border-pink-100/50 dark:border-slate-700/50 min-w-0" style="box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1);">
        <h2 class="text-lg font-bold text-gray-800 dark:text-gray-100 mb-4">User Profile</h2>
        
        <!-- Loading State -->
        <div id="profile-loading" class="text-center py-3">
          <p class="text-gray-600 dark:text-gray-400 text-sm">Loading profile...</p>
        </div>

        <!-- Profile Content -->
        <div id="profile-form-container" class="hidden">
          <div class="space-y-3">
            <div>
              <label for="firstName" class="block text-xs font-medium mb-1 text-gray-700 dark:text-gray-300">First Name</label>
              <input
                type="text"
                id="firstName"
                name="firstName"
                required
                maxlength="50"
                class="w-full px-3 py-1.5 text-sm border rounded-lg focus:ring-2 focus:ring-blue-500 dark:bg-slate-700 dark:border-slate-600 dark:text-gray-100"
              />
            </div>
            
            <div>
              <label for="lastName" class="block text-xs font-medium mb-1 text-gray-700 dark:text-gray-300">Last Name</label>
              <input
                type="text"
                id="lastName"
                name="lastName"
                maxlength="50"
                class="w-full px-3 py-1.5 text-sm border rounded-lg focus:ring-2 focus:ring-blue-500 dark:bg-slate-700 dark:border-slate-600 dark:text-gray-100"
              />
            </div>
            
            <div>
              <label for="email" class="block text-xs font-medium mb-1 text-gray-700 dark:text-gray-300">Email</label>
              <input
                type="email"
                id="email"
                disabled
                class="w-full px-3 py-1.5 text-sm border rounded-lg bg-gray-100 dark:bg-slate-900 dark:border-slate-600 cursor-not-allowed text-gray-600 dark:text-gray-400"
              />
            </div>
        
            <div id="name-error" class="text-red-500 text-xs hidden"></div>
            <div id="name-success" class="text-green-500 text-xs hidden"></div>
          </div>
        </div>
      </div>
      
      <!-- Progress Stats Section -->
      <div class="bg-white/70 dark:bg-slate-800/70 backdrop-blur-sm rounded-xl p-4 border border-pink-100/50 dark:border-slate-700/50 min-w-0 overflow-hidden" style="box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1);">
        <!-- Difficulty Stats -->
        <div class="flex items-center gap-3 mb-4">
          <div class="w-8 flex-shrink-0"></div> <!-- Spacer to align with scroll buttons -->
          <div class="flex flex-wrap items-center gap-3 flex-1">
            <div class="flex items-center gap-2 px-3 py-1.5 rounded-full bg-green-100 text-green-700 dark:bg-green-900/40 dark:text-green-300">
              <span class="text-sm font-medium">Easy</span>
              <span id="easy-proportion" class="text-xs opacity-70"></span>
            </div>
            <div class="flex items-center gap-2 px-3 py-1.5 rounded-full bg-orange-100 text-orange-700 dark:bg-orange-900/40 dark:text-orange-300">
              <span class="text-sm font-medium">Medium</span>
              <span id="medium-proportion" class="text-xs opacity-70"></span>
            </div>
            <div class="flex items-center gap-2 px-3 py-1.5 rounded-full bg-red-100 text-red-700 dark:bg-red-900/40 dark:text-red-300">
              <span class="text-sm font-medium">Hard</span>
              <span id="hard-proportion" class="text-xs opacity-70"></span>
            </div>
            <div class="flex items-center gap-2 px-3 py-1.5 rounded-full bg-purple-100 text-purple-700 dark:bg-purple-900/40 dark:text-purple-300">
              <span class="text-sm font-medium">Very Hard</span>
              <span id="very-hard-proportion" class="text-xs opacity-70"></span>
            </div>
          </div>
          <div class="w-8 flex-shrink-0"></div> <!-- Spacer to align with scroll buttons -->
        </div>

        <!-- Year Stats with Navigation -->
        <div class="flex items-center gap-3 mb-4">
          <!-- Left scroll button -->
          <button 
            id="year-scroll-left" 
            class="flex-shrink-0 w-8 h-8 flex items-center justify-center rounded-full bg-gray-200 dark:bg-slate-700 hover:bg-gray-300 dark:hover:bg-slate-600 transition disabled:opacity-30 disabled:cursor-not-allowed"
            aria-label="Scroll years left"
          >
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
            </svg>
          </button>

          <!-- Year pills container with horizontal scroll -->
          <div class="overflow-hidden flex-1">
            <div id="year-pills-container" class="flex gap-3 transition-transform duration-300" style="transform: translateX(0);">
              <!-- Year pills will be inserted here by JavaScript -->
            </div>
          </div>

          <!-- Right scroll button -->
          <button 
            id="year-scroll-right" 
            class="flex-shrink-0 w-8 h-8 flex items-center justify-center rounded-full bg-gray-200 dark:bg-slate-700 hover:bg-gray-300 dark:hover:bg-slate-600 transition disabled:opacity-30 disabled:cursor-not-allowed"
            aria-label="Scroll years right"
          >
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
            </svg>
          </button>
        </div>

        <!-- Paper Stats -->
        <div class="flex items-center gap-3 mb-4">
          <div class="w-8 flex-shrink-0"></div> <!-- Spacer to align with scroll buttons -->
          <div class="flex flex-wrap items-center gap-3 flex-1">
            <div id="paper-pills-container" class="flex gap-3">
              <!-- Paper pills will be inserted here by JavaScript -->
            </div>
          </div>
          <div class="w-8 flex-shrink-0"></div> <!-- Spacer to align with scroll buttons -->
        </div>

        <!-- Topic Stats with Navigation -->
        <div class="flex items-center gap-3 mb-4">
          <!-- Left scroll button -->
          <button 
            id="topic-scroll-left" 
            class="flex-shrink-0 w-8 h-8 flex items-center justify-center rounded-full bg-gray-200 dark:bg-slate-700 hover:bg-gray-300 dark:hover:bg-slate-600 transition disabled:opacity-30 disabled:cursor-not-allowed"
            aria-label="Scroll topics left"
          >
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
            </svg>
          </button>

          <!-- Topic pills container with horizontal scroll -->
          <div class="overflow-hidden flex-1">
            <div id="topic-pills-container" class="flex gap-3 transition-transform duration-300" style="transform: translateX(0);">
              <!-- Topic pills will be inserted here by JavaScript -->
            </div>
          </div>

          <!-- Right scroll button -->
          <button 
            id="topic-scroll-right" 
            class="flex-shrink-0 w-8 h-8 flex items-center justify-center rounded-full bg-gray-200 dark:bg-slate-700 hover:bg-gray-300 dark:hover:bg-slate-600 transition disabled:opacity-30 disabled:cursor-not-allowed"
            aria-label="Scroll topics right"
          >
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
            </svg>
          </button>
        </div>

        <!-- Question Type Stats -->
        <div class="flex items-center gap-3">
          <div class="w-8 flex-shrink-0"></div> <!-- Spacer to align with scroll buttons -->
          <div class="flex flex-wrap items-center gap-3 flex-1">
            <div id="type-pills-container" class="flex gap-3">
              <!-- Type pills will be inserted here by JavaScript -->
            </div>
          </div>
          <div class="w-8 flex-shrink-0"></div> <!-- Spacer to align with scroll buttons -->
        </div>
      </div>
    </div>
    
    <div class="flex items-center justify-between mb-4">
      <!-- Topic Filter Dropdown (moved from profile section) -->
      <div class="w-56">
        {stats ? (
          <select id="topic-filter" class="h-10 w-full text-base rounded-xl border border-gray-300 dark:border-slate-600 bg-white dark:bg-slate-800 text-gray-800 dark:text-gray-100 px-3 focus:outline-none focus:ring-2 focus:ring-blue-500 shadow-sm appearance-none bg-no-repeat bg-right pr-10" style="background-image: url('data:image/svg+xml;charset=UTF-8,%3csvg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 24 24%27 fill=%27none%27 stroke=%27currentColor%27 stroke-width=%272%27 stroke-linecap=%27round%27 stroke-linejoin=%27round%27%3e%3cpolyline points=%276 9 12 15 18 9%27%3e%3c/polyline%3e%3c/svg%3e'); background-size: 1.25rem; background-position: right 0.75rem center;">
            <option value="__all">All Topics</option>
            {Object.keys(stats.topics).sort().map(t => <option value={t}>{TOPIC_LABELS[t] || t.replace(/[-_]/g,' ').replace(/\b\w/g, c=>c.toUpperCase())}</option>)}
          </select>
        ) : (
          <div class="h-10 animate-pulse bg-gray-200 dark:bg-slate-700 rounded-xl" />
        )}
      </div>
      
      <!-- Question Count Display with Mini Progress Circle -->
      <div class="flex items-center gap-3">
        <!-- Count Display -->
        <div class="text-left min-w-[140px]" style="transition: opacity 0.15s ease-out, transform 0.15s ease-out;">
          <p class="text-lg transition-all duration-300 ease-out">
            <span id="completed-count" class="font-bold text-gray-900 dark:text-gray-100">
              {attempts.length}
            </span>
            <span class="text-gray-500 dark:text-gray-400">
              / {stats?.total || 0} Completed
            </span>
          </p>
        </div>
        
        <!-- Mini Circular Progress -->
        <div class="relative w-10 h-10 flex-shrink-0">
          <svg class="w-full h-full transform -rotate-90" viewBox="0 0 48 48">
            <circle
              cx="24"
              cy="24"
              r="20"
              fill="none"
              stroke="currentColor"
              stroke-width="4"
              class="text-gray-200 dark:text-slate-700"
            />
            <circle
              id="mini-progress-bar"
              cx="24"
              cy="24"
              r="20"
              fill="none"
              stroke="currentColor"
              stroke-width="4"
              stroke-linecap="round"
              class="text-pink-500 dark:text-pink-600 transition-all duration-500"
              style={`stroke-dasharray: ${2 * Math.PI * 20}; stroke-dashoffset: ${2 * Math.PI * 20 * (1 - (stats?.total ? Math.min(1, attempts.length / stats.total) : 0))}`}
            />
          </svg>
        </div>
      </div>
    </div>
    
    {/* Loading spinner for attempts grid */}
    <div id="attempts-loading" class="flex flex-col items-center justify-center py-24">
      <div class="w-16 h-16 border-4 border-pink-200 dark:border-pink-800 border-t-pink-600 dark:border-t-pink-400 rounded-full animate-spin mb-4"></div>
      <p class="text-gray-600 dark:text-gray-400 text-lg">Loading your attempts...</p>
    </div>
    
    {/* Auth warning removed intentionally */}
    <div id="empty-progress-state" class="hidden">
      <div class="flex flex-col items-center justify-center py-24 text-center text-gray-500 dark:text-gray-400">
        <div class="w-28 h-28 mb-6 opacity-60">
          <svg viewBox="0 0 120 120" class="w-full h-full" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="60" cy="60" r="36" stroke-dasharray="6 8" />
            <path d="M30 78c8 10 20 16 30 16 14 0 26-8 34-20M32 52c4-12 16-22 28-22 10 0 20 6 26 14M44 88c-4-4-8-10-10-16M82 84c2-6 4-14 2-20M52 34c-2 4-4 8-4 12" />
            <path d="M18 96c12 4 28 6 42 6 18 0 36-4 48-10" stroke-dasharray="4 10" />
          </svg>
        </div>
        <p class="text-lg font-medium mb-2">No completed attempts yet</p>
        <p class="max-w-md text-sm mb-6">Head over to Practice and solve your first question. Your progress will appear here once you save an attempt.</p>
        <a href="/maths/practice" class="inline-flex items-center px-5 py-2.5 rounded-lg bg-red-200 text-red-800 font-medium hover:bg-red-300 dark:bg-red-900 dark:text-red-200 dark:hover:bg-red-800 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-400 dark:focus:ring-offset-slate-900 transition">Go to Practice</a>
      </div>
    </div>
  <div id="topic-labels" data-topic-labels={JSON.stringify(TOPIC_LABELS)} class="hidden"></div>
  {stats && <div id="progress-stats" data-stats={JSON.stringify(stats)} class="hidden"></div>}
  <div class="grid gap-4 md:gap-6 hidden" id="attempt-grid" data-backend={BACKEND_BASE}>
      {attemptViews.map(({ a, diffText, diffClasses, topics, overLimit }) => (
        <div class="rounded-xl border border-gray-200 dark:border-slate-700 bg-white dark:bg-slate-800 p-4 shadow-sm flex flex-col gap-3" data-attempt={a.questionId} data-difficulty={diffText || ''} data-time={a.timeTakenSeconds || ''} data-question-name={a.question?.name || ''}>
          <div class="flex items-start justify-between gap-4">
            <div class="flex-1">
              <div class="flex flex-wrap items-center gap-3">
                {(() => {
                  const primaryTopic = (topics && topics.length) ? topics[0].slug : (a.questionId.split('-')[0] || 'unknown');
                  const practiceHref = `/maths/practice/${primaryTopic}?q=${a.questionId}`;
                  
                  // Format the display name
                  let displayName = a.question?.name || a.questionId;
                  // If it's a custom question (no year in name), format the ID
                  if (!a.question?.name || !/^\d{4}/.test(a.question.name)) {
                    // Format: alg-0007 -> Custom Algebra 7
                    const match = a.questionId.match(/^([a-z-]+)-0*(\d+)$/i);
                    if (match) {
                      const topicSlug = match[1];
                      const questionNum = match[2];
                      const topicLabel = TOPIC_LABELS[topicSlug] || topicSlug.split('-').map((w: string) => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
                      displayName = `Custom ${topicLabel} ${questionNum}`;
                    }
                  }
                  
                  return (
                    <h2 class="m-0 font-semibold text-gray-900 dark:text-gray-100 text-lg leading-tight">
                      <a href={practiceHref} class="hover:underline focus:outline-none focus:ring-2 focus:ring-blue-500 rounded-sm">{displayName}</a>
                    </h2>
                  );
                })()}
                <div class="flex flex-wrap items-center gap-2 ml-1 pt-0.5">
                  {diffText && <span class={`inline-flex items-center px-2 py-1 rounded-md text-xs font-medium ${diffClasses}`} data-difficulty-chip>{diffText}</span>}
                  {topics.map(t => (
                    <span class="inline-flex items-center px-2 py-1 rounded-md text-xs font-medium bg-gray-100 dark:bg-slate-700 text-gray-700 dark:text-gray-300" data-topic={t.slug} title={t.slug}>{t.label}</span>
                  ))}
                </div>
              </div>
              <p class="text-xs text-gray-500 dark:text-gray-400 mt-1">{a.completedAt ? new Date(a.completedAt).toLocaleString() : ''}</p>
            </div>
            {a.timeTakenSeconds != null && a.timeTakenSeconds > 0 && (
              <div class="flex items-start gap-2">
                <span class={`inline-flex items-center h-7 px-2 py-1 rounded-md text-xs font-medium self-start ${overLimit ? 'bg-red-100 dark:bg-red-900 text-red-700 dark:text-red-300' : 'bg-blue-100 dark:bg-blue-900 text-blue-700 dark:text-blue-300'}`}
                  data-time-chip>
                  {Math.floor((a.timeTakenSeconds || 0) / 60).toString().padStart(2,'0')}:{((a.timeTakenSeconds || 0) % 60).toString().padStart(2,'0')}
                </span>
                <button class="edit-notes inline-flex items-center justify-center h-7 w-7 rounded-md border border-transparent hover:border-blue-500 text-gray-500 hover:text-blue-600 dark:text-gray-400 dark:hover:text-blue-400" title="Edit notes" data-question-id={a.questionId}>
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 3a2.83 2.83 0 0 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>
                </button>
              </div>
            )}
            {(!a.timeTakenSeconds || a.timeTakenSeconds === 0) && (
              <div class="flex items-start gap-2">
                <button class="edit-notes inline-flex items-center justify-center h-7 w-7 rounded-md border border-transparent hover:border-blue-500 text-gray-500 hover:text-blue-600 dark:text-gray-400 dark:hover:text-blue-400" title="Edit notes" data-question-id={a.questionId}>
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 3a2.83 2.83 0 0 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>
                </button>
              </div>
            )}
          </div>
          {a.notes && (
            <div class="relative">
              <div class="notes-clamped text-sm text-gray-700 dark:text-gray-300" data-full={a.notes}>{a.notes}</div>
              <button class="expand-notes text-xs mt-1 text-blue-600 dark:text-blue-400 hover:underline">Expand</button>
            </div>
          )}
        </div>
      ))}
    </div>
  </section>
  </div>

  <!-- Edit Notes Modal -->
  <div id="edit-notes-modal" class="fixed inset-0 bg-black bg-opacity-50 backdrop-blur-sm z-50 flex items-center justify-center hidden">
    <div class="bg-white dark:bg-slate-800 rounded-xl p-6 max-w-md w-full mx-4 shadow-xl">
      <h3 class="text-lg font-semibold text-gray-800 dark:text-gray-200 mb-4">Edit Attempt Notes</h3>
      <div class="mb-4">
        <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Question:</label>
        <div id="edit-modal-question-title" class="p-3 bg-gray-50 dark:bg-slate-700 rounded-lg text-gray-800 dark:text-gray-200">--</div>
      </div>
      <div class="mb-4">
        <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Time Taken:</label>
        <div id="edit-modal-time-taken" class="p-3 bg-gray-50 dark:bg-slate-700 rounded-lg font-mono text-gray-800 dark:text-gray-200">--:--</div>
      </div>
      <div class="mb-6">
        <label for="edit-attempt-notes" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Notes:</label>
        <textarea id="edit-attempt-notes" rows="4" class="w-full p-3 border border-gray-300 dark:border-slate-600 rounded-lg focus:ring-2 focus:ring-pink-500 focus:border-pink-500 dark:bg-slate-700 dark:text-gray-200 resize-none" placeholder="Update your notes for this attempt..."></textarea>
      </div>
      <div class="flex gap-3">
        <button id="cancel-edit-notes" class="flex-1 px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 dark:bg-slate-600 dark:text-gray-200 dark:hover:bg-slate-500">Cancel</button>
        <button id="confirm-edit-notes" class="flex-1 px-4 py-2 bg-pink-500 text-white rounded-lg hover:bg-pink-600 dark:bg-pink-600 dark:hover:bg-pink-700">Save Notes</button>
      </div>
    </div>
  </div>

  <script>
    (function(){
      const grid = document.getElementById('attempt-grid');
      const emptyState = document.getElementById('empty-progress-state');
      const loadingSpinner = document.getElementById('attempts-loading');
      const progressStatsEl = document.getElementById('progress-stats');
      const topicSelect = document.getElementById('topic-filter') as HTMLSelectElement | null;
      const topicLabelsEl = document.getElementById('topic-labels');
      let topicLabels: Record<string,string> = {};
      if (topicLabelsEl) { try { topicLabels = JSON.parse(topicLabelsEl.getAttribute('data-topic-labels') || '{}'); } catch { /* ignore */ } }
      const backendBase = grid?.getAttribute('data-backend') || 'http://localhost:3001';
      
      // Fetch attempts from database on page load
      async function fetchAttemptsFromDatabase() {
        try {
          const response = await fetch(`${backendBase}/api/attempts`, {
            credentials: 'include',
            headers: { 'Accept': 'application/json' }
          });
          
          if (!response.ok) {
            console.warn('Failed to fetch attempts from database:', response.status);
            // Hide loading, show empty state
            if (loadingSpinner) loadingSpinner.classList.add('hidden');
            if (emptyState) emptyState.classList.remove('hidden');
            return [];
          }
          
          const data = await response.json();
          return data.attempts || [];
        } catch (error) {
          console.error('Error fetching attempts:', error);
          // Hide loading, show empty state
          if (loadingSpinner) loadingSpinner.classList.add('hidden');
          if (emptyState) emptyState.classList.remove('hidden');
          return [];
        }
      }
      
      // Render attempts to the grid
      function renderAttempts(attempts: any[]) {
        if (!grid) return;
        
        // Hide loading spinner
        if (loadingSpinner) loadingSpinner.classList.add('hidden');
        
        if (attempts.length === 0) {
          // Show empty state
          if (emptyState) emptyState.classList.remove('hidden');
          if (grid) grid.classList.add('hidden');
          return;
        }
        
        // Show grid, hide empty state
        if (grid) grid.classList.remove('hidden');
        if (emptyState) emptyState.classList.add('hidden');
        
        // Clear existing server-rendered attempts
        grid.innerHTML = '';
        
        // Render each attempt
        attempts.forEach((attempt: any) => {
          const card = document.createElement('div');
          card.className = 'rounded-xl border border-gray-200 dark:border-slate-700 bg-white dark:bg-slate-800 p-4 shadow-sm flex flex-col gap-3';
          
          // Format difficulty
          let diffChip = '';
          let diffText = '';
          if (attempt.difficulty) {
            const diff = attempt.difficulty.toLowerCase();
            if (diff === 'easy' || diff === '1') {
              diffChip = '<span class="inline-flex items-center px-2 py-1 rounded-md text-xs font-medium bg-green-100 text-green-700 dark:bg-green-900/40 dark:text-green-300" data-difficulty-chip>Easy</span>';
              diffText = 'Easy';
            } else if (diff === 'medium' || diff === '2') {
              diffChip = '<span class="inline-flex items-center px-2 py-1 rounded-md text-xs font-medium bg-orange-100 text-orange-700 dark:bg-orange-900/40 dark:text-orange-300" data-difficulty-chip>Medium</span>';
              diffText = 'Medium';
            } else if (diff === 'hard' || diff === '3') {
              diffChip = '<span class="inline-flex items-center px-2 py-1 rounded-md text-xs font-medium bg-red-100 text-red-700 dark:bg-red-900/40 dark:text-red-300" data-difficulty-chip>Hard</span>';
              diffText = 'Hard';
            } else {
              diffChip = '<span class="inline-flex items-center px-2 py-1 rounded-md text-xs font-medium bg-purple-100 text-purple-700 dark:bg-purple-900/40 dark:text-purple-300" data-difficulty-chip>Very Hard</span>';
              diffText = 'Very Hard';
            }
          }
          
          // Format topics
          const topics = attempt.related_topics || [];
          const topicChips = topics.map((topic: string) => {
            const label = topicLabels[topic] || topic.split(/[-_ ]+/).map(w => w ? w[0].toUpperCase() + w.slice(1) : '').join(' ');
            return `<span class="inline-flex items-center px-2 py-1 rounded-md text-xs font-medium bg-gray-100 dark:bg-slate-700 text-gray-700 dark:text-gray-300" data-topic="${topic}">${label}</span>`;
          }).join('');
          
          // Format display name
          let displayName = attempt.question_name || attempt.question_id;
          if (!attempt.question_name || !/^\d{4}/.test(attempt.question_name)) {
            const match = attempt.question_id.match(/^([a-z-]+)-0*(\d+)$/i);
            if (match) {
              const topicSlug = match[1];
              const questionNum = match[2];
              const topicLabel = topicLabels[topicSlug] || topicSlug.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
              displayName = `Custom ${topicLabel} ${questionNum}`;
            }
          }
          
          // Format time
          const timeTaken = attempt.time_taken_seconds;
          let timeChip = '';
          if (timeTaken != null && timeTaken > 0) {
            const minutes = Math.floor(timeTaken / 60);
            const seconds = timeTaken % 60;
            timeChip = `<span class="inline-flex items-center h-7 px-2 py-1 rounded-md bg-blue-100 dark:bg-blue-900 text-blue-700 dark:text-blue-300 text-xs font-medium" data-time-chip>${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}</span>`;
          }
          
          // Primary topic for link
          const primaryTopic = attempt.parent_topic || (topics.length > 0 ? topics[0] : attempt.question_id.split('-')[0]);
          const practiceHref = `/maths/practice/${primaryTopic}?q=${attempt.question_id}`;
          
          // Format timestamp
          const timestamp = attempt.completed_at || attempt.last_updated_at;
          const dateStr = timestamp ? new Date(timestamp).toLocaleString() : '';
          
          // Notes display
          const notesBlock = attempt.notes ? 
            `<div class="relative"><div class="notes-clamped text-sm text-gray-700 dark:text-gray-300" data-full="${(attempt.notes || '').replace(/"/g, '&quot;')}">${attempt.notes}</div><button class="expand-notes text-xs mt-1 text-blue-600 dark:text-blue-400 hover:underline">Expand</button></div>` : '';
          
          card.innerHTML = `
            <div class="flex items-start justify-between gap-4">
              <div class="flex-1">
                <div class="flex flex-wrap items-center gap-3">
                  <h2 class="m-0 font-semibold text-gray-900 dark:text-gray-100 text-lg leading-tight"><a href="${practiceHref}" class="hover:underline focus:outline-none focus:ring-2 focus:ring-blue-500 rounded-sm">${displayName}</a></h2>
                  <div class="flex flex-wrap items-center gap-2 ml-1 pt-0.5">${diffChip}${topicChips}</div>
                </div>
                <p class="text-xs text-gray-500 dark:text-gray-400 mt-1">${dateStr}</p>
              </div>
              <div class="flex items-start gap-2">${timeChip}
                <button class="edit-notes inline-flex items-center justify-center h-7 w-7 rounded-md border border-transparent hover:border-blue-500 text-gray-500 hover:text-blue-600 dark:text-gray-400 dark:hover:text-blue-400" title="Edit notes" data-question-id="${attempt.question_id}">
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 3a2.83 2.83 0 0 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>
                </button>
              </div>
            </div>
            ${notesBlock}
          `;
          
          card.setAttribute('data-attempt', attempt.question_id);
          card.setAttribute('data-difficulty', diffText);
          card.setAttribute('data-time', timeTaken || '');
          card.setAttribute('data-question-name', attempt.question_name || '');
          
          grid.appendChild(card);
        });
        
        // Recompute progress after rendering
        recomputeProgress();
      }
      
      // Load attempts from database on page load
      fetchAttemptsFromDatabase().then(attempts => {
        renderAttempts(attempts);
      });
      
      function loadLocalAttempts(){
        try {
          const raw = localStorage.getItem('questionAttempts');
          if(!raw) return [];
          return JSON.parse(raw);
        } catch { return []; }
      }
      
      let statsData: { total?: number; topics?: Record<string, number> } = {};
      if (progressStatsEl) {
        try { statsData = JSON.parse(progressStatsEl.getAttribute('data-stats') || '{}'); } catch { /* ignore parse */ }
      }

      function recomputeProgress(){
        if(!('total' in statsData)) return;
        const selectedTopic = topicSelect && topicSelect.value !== '__all' ? topicSelect.value : null;
        const cards = Array.from(grid?.querySelectorAll('[data-attempt]') || []);
        const unique = new Map<string, Element>();
        cards.forEach(c => { const id = c.getAttribute('data-attempt'); if(id) unique.set(id,c); });
        let total = 0; let completed = 0;
        if (!selectedTopic) {
          total = (statsData.total ?? 0) as number;
          completed = unique.size;
        } else {
          total = statsData.topics && statsData.topics[selectedTopic] ? statsData.topics[selectedTopic] : 0;
          unique.forEach(card => {
            const topics = Array.from(card.querySelectorAll('[data-topic]')).map(e=>e.getAttribute('data-topic')).filter((v): v is string => !!v);
            let match = topics.includes(selectedTopic);
            if (!match && topics.length === 0) {
              const id = card.getAttribute('data-attempt') || '';
              if (id.split('-')[0] === selectedTopic) match = true;
            }
            if (match) completed++;
          });
        }
        
        // Update completed count display with animation
        const completedCountEl = document.getElementById('completed-count');
        if (completedCountEl) {
          const parentDiv = completedCountEl.closest('.text-right');
          if (parentDiv && parentDiv instanceof HTMLElement) {
            // Add fade-out animation
            parentDiv.style.opacity = '0';
            parentDiv.style.transform = 'scale(0.95)';
            parentDiv.style.transition = 'all 0.15s ease-out';
            
            setTimeout(() => {
              parentDiv.innerHTML = `
                <p class="text-lg transition-all duration-300 ease-out">
                  <span id="completed-count" class="font-bold text-gray-900 dark:text-gray-100">
                    ${completed}
                  </span>
                  <span class="text-gray-500 dark:text-gray-400">
                    / ${total} Completed
                  </span>
                </p>
              `;
              
              // Force reflow and fade-in animation
              requestAnimationFrame(() => {
                parentDiv.style.opacity = '1';
                parentDiv.style.transform = 'scale(1)';
              });
            }, 150);
          }
        }
        
        // Update mini progress circle
        const miniProgressBar = document.getElementById('mini-progress-bar');
        if (miniProgressBar) {
          const radius = 20;
          const circumference = 2 * Math.PI * radius;
          const progress = total ? Math.min(1, completed / total) : 0;
          const offset = circumference * (1 - progress);
          (miniProgressBar as HTMLElement).style.strokeDashoffset = String(offset);
        }
        
        // Update difficulty stats
        const easyCountEl = document.getElementById('easy-count');
        const mediumCountEl = document.getElementById('medium-count');
        const hardCountEl = document.getElementById('hard-count');
        const veryHardCountEl = document.getElementById('very-hard-count');
        
        if (easyCountEl || mediumCountEl || hardCountEl || veryHardCountEl) {
          let easyCount = 0, mediumCount = 0, hardCount = 0, veryHardCount = 0;
          
          if (!selectedTopic) {
            // Count all attempts
            unique.forEach(card => {
              const diffChip = card.querySelector('[data-difficulty-chip]');
              if (diffChip) {
                const diffText = diffChip.textContent?.trim();
                if (diffText === 'Easy') easyCount++;
                else if (diffText === 'Medium') mediumCount++;
                else if (diffText === 'Hard') hardCount++;
                else if (diffText === 'Very Hard') veryHardCount++;
              }
            });
          } else {
            // Count only attempts for selected topic
            unique.forEach(card => {
              const topics = Array.from(card.querySelectorAll('[data-topic]')).map(e=>e.getAttribute('data-topic')).filter((v): v is string => !!v);
              let match = topics.includes(selectedTopic);
              if (!match && topics.length === 0) {
                const id = card.getAttribute('data-attempt') || '';
                if (id.split('-')[0] === selectedTopic) match = true;
              }
              if (match) {
                const diffChip = card.querySelector('[data-difficulty-chip]');
                if (diffChip) {
                  const diffText = diffChip.textContent?.trim();
                  if (diffText === 'Easy') easyCount++;
                  else if (diffText === 'Medium') mediumCount++;
                  else if (diffText === 'Hard') hardCount++;
                  else if (diffText === 'Very Hard') veryHardCount++;
                }
              }
            });
          }
          
          // Animate count updates
          const animateCount = (el: HTMLElement, newValue: number) => {
            const currentValue = parseInt(el.textContent || '0');
            if (currentValue !== newValue) {
              el.style.transition = 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
              el.style.transform = 'scale(1.2)';
              el.style.opacity = '0.5';
              
              setTimeout(() => {
                el.textContent = String(newValue);
                el.style.transform = 'scale(1)';
                el.style.opacity = '1';
              }, 150);
            }
          };
          
          if (easyCountEl) animateCount(easyCountEl as HTMLElement, easyCount);
          if (mediumCountEl) animateCount(mediumCountEl as HTMLElement, mediumCount);
          if (hardCountEl) animateCount(hardCountEl as HTMLElement, hardCount);
          if (veryHardCountEl) animateCount(veryHardCountEl as HTMLElement, veryHardCount);
        }
      }

      if (grid && grid.children.length === 0) {
        const local = loadLocalAttempts();
        if (local.length) {
          // Hide empty state and inject local attempts
          if (emptyState) emptyState.classList.add('hidden');
          // Sort local newest first
          local.sort((a,b) => {
            const ta = a.timestamp ? new Date(a.timestamp).getTime() : 0;
            const tb = b.timestamp ? new Date(b.timestamp).getTime() : 0;
            return tb - ta;
          });
          local.forEach(a => {
            const card = document.createElement('div');
            card.className = 'rounded-xl border border-gray-200 dark:border-slate-700 bg-white dark:bg-slate-800 p-4 shadow-sm flex flex-col gap-3';
            
            // Only show time if it's greater than 0
            const time = (a.timeTaken != null && a.timeTaken > 0) ? `<span class="inline-flex items-center h-7 px-2 py-1 rounded-md bg-blue-100 dark:bg-blue-900 text-blue-700 dark:text-blue-300 text-xs font-medium" data-time-chip>${String(Math.floor(a.timeTaken/60)).padStart(2,'0')}:${String(a.timeTaken%60).padStart(2,'0')}</span>` : '';
            
            const topic = a.topic || (a.questionId ? a.questionId.split('-')[0] : null);
            const diff = a.difficulty;
            let diffChip = '';
            if (diff !== undefined && diff !== null && diff !== '') {
              const label = String(diff);
              const num = parseInt(label,10);
              let cls=''; let norm='';
              if(!isNaN(num)) {
                if (num <=1) { cls='bg-green-100 text-green-700 dark:bg-green-900/40 dark:text-green-300'; norm='Easy'; }
                else if (num===2) { cls='bg-orange-100 text-orange-700 dark:bg-orange-900/40 dark:text-orange-300'; norm='Medium'; }
                else { cls='bg-red-100 text-red-700 dark:bg-red-900/40 dark:text-red-300'; norm='Hard'; }
              } else {
                const lower=label.toLowerCase();
                if(/(easy|low)/.test(lower)) { cls='bg-green-100 text-green-700 dark:bg-green-900/40 dark:text-green-300'; norm='Easy'; }
                else if(/(med|medium|moderate)/.test(lower)) { cls='bg-orange-100 text-orange-700 dark:bg-orange-900/40 dark:text-orange-300'; norm='Medium'; }
                else { cls='bg-red-100 text-red-700 dark:bg-red-900/40 dark:text-red-300'; norm='Hard'; }
              }
              diffChip = `<span class="inline-flex items-center px-2 py-1 rounded-md text-xs font-medium ${cls}" data-difficulty-chip>${norm || label}</span>`;
            }
            const displayTopic = topic ? (topicLabels[topic] || topic.split(/[-_ ]+/).map(w=>w? w[0].toUpperCase()+w.slice(1):'').join(' ')) : '';
            const localTopicChip = topic ? `<span class="inline-flex items-center px-2 py-1 rounded-md text-xs font-medium bg-gray-100 dark:bg-slate-700 text-gray-700 dark:text-gray-300" data-topic="${topic}" title="${topic}">${displayTopic}</span>` : '';
            const notesBlock = a.notes ? `<div class="relative"><div class="notes-clamped text-sm text-gray-700 dark:text-gray-300" data-full="${(a.notes||'').replace(/"/g,'&quot;')}">${a.notes}</div><button class="expand-notes text-xs mt-1 text-blue-600 dark:text-blue-400 hover:underline">Expand</button></div>` : '';
            
            // Format display name for custom questions
            let displayName = a.questionName || a.questionId;
            if (!a.questionName || !/^\d{4}/.test(a.questionName)) {
              // Format: alg-0007 -> Custom Algebra 7
              const match = a.questionId.match(/^([a-z-]+)-0*(\d+)$/i);
              if (match) {
                const topicSlug = match[1];
                const questionNum = match[2];
                const topicLabel = topicLabels[topicSlug] || topicSlug.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
                displayName = `Custom ${topicLabel} ${questionNum}`;
              }
            }
            
            card.innerHTML = `
              <div class="flex items-start justify-between gap-4">
                <div class="flex-1">
                  <div class="flex flex-wrap items-center gap-3">
                    ${(() => {
                      const primaryTopic = (topic || (a.questionId ? a.questionId.split('-')[0] : 'unknown'));
                      const practiceHref = `/maths/practice/${primaryTopic}?q=${a.questionId}`;
                      return `<h2 class="m-0 font-semibold text-gray-900 dark:text-gray-100 text-lg leading-tight"><a href="${practiceHref}" class="hover:underline focus:outline-none focus:ring-2 focus:ring-blue-500 rounded-sm">${displayName}</a></h2>`;
                    })()}
                    <div class="flex flex-wrap items-center gap-2 ml-1 pt-0.5">${diffChip}${localTopicChip}</div>
                  </div>
                  <p class="text-xs text-gray-500 dark:text-gray-400 mt-1">${a.timestamp ? new Date(a.timestamp).toLocaleString() : ''}</p>
                </div>
                <div class="flex items-start gap-2">${time}
                  <button class="edit-notes inline-flex items-center justify-center h-7 w-7 rounded-md border border-transparent hover:border-blue-500 text-gray-500 hover:text-blue-600 dark:text-gray-400 dark:hover:text-blue-400" title="Edit notes" data-question-id="${a.questionId}">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 3a2.83 2.83 0 0 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>
                  </button>
                </div>
              </div>
              ${notesBlock}
            `;
            card.setAttribute('data-attempt', a.questionId);
            card.setAttribute('data-question-name', a.questionName || '');
            grid.appendChild(card);
          });
          recomputeProgress();
        }
      }

      // Modal state
      let editingAttemptId: string | null = null;
      const editModal = document.getElementById('edit-notes-modal');
      const editNotesTextarea = document.getElementById('edit-attempt-notes') as HTMLTextAreaElement | null;
      const editQuestionTitleEl = document.getElementById('edit-modal-question-title');
      const editTimeTakenEl = document.getElementById('edit-modal-time-taken');
      const cancelEditBtn = document.getElementById('cancel-edit-notes');
      const confirmEditBtn = document.getElementById('confirm-edit-notes');

      function openEditModal(qid: string, currentNotes: string, questionTitle: string, timeSeconds: number | null){
        editingAttemptId = qid;
        if (editNotesTextarea) editNotesTextarea.value = currentNotes;
        if (editQuestionTitleEl) editQuestionTitleEl.textContent = questionTitle || qid;
        if (editTimeTakenEl) {
          if (timeSeconds != null) {
            const m = Math.floor(timeSeconds/60).toString().padStart(2,'0');
            const s = (timeSeconds%60).toString().padStart(2,'0');
            editTimeTakenEl.textContent = `${m}:${s}`;
          } else {
            editTimeTakenEl.textContent = '--:--';
          }
        }
        if (editModal) {
          editModal.classList.remove('hidden');
          document.body.style.overflow='hidden';
          setTimeout(()=>{ editNotesTextarea?.focus({preventScroll:true}); }, 50);
        }
      }

      function closeEditModal(){
        if (editModal) editModal.classList.add('hidden');
        document.body.style.overflow='';
        editingAttemptId = null;
      }

      cancelEditBtn?.addEventListener('click', ()=> closeEditModal());
      cancelEditBtn?.addEventListener('keydown', e=>{ if(e.key==='Escape') closeEditModal(); });
      document.addEventListener('keydown', e=>{ if(e.key==='Escape' && !editModal?.classList.contains('hidden')) closeEditModal(); });
      confirmEditBtn?.addEventListener('click', async ()=>{
        if(!editingAttemptId) return;
        const newNotes = editNotesTextarea ? editNotesTextarea.value : '';
        // Update card UI
        const card = grid?.querySelector(`[data-attempt="${editingAttemptId}"]`);
        if (card) {
          let notesEl = card.querySelector('.notes-clamped') as HTMLElement | null;
          if (newNotes.trim() === '') {
            if (notesEl) { const wrapper = notesEl.parentElement; if (wrapper) wrapper.remove(); }
          } else {
            if (!notesEl) {
              const block = document.createElement('div');
              block.className = 'relative';
              block.innerHTML = `<div class="notes-clamped text-sm text-gray-700 dark:text-gray-300" data-full="${newNotes.replace(/"/g,'&quot;')}">${newNotes}</div><button class="expand-notes text-xs mt-1 text-blue-600 dark:text-blue-400 hover:underline">Expand</button>`;
              card.appendChild(block);
              notesEl = block.querySelector('.notes-clamped') as HTMLElement | null;
            } else {
              notesEl.textContent = newNotes;
              notesEl.setAttribute('data-full', newNotes);
            }
          }
        }
        // Save to database
        if (backendBase) {
          try { 
            const response = await fetch(`${backendBase}/api/attempts/${editingAttemptId}/notes`, { 
              method: 'PATCH', 
              headers: {'Content-Type': 'application/json'}, 
              credentials: 'include', 
              body: JSON.stringify({ notes: newNotes || null }) 
            });
            if (response.ok) {
              console.log('Notes updated in database');
            } else {
              console.warn('Failed to update notes in database:', response.status);
            }
          } catch (error) { 
            console.error('Error updating notes:', error);
          }
        }
        // Also update localStorage as backup
        try { const local = loadLocalAttempts(); const found = local.find(a=>a.questionId===editingAttemptId); if(found){ found.notes = newNotes; localStorage.setItem('questionAttempts', JSON.stringify(local)); } } catch { /* ignore */ }
        closeEditModal();
        setTimeout(applyOverflowDetection, 30);
      });

      document.addEventListener('click', async function(e){
        const target = e.target as Element | null;
        if(!target) return;

        // Expand / Collapse notes
        const expandBtn = target.closest('.expand-notes');
        if (expandBtn) {
          const wrapper = (expandBtn as HTMLElement).previousElementSibling;
          if(wrapper instanceof HTMLElement) {
            if(wrapper.classList.contains('expanded')) {
              wrapper.classList.remove('expanded');
              (expandBtn as HTMLElement).textContent = 'Expand';
            } else {
              wrapper.classList.add('expanded');
              (expandBtn as HTMLElement).textContent = 'Collapse';
            }
          }
          return;
        }

        // Edit notes button
        const editBtn = target.closest('.edit-notes');
        if (editBtn) {
          const qid = (editBtn as HTMLElement).getAttribute('data-question-id');
          if(!qid) return;
          const card = (editBtn as HTMLElement).closest('[data-attempt]');
          if(!card) return;
          const notesEl = card.querySelector('.notes-clamped') as HTMLElement | null;
          const current = notesEl ? (notesEl.getAttribute('data-full') || notesEl.textContent || '') : '';
          const titleAnchor = card.querySelector('h2 a');
          const questionTitle = titleAnchor ? (titleAnchor.textContent || qid) : qid;
          const timeAttr = card.getAttribute('data-time');
          const timeSeconds = timeAttr ? parseInt(timeAttr,10) : null;
          openEditModal(qid, current, questionTitle, timeSeconds);
        }
      });

      // Overflow detection for notes: remove expand button if not needed
      function applyOverflowDetection(){
        document.querySelectorAll('.notes-clamped').forEach(el => {
          if(!(el instanceof HTMLElement)) return;
          const btn = el.parentElement?.querySelector('.expand-notes');
            if (!btn) return;
          if (el.scrollHeight <= el.clientHeight + 2) {
            btn.remove();
          }
        });
      }
      applyOverflowDetection();
      // Re-run after a tick for dynamically injected content
      setTimeout(applyOverflowDetection, 50);

      // Listen for storage changes (another tab saving attempts)
      window.addEventListener('storage', ev => {
        if (ev.key === 'questionAttempts') {
          // naive refresh strategy: if grid is empty, repopulate; else only recompute progress
          recomputeProgress();
        }
      });
      recomputeProgress();
      if (topicSelect) {
        topicSelect.addEventListener('change', recomputeProgress);
      }

      // ============ Year Stats Management ============
      let currentYearScrollOffset = 0;

      // Update difficulty proportions
      async function updateDifficultyProportions() {
        const diffMap = {
          'easy': 'Easy',
          'medium': 'Medium',
          'hard': 'Hard',
          'very-hard': 'Very Hard'
        };
        
        // Fetch all questions to get totals
        const response = await fetch(`${backendBase}/api/questions/all`, { credentials: 'include' });
        const allQuestions = await response.json();
        
        // Count totals by difficulty
        const totals: Record<string, number> = { Easy: 0, Medium: 0, Hard: 0, 'Very Hard': 0 };
        allQuestions.forEach((q: any) => {
          const diff = q.difficulty;
          if (diff !== undefined && diff !== null) {
            const num = parseInt(String(diff), 10);
            let diffText = '';
            if (!isNaN(num)) {
              if (num <= 1) diffText = 'Easy';
              else if (num === 2) diffText = 'Medium';
              else if (num === 3) diffText = 'Hard';
              else diffText = 'Very Hard';
            } else {
              const lower = String(diff).toLowerCase();
              if (/(^|\b)(easy|low)(\b|$)/.test(lower)) diffText = 'Easy';
              else if (/(^|\b)(med|medium|moderate)(\b|$)/.test(lower)) diffText = 'Medium';
              else if (/(^|\b)(very.?hard|extremely.?hard|veryhard)(\b|$)/.test(lower)) diffText = 'Very Hard';
              else if (/(^|\b)(hard|difficult)(\b|$)/.test(lower)) diffText = 'Hard';
            }
            if (diffText && totals[diffText] !== undefined) {
              totals[diffText]++;
            }
          }
        });
        
        Object.entries(diffMap).forEach(([id, diffText]) => {
          const proportionEl = document.getElementById(`${id}-proportion`);
          
          if (proportionEl) {
            // Count completed from user's database attempts (rendered in grid)
            const cards = Array.from(grid?.querySelectorAll('[data-attempt]') || []);
            const unique = new Map<string, Element>();
            cards.forEach(c => { const id = c.getAttribute('data-attempt'); if(id) unique.set(id,c); });
            
            let completed = 0;
            
            unique.forEach(card => {
              const diffChip = card.querySelector('[data-difficulty-chip]');
              if (diffChip && diffChip.textContent?.trim() === diffText) {
                completed++;
              }
            });
            
            const total = totals[diffText] || 0;
            
            if (total > 0) {
              proportionEl.textContent = `(${completed}/${total})`;
            } else {
              proportionEl.textContent = '';
            }
          }
        });
      }

      // Update year pills
      async function updateYearStats() {
        // Fetch all questions to get all years and totals
        const response = await fetch(`${backendBase}/api/questions/all`, { credentials: 'include' });
        const allQuestions = await response.json();
        
        // Extract all years from all questions
        const extractYear = (name: string | null | undefined): string | null => {
          if (!name) return null;
          const match = name.match(/^(\d{4}(?:\s+(?:Deferred|Sample|Preview|[A-Z][a-z]+))?)/);
          return match ? match[1] : null;
        };
        
        const yearTotals: Record<string, number> = {};
        allQuestions.forEach((q: any) => {
          const year = extractYear(q.name);
          if (year) {
            yearTotals[year] = (yearTotals[year] || 0) + 1;
          }
        });
        
        // Get user's completed attempts by year from database-rendered grid
        const cards = Array.from(grid?.querySelectorAll('[data-attempt]') || []);
        const unique = new Map<string, Element>();
        cards.forEach(c => { const id = c.getAttribute('data-attempt'); if(id) unique.set(id,c); });
        
        const yearCompleted: Record<string, number> = {};
        
        unique.forEach(card => {
          const titleEl = card.querySelector('h2 a');
          if (titleEl) {
            const name = titleEl.textContent;
            const year = extractYear(name);
            if (year) {
              yearCompleted[year] = (yearCompleted[year] || 0) + 1;
            }
          }
        });
        
        // Get all years and sort (newest first)
        const years = Object.keys(yearTotals).sort().reverse();
        
        // Render year pills
        const container = document.getElementById('year-pills-container');
        if (!container) return;
        
        container.innerHTML = '';
        
        years.forEach(year => {
          const completed = yearCompleted[year] || 0;
          const total = yearTotals[year] || 0;
          
          // Replace "Project" with "Project Maths" in year display
          const displayYear = year.replace(/\bProject\b/i, 'Project Maths');
          
          const pill = document.createElement('div');
          pill.className = 'flex-shrink-0 flex items-center gap-2 px-3 py-1.5 rounded-full bg-gray-200 text-gray-700 dark:bg-gray-700 dark:text-gray-300 transition-all duration-300';
          pill.innerHTML = `
            <span class="text-sm font-medium">${displayYear}</span>
            <span class="text-xs opacity-70">(${completed}/${total})</span>
          `;
          container.appendChild(pill);
        });
        
        // Update navigation button states
        updateYearScrollButtons();
      }

      // Year navigation handlers
      function updateYearScrollButtons() {
        const container = document.getElementById('year-pills-container');
        const leftBtn = document.getElementById('year-scroll-left');
        const rightBtn = document.getElementById('year-scroll-right');
        
        if (!container || !leftBtn || !rightBtn) return;
        
        const parentWidth = container.parentElement?.clientWidth || 0;
        const maxScroll = Math.max(0, container.scrollWidth - parentWidth);
        const currentTransform = container.style.transform;
        const currentOffset = currentTransform ? 
          parseInt(currentTransform.match(/-?\d+/)?.[0] || '0') : 0;
        
        // Disable left button if at start
        if (currentOffset >= 0) {
          leftBtn.setAttribute('disabled', 'true');
        } else {
          leftBtn.removeAttribute('disabled');
        }
        
        // Disable right button if at end
        if (Math.abs(currentOffset) >= maxScroll) {
          rightBtn.setAttribute('disabled', 'true');
        } else {
          rightBtn.removeAttribute('disabled');
        }
      }

      function scrollYears(direction: 'left' | 'right') {
        const container = document.getElementById('year-pills-container');
        if (!container || !container.parentElement) return;
        
        const parentWidth = container.parentElement.clientWidth;
        const pills = Array.from(container.children) as HTMLElement[];
        
        if (pills.length === 0) return;
        
        const currentTransform = container.style.transform;
        const currentOffset = currentTransform ? 
          parseInt(currentTransform.match(/-?\d+/)?.[0] || '0') : 0;
        
        let newOffset = currentOffset;
        
        if (direction === 'left') {
          // Scroll left - show the previous pill (one that's currently hidden on the left)
          // Find the first pill that's currently cut off or hidden on the left
          for (let i = pills.length - 1; i >= 0; i--) {
            const pillLeft = pills[i].offsetLeft + currentOffset;
            const pillRight = pillLeft + pills[i].offsetWidth;
            
            // If this pill's right edge is just before or at the container start (hidden/cut off on left)
            if (pillRight <= 0 || pillLeft < 0) {
              // Scroll to show this pill fully
              newOffset = -pills[i].offsetLeft;
              break;
            }
          }
          
          // If no hidden pill found (we're at the start), stay at 0
          if (newOffset === currentOffset) {
            newOffset = 0;
          }
        } else {
          // Scroll right - hide the leftmost visible pill and show the next one on the right
          // Find the first pill that's currently fully or partially visible
          let firstVisibleIndex = -1;
          for (let i = 0; i < pills.length; i++) {
            const pillLeft = pills[i].offsetLeft + currentOffset;
            const pillRight = pillLeft + pills[i].offsetWidth;
            
            // This pill is at least partially visible
            if (pillRight > 0 && pillLeft < parentWidth) {
              firstVisibleIndex = i;
              break;
            }
          }
          
          // Scroll to hide this pill and show the next one
          if (firstVisibleIndex >= 0 && firstVisibleIndex < pills.length - 1) {
            const nextPillIndex = firstVisibleIndex + 1;
            newOffset = -pills[nextPillIndex].offsetLeft;
          }
        }
        
        const maxScroll = Math.max(0, container.scrollWidth - parentWidth);
        currentYearScrollOffset = Math.max(-maxScroll, Math.min(0, newOffset));
        
        container.style.transform = `translateX(${currentYearScrollOffset}px)`;
        updateYearScrollButtons();
      }

      // Setup navigation buttons for years
      const yearScrollLeft = document.getElementById('year-scroll-left');
      const yearScrollRight = document.getElementById('year-scroll-right');
      
      if (yearScrollLeft) {
        yearScrollLeft.addEventListener('click', () => scrollYears('left'));
      }
      
      if (yearScrollRight) {
        yearScrollRight.addEventListener('click', () => scrollYears('right'));
      }

      // Paper pills (Paper 1, Paper 2) - no scrolling needed
      async function updatePaperStats() {
        const container = document.getElementById('paper-pills-container');
        if (!container) return;

        container.innerHTML = '';
        const papers = [
          { label: 'Paper 1', pattern: 'P1' },
          { label: 'Paper 2', pattern: 'P2' }
        ];

        // Fetch all questions to get totals
        const response = await fetch(`${backendBase}/api/questions/all`, { credentials: 'include' });
        const allQuestions = await response.json();

        for (const paper of papers) {
          // Count completed from user's database attempts in grid
          const grid = document.getElementById('attempts-grid');
          const cards = Array.from(grid?.querySelectorAll('[data-attempt]') || []);
          const unique = new Map<string, Element>();
          cards.forEach(c => { const id = c.getAttribute('data-attempt'); if(id) unique.set(id,c); });

          let completed = 0;

          unique.forEach(card => {
            const nameEl = card.querySelector('[data-question-name]');
            const name = nameEl?.getAttribute('data-question-name');
            if (name && name.includes(paper.pattern)) {
              completed++;
            }
          });

          // Count total from all questions
          const total = allQuestions.filter((q: any) => {
            return q.name && q.name.includes(paper.pattern);
          }).length;

          const pill = document.createElement('div');
          pill.className = 'flex-shrink-0 flex items-center gap-2 px-3 py-1.5 rounded-full bg-gray-200 text-gray-700 dark:bg-gray-700 dark:text-gray-300';
          pill.innerHTML = `
            <span class="text-sm font-medium">${paper.label}</span>
            <span class="text-xs opacity-70">(${completed}/${total})</span>
          `;
          container.appendChild(pill);
        }
      }

      // Topic pills
      let currentTopicScrollOffset = 0;

      async function updateTopicStats() {
        const container = document.getElementById('topic-pills-container');
        if (!container) return;

        container.innerHTML = '';
        const topics = [
          'algebra',
          'complex-numbers',
          'differentiation',
          'financial-mathematics',
          'geometry',
          'induction',
          'integration',
          'probability',
          'sequences-and-series',
          'statistics',
          'the-circle',
          'the-line',
          'trigonometry'
        ];

        const topicLabels: Record<string, string> = {
          'algebra': 'Algebra',
          'complex-numbers': 'Complex Numbers',
          'differentiation': 'Differentiation',
          'financial-mathematics': 'Financial Mathematics',
          'geometry': 'Geometry',
          'induction': 'Induction',
          'integration': 'Integration',
          'probability': 'Probability',
          'sequences-and-series': 'Sequences and Series',
          'statistics': 'Statistics',
          'the-circle': 'The Circle',
          'the-line': 'The Line',
          'trigonometry': 'Trigonometry'
        };

        // Fetch all questions to get totals
        const response = await fetch(`${backendBase}/api/questions/all`, { credentials: 'include' });
        const allQuestions = await response.json();

        for (const topic of topics) {
          // Count completed from user's database attempts in grid
          const grid = document.getElementById('attempts-grid');
          const cards = Array.from(grid?.querySelectorAll('[data-attempt]') || []);
          const unique = new Map<string, Element>();
          cards.forEach(c => { const id = c.getAttribute('data-attempt'); if(id) unique.set(id,c); });

          let completed = 0;
          unique.forEach(card => {
            const topics = Array.from(card.querySelectorAll('[data-topic]')).map(e=>e.getAttribute('data-topic')).filter((v): v is string => !!v);
            let match = topics.includes(topic);
            if (!match && topics.length === 0) {
              const id = card.getAttribute('data-attempt') || '';
              if (id.split('-')[0] === topic) match = true;
            }
            if (match) completed++;
          });

          // Count total from all questions
          let total = 0;
          allQuestions.forEach((q: any) => {
            if (Array.isArray(q.topic)) {
              const occurrences = q.topic.filter((t: string) => t === topic).length;
              total += occurrences;
            } else if (q.topic === topic) {
              total += 1;
            } else if (!q.topic && q.name?.startsWith(topic)) {
              total += 1;
            }
          });

          const pill = document.createElement('div');
          pill.className = 'flex-shrink-0 flex items-center gap-2 px-3 py-1.5 rounded-full bg-gray-200 text-gray-700 dark:bg-gray-700 dark:text-gray-300';
          pill.innerHTML = `
            <span class="text-sm font-medium">${topicLabels[topic] || topic}</span>
            <span class="text-xs opacity-70">(${completed}/${total})</span>
          `;
          container.appendChild(pill);
        }

        updateTopicScrollButtons();
      }

      function updateTopicScrollButtons() {
        const container = document.getElementById('topic-pills-container');
        const leftBtn = document.getElementById('topic-scroll-left');
        const rightBtn = document.getElementById('topic-scroll-right');
        
        if (!container || !leftBtn || !rightBtn) return;
        
        const parentWidth = container.parentElement?.clientWidth || 0;
        const maxScroll = Math.max(0, container.scrollWidth - parentWidth);
        const currentTransform = container.style.transform;
        const currentOffset = currentTransform ? 
          parseInt(currentTransform.match(/-?\d+/)?.[0] || '0') : 0;
        
        if (currentOffset >= 0) {
          leftBtn.setAttribute('disabled', 'true');
        } else {
          leftBtn.removeAttribute('disabled');
        }
        
        if (Math.abs(currentOffset) >= maxScroll) {
          rightBtn.setAttribute('disabled', 'true');
        } else {
          rightBtn.removeAttribute('disabled');
        }
      }

      function scrollTopics(direction: 'left' | 'right') {
        const container = document.getElementById('topic-pills-container');
        if (!container || !container.parentElement) return;
        
        const parentWidth = container.parentElement.clientWidth;
        const pills = Array.from(container.children) as HTMLElement[];
        
        if (pills.length === 0) return;
        
        const currentTransform = container.style.transform;
        const currentOffset = currentTransform ? 
          parseInt(currentTransform.match(/-?\d+/)?.[0] || '0') : 0;
        
        let newOffset = currentOffset;
        
        if (direction === 'left') {
          for (let i = pills.length - 1; i >= 0; i--) {
            const pillLeft = pills[i].offsetLeft + currentOffset;
            const pillRight = pillLeft + pills[i].offsetWidth;
            if (pillRight <= 0 || pillLeft < 0) {
              newOffset = -pills[i].offsetLeft;
              break;
            }
          }
          if (newOffset === currentOffset) {
            newOffset = 0;
          }
        } else {
          let firstVisibleIndex = -1;
          for (let i = 0; i < pills.length; i++) {
            const pillLeft = pills[i].offsetLeft + currentOffset;
            const pillRight = pillLeft + pills[i].offsetWidth;
            if (pillRight > 0 && pillLeft < parentWidth) {
              firstVisibleIndex = i;
              break;
            }
          }
          if (firstVisibleIndex >= 0 && firstVisibleIndex < pills.length - 1) {
            const nextPillIndex = firstVisibleIndex + 1;
            newOffset = -pills[nextPillIndex].offsetLeft;
          }
        }
        
        const maxScroll = Math.max(0, container.scrollWidth - parentWidth);
        currentTopicScrollOffset = Math.max(-maxScroll, Math.min(0, newOffset));
        
        container.style.transform = `translateX(${currentTopicScrollOffset}px)`;
        updateTopicScrollButtons();
      }

      const topicScrollLeft = document.getElementById('topic-scroll-left');
      const topicScrollRight = document.getElementById('topic-scroll-right');
      
      if (topicScrollLeft) {
        topicScrollLeft.addEventListener('click', () => scrollTopics('left'));
      }
      
      if (topicScrollRight) {
        topicScrollRight.addEventListener('click', () => scrollTopics('right'));
      }

      // Question Type pills (State, Custom) - no scrolling needed
      async function updateTypeStats() {
        const container = document.getElementById('type-pills-container');
        if (!container) return;

        container.innerHTML = '';
        const types = ['State', 'Custom'];

        // Fetch all questions to get totals
        const response = await fetch(`${backendBase}/api/questions/all`, { credentials: 'include' });
        const allQuestions = await response.json();

        for (const type of types) {
          // Count completed from user's database attempts in grid
          const grid = document.getElementById('attempts-grid');
          const cards = Array.from(grid?.querySelectorAll('[data-attempt]') || []);
          const unique = new Map<string, Element>();
          cards.forEach(c => { const id = c.getAttribute('data-attempt'); if(id) unique.set(id,c); });

          let completed = 0;

          unique.forEach(card => {
            const nameEl = card.querySelector('[data-question-name]');
            const name = nameEl?.getAttribute('data-question-name');
            if (name) {
              // Infer type: State questions have year patterns like "2024", "2023 Deferred", etc.
              const hasYear = /^\d{4}/.test(name);
              const isState = hasYear;
              if ((type === 'State' && isState) || (type === 'Custom' && !isState)) {
                completed++;
              }
            }
          });

          // Count total from all questions
          const total = allQuestions.filter((q: any) => {
            const hasYear = q.name && /^\d{4}/.test(q.name);
            const isState = hasYear;
            return (type === 'State' && isState) || (type === 'Custom' && !isState);
          }).length;

          const pill = document.createElement('div');
          pill.className = 'flex-shrink-0 flex items-center gap-2 px-3 py-1.5 rounded-full bg-gray-200 text-gray-700 dark:bg-gray-700 dark:text-gray-300';
          pill.innerHTML = `
            <span class="text-sm font-medium">${type}</span>
            <span class="text-xs opacity-70">(${completed}/${total})</span>
          `;
          container.appendChild(pill);
        }
      }

      // Initial load of all stats
      updateDifficultyProportions();
      updateYearStats();
      updatePaperStats();
      updateTopicStats();
      updateTypeStats();

      // Invalidate cache when new questions might be added (listen to storage events)
      window.addEventListener('storage', (ev) => {
        if (ev.key === 'questionAttempts') {
          // Don't invalidate cache for attempts, only for actual question changes
          return;
        }
      });

      // Manual cache refresh function (can be called when questions are added)
      interface WindowWithRefresh extends Window {
        refreshQuestionCache?: () => void;
      }
      (window as WindowWithRefresh).refreshQuestionCache = () => {
        updateDifficultyProportions();
        updateYearStats();
        updatePaperStats();
        updateTopicStats();
        updateTypeStats();
      };

      // Update stats when topic changes
      if (topicSelect) {
        const originalListener = () => {
          recomputeProgress();
        };
        topicSelect.removeEventListener('change', recomputeProgress);
        topicSelect.addEventListener('change', originalListener);
      }
    })();

    // Profile management
    (async function profileManagement() {
      const API_BASE = 'http://localhost:3001/api/user-auth';
      const profileLoading = document.getElementById('profile-loading');
      const profileFormContainer = document.getElementById('profile-form-container');
      const nameError = document.getElementById('name-error');
      const nameSuccess = document.getElementById('name-success');
      
      let currentFirstName = '';
      let currentLastName = '';

      // Load user profile
      async function loadProfile() {
        try {
          const response = await fetch(`${API_BASE}/me`, {
            credentials: 'include'
          });
          
          if (!response.ok) {
            if (response.status === 401) {
              window.location.href = '/login?returnTo=/progress';
              return;
            }
            throw new Error('Failed to load profile');
          }
          
          const data = await response.json();
          const user = data.user;
          
          // Populate form fields
          const firstNameInput = document.getElementById('firstName') as HTMLInputElement;
          const lastNameInput = document.getElementById('lastName') as HTMLInputElement;
          const emailInput = document.getElementById('email') as HTMLInputElement;
          
          if (firstNameInput) {
            firstNameInput.value = user.firstName || '';
            currentFirstName = user.firstName || '';
          }
          if (lastNameInput) {
            lastNameInput.value = user.lastName || '';
            currentLastName = user.lastName || '';
          }
          if (emailInput) emailInput.value = user.email || '';
          
          // Show profile form
          if (profileLoading) profileLoading.classList.add('hidden');
          if (profileFormContainer) profileFormContainer.classList.remove('hidden');
        } catch (error) {
          console.error('Error loading profile:', error);
          if (profileLoading) {
            profileLoading.innerHTML = '<p class="text-red-500">Failed to load profile</p>';
          }
        }
      }

      // Update profile function
      async function updateProfile(firstName: string, lastName: string) {
        if (nameError) nameError.classList.add('hidden');
        if (nameSuccess) nameSuccess.classList.add('hidden');
        
        if (!firstName.trim()) {
          if (nameError) {
            nameError.textContent = 'First name is required';
            nameError.classList.remove('hidden');
          }
          return false;
        }
        
        try {
          const response = await fetch(`${API_BASE}/update-profile`, {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json',
            },
            credentials: 'include',
            body: JSON.stringify({
              firstName: firstName.trim(),
              lastName: lastName.trim()
            })
          });
          
          if (!response.ok) {
            const data = await response.json();
            throw new Error(data.message || 'Failed to update profile');
          }
          
          // Update stored values
          currentFirstName = firstName.trim();
          currentLastName = lastName.trim();
          
          if (nameSuccess) {
            nameSuccess.textContent = 'Profile updated successfully!';
            nameSuccess.classList.remove('hidden');
          }
          
          // Update the header username if it exists
          const authStatus = document.getElementById('auth-status');
          if (authStatus) {
            const menuBtn = authStatus.querySelector('#user-menu-btn');
            if (menuBtn) {
              // Update the button text to show new name
              const nameText = menuBtn.childNodes[2]; // The text node between the SVGs
              if (nameText && nameText.nodeType === Node.TEXT_NODE) {
                nameText.textContent = ` ${firstName.trim()} `;
              }
            }
          }
          
          setTimeout(() => {
            if (nameSuccess) nameSuccess.classList.add('hidden');
          }, 3000);
          
          return true;
        } catch (error) {
          if (nameError) {
            nameError.textContent = error instanceof Error ? error.message : 'Failed to update profile';
            nameError.classList.remove('hidden');
          }
          return false;
        }
      }

      // Handle blur events on name fields
      const firstNameInput = document.getElementById('firstName') as HTMLInputElement;
      const lastNameInput = document.getElementById('lastName') as HTMLInputElement;
      
      if (firstNameInput) {
        firstNameInput.addEventListener('blur', async () => {
          const newFirstName = firstNameInput.value.trim();
          const currentLastNameValue = lastNameInput?.value.trim() || '';
          
          if (newFirstName !== currentFirstName) {
            await updateProfile(newFirstName, currentLastNameValue);
          }
        });
      }
      
      if (lastNameInput) {
        lastNameInput.addEventListener('blur', async () => {
          const newLastName = lastNameInput.value.trim();
          const currentFirstNameValue = firstNameInput?.value.trim() || '';
          
          if (newLastName !== currentLastName) {
            await updateProfile(currentFirstNameValue, newLastName);
          }
        });
      }

      // Load profile on page load
      loadProfile();
    })();
  </script>
  <style>
    .notes-clamped { max-height: 4.5rem; overflow: hidden; position: relative; }
    .notes-clamped.expanded { max-height: none; }
    .notes-clamped::after { content: ''; position: absolute; bottom: 0; left:0; right:0; height:1.5rem; background: linear-gradient(to bottom, rgba(255,255,255,0), var(--tw-bg-opacity,#fff)); pointer-events:none; }
    .dark .notes-clamped::after { background: linear-gradient(to bottom, rgba(15,23,42,0), rgba(15,23,42,1)); }
    .notes-clamped.expanded::after { display: none; }
  </style>
</Layout>
