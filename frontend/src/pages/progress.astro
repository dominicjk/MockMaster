---
import Layout from '~/layouts/PageLayout.astro';

interface QuestionMeta { name?: string; topic?: string | string[]; difficulty?: number | string; timeLimitSeconds?: number }
interface Attempt {
  questionId: string;
  completedAt?: string;
  timeTakenSeconds?: number | null;
  notes: string;
  question?: QuestionMeta | null;
  difficulty?: number | string | null;
}
interface RawAttempt {
  questionId: string;
  completedAt?: string;
  timestamp?: string;
  lastUpdatedAt?: string;
  timeTakenSeconds?: number;
  timeTaken?: number;
  notes?: string;
  question?: QuestionMeta | null;
  difficulty?: number | string;
}

const BACKEND_BASE = import.meta.env.PUBLIC_BACKEND_URL || 'http://localhost:3001';
let attempts: Attempt[] = [];
let stats: { total: number; topics: Record<string, number> } | null = null;
let TOPIC_LABELS: Record<string, string> = {};

// Note: Server-side rendering will show empty state initially
// Client-side will fetch attempts from database and display loading spinner
// This is intentional to avoid blocking page load

// Load question stats (counts) for progress bars
try {
  const sr = await fetch(`${BACKEND_BASE}/api/questions/stats`);
  if (sr.ok) {
    stats = await sr.json();
  }
  if (stats && stats.topics) {
    const topicsObj = stats.topics; // local alias for non-null assertion clarity
    // Merge Financial Maths variants into a single canonical key 'financial-maths'
    const financialVariants = ['financial-mathematics', 'financial mathematics'];
    let financialMerged = 0;
    financialVariants.forEach(v => {
      if (topicsObj[v]) { financialMerged += topicsObj[v]; delete topicsObj[v]; }
    });
    if (financialMerged) topicsObj['financial-maths'] = (topicsObj['financial-maths'] || 0) + financialMerged;

    // Remove combined Probability-Statistics synthetic grouping (prob-stat variants)
    const probCombined = ['prob-stat','prob stat','probability-statistics','probability statistics'];
  probCombined.forEach(v => { if (topicsObj[v]) delete topicsObj[v]; });

    // Build labels with special mappings, excluding combined group completely
    const toTitle = (slug: string) => slug.split(/[-_ ]+/).map(w => w ? w[0].toUpperCase() + w.slice(1) : '').join(' ');
    const specialLabelMap: Record<string,string> = {
      'financial-maths': 'Financial Maths'
    };
    TOPIC_LABELS = Object.fromEntries(
  Object.keys(topicsObj)
        .filter(k => !probCombined.includes(k.toLowerCase()))
        .map(k => {
          const lower = k.toLowerCase();
          if (specialLabelMap[lower]) return [k, specialLabelMap[lower]];
          if (lower === 'financial-mathematics' || lower === 'financial mathematics') return [k, 'Financial Maths'];
          if (probCombined.includes(lower)) return [k, '']; // shouldn't reach due to filter
          return [k, toTitle(k)];
        })
    );
  }
} catch { /* ignore stats fetch failure */ }

// Sort attempts newest first
attempts.sort((a,b) => {
  const ta = a.completedAt ? new Date(a.completedAt).getTime() : 0;
  const tb = b.completedAt ? new Date(b.completedAt).getTime() : 0;
  return tb - ta;
});

// Precompute display meta to simplify template (avoids complex logic in JSX section)
interface DisplayTopic { slug: string; label: string }
interface AttemptView { a: Attempt; diffLabel: string | null; diffText: string | null; diffClasses: string; topics: DisplayTopic[]; timeLimitSeconds: number | null; overLimit: boolean }
const attemptViews: AttemptView[] = attempts.map(a => {
  const diffRaw = a.difficulty ?? a.question?.difficulty;
  let diffLabel: string | null = null; // original raw label
  let diffText: string | null = null; // normalized Easy / Medium / Hard / Very Hard
  let diffClasses = '';
  if (diffRaw !== undefined && diffRaw !== null && diffRaw !== '') {
    diffLabel = String(diffRaw);
    const num = parseInt(diffLabel, 10);
    if (!isNaN(num)) {
      if (num <= 1) { diffText = 'Easy'; diffClasses = 'bg-green-100 text-green-700 dark:bg-green-900/40 dark:text-green-300'; }
      else if (num === 2) { diffText = 'Medium'; diffClasses = 'bg-orange-100 text-orange-700 dark:bg-orange-900/40 dark:text-orange-300'; }
      else if (num === 3) { diffText = 'Hard'; diffClasses = 'bg-red-100 text-red-700 dark:bg-red-900/40 dark:text-red-300'; }
      else { diffText = 'Very Hard'; diffClasses = 'bg-purple-100 text-purple-700 dark:bg-purple-900/40 dark:text-purple-300'; }
    } else {
      const lower = diffLabel.toLowerCase();
      if (/(^|\b)(easy|low)(\b|$)/.test(lower)) { diffText = 'Easy'; diffClasses = 'bg-green-100 text-green-700 dark:bg-green-900/40 dark:text-green-300'; }
      else if (/(^|\b)(med|medium|moderate)(\b|$)/.test(lower)) { diffText = 'Medium'; diffClasses = 'bg-orange-100 text-orange-700 dark:bg-orange-900/40 dark:text-orange-300'; }
      else if (/(^|\b)(very.?hard|extremely.?hard|veryhard)(\b|$)/.test(lower)) { diffText = 'Very Hard'; diffClasses = 'bg-purple-100 text-purple-700 dark:bg-purple-900/40 dark:text-purple-300'; }
      else { diffText = 'Hard'; diffClasses = 'bg-red-100 text-red-700 dark:bg-red-900/40 dark:text-red-300'; }
    }
  }
  const topicSlugs: string[] = a.question ? (Array.isArray(a.question.topic) ? a.question.topic : [a.question.topic]).filter(Boolean) as string[] : [];
  const canonical = (slug: string) => {
    const lower = slug.toLowerCase();
    if (lower === 'financial-mathematics' || lower === 'financial mathematics') return 'financial-maths';
    if (lower === 'prob-stat' || lower === 'prob stat' || lower === 'probability-statistics' || lower === 'probability statistics') return ''; // drop combined
    return slug;
  };
  const seenLabels = new Set<string>();
  const topics: DisplayTopic[] = [];
  topicSlugs.forEach(raw => {
    const slug = canonical(raw);
    if (!slug) return; // dropped combined group
    const label = TOPIC_LABELS[slug] || slug.split(/[-_ ]+/).map(w=>w? w[0].toUpperCase()+w.slice(1):'').join(' ');
    if (seenLabels.has(label)) return;
    seenLabels.add(label);
    topics.push({ slug, label });
  });
  const timeLimitSeconds = a.question?.timeLimitSeconds ?? null;
  const overLimit = timeLimitSeconds != null && a.timeTakenSeconds != null && a.timeTakenSeconds > timeLimitSeconds;
  return { a, diffLabel, diffText, diffClasses, topics, timeLimitSeconds, overLimit };
});

// Client will optionally augment with local attempts if none from server.
---

<Layout metadata={{ title: 'Your Profile' }}>
  <style>
    /* Custom dropdown styling for rounder appearance */
    #topic-filter option {
      border-radius: 0.5rem;
      padding: 0.5rem;
    }
    
    /* Style the dropdown container for rounded corners */
    #topic-filter {
      border-radius: 0.75rem;
    }
  </style>
  
  <div class="min-h-screen bg-gradient-to-br from-pink-50 via-white to-pink-50 dark:from-slate-900 dark:via-slate-800 dark:to-slate-900">
  <section class="max-w-6xl mx-auto px-4 py-10">
    
    <!-- User Profile Section -->
    <!-- User Profile and Progress Stats - Side by Side -->
    <div class="mb-6 grid grid-cols-1 lg:grid-cols-[1fr_3fr] gap-4 max-w-full overflow-hidden">
      <!-- User Profile Section -->
      <div class="bg-white/70 dark:bg-slate-800/70 backdrop-blur-sm rounded-xl p-3 border border-pink-100/50 dark:border-slate-700/50 min-w-0 flex flex-col" style="box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1);">
        <h2 class="text-base font-bold text-gray-800 dark:text-gray-100 mb-3">User Profile</h2>
        
        <!-- Loading State -->
        <div id="profile-loading" class="text-center py-2">
          <p class="text-gray-600 dark:text-gray-400 text-xs">Loading profile...</p>
        </div>

        <!-- Profile Content -->
        <div id="profile-form-container" class="hidden flex-1 flex flex-col">
          <div class="space-y-2">
            <div>
              <label for="firstName" class="block text-xs font-medium mb-1 text-gray-700 dark:text-gray-300">First Name</label>
              <div class="relative">
                <input
                  type="text"
                  id="firstName"
                  name="firstName"
                  required
                  maxlength="50"
                  class="w-full px-2.5 py-1 pr-8 text-xs border rounded-lg focus:ring-2 focus:ring-blue-500 dark:bg-slate-700 dark:border-slate-600 dark:text-gray-100"
                />
                <button
                  id="save-firstName"
                  class="hidden absolute right-1 top-1/2 -translate-y-1/2 w-6 h-6 flex items-center justify-center rounded bg-green-500 hover:bg-green-600 text-white transition"
                  title="Save first name"
                >
                  <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"/>
                  </svg>
                </button>
              </div>
            </div>
            
            <div>
              <label for="lastName" class="block text-xs font-medium mb-1 text-gray-700 dark:text-gray-300">Last Name</label>
              <div class="relative">
                <input
                  type="text"
                  id="lastName"
                  name="lastName"
                  maxlength="50"
                  class="w-full px-2.5 py-1 pr-8 text-xs border rounded-lg focus:ring-2 focus:ring-blue-500 dark:bg-slate-700 dark:border-slate-600 dark:text-gray-100"
                />
                <button
                  id="save-lastName"
                  class="hidden absolute right-1 top-1/2 -translate-y-1/2 w-6 h-6 flex items-center justify-center rounded bg-green-500 hover:bg-green-600 text-white transition"
                  title="Save last name"
                >
                  <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"/>
                  </svg>
                </button>
              </div>
            </div>
            
            <div>
              <label for="email" class="block text-xs font-medium mb-1 text-gray-700 dark:text-gray-300">Email</label>
              <input
                type="email"
                id="email"
                disabled
                class="w-full px-2.5 py-1 text-xs border rounded-lg bg-gray-100 dark:bg-slate-900 dark:border-slate-600 cursor-not-allowed text-gray-600 dark:text-gray-400"
              />
            </div>
        
            <div id="name-error" class="text-red-500 text-xs hidden"></div>
          </div>
        </div>
      </div>
      
      <!-- Progress Stats Section -->
      <div class="bg-white/70 dark:bg-slate-800/70 backdrop-blur-sm rounded-xl p-3 border border-pink-100/50 dark:border-slate-700/50 min-w-0 overflow-hidden flex flex-col" style="box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1);">
        <!-- Difficulty Stats -->
        <div class="flex items-center gap-2 mb-3">
          <div class="w-7 flex-shrink-0"></div> <!-- Spacer to align with scroll buttons -->
          <div class="flex flex-wrap items-center gap-2 flex-1">
            <div class="flex items-center gap-1.5 px-2 py-1 rounded-full bg-green-100 text-green-700 dark:bg-green-900/40 dark:text-green-300 cursor-pointer hover:opacity-80 transition" data-pill-type="difficulty" data-pill-value="Easy">
              <span class="text-xs font-medium">Easy</span>
              <span id="easy-proportion" class="text-xs opacity-70"></span>
            </div>
            <div class="flex items-center gap-1.5 px-2 py-1 rounded-full bg-orange-100 text-orange-700 dark:bg-orange-900/40 dark:text-orange-300 cursor-pointer hover:opacity-80 transition" data-pill-type="difficulty" data-pill-value="Medium">
              <span class="text-xs font-medium">Medium</span>
              <span id="medium-proportion" class="text-xs opacity-70"></span>
            </div>
            <div class="flex items-center gap-1.5 px-2 py-1 rounded-full bg-red-100 text-red-700 dark:bg-red-900/40 dark:text-red-300 cursor-pointer hover:opacity-80 transition" data-pill-type="difficulty" data-pill-value="Hard">
              <span class="text-xs font-medium">Hard</span>
              <span id="hard-proportion" class="text-xs opacity-70"></span>
            </div>
            <div class="flex items-center gap-1.5 px-2 py-1 rounded-full bg-purple-100 text-purple-700 dark:bg-purple-900/40 dark:text-purple-300 cursor-pointer hover:opacity-80 transition" data-pill-type="difficulty" data-pill-value="Very Hard">
              <span class="text-xs font-medium">Very Hard</span>
              <span id="very-hard-proportion" class="text-xs opacity-70"></span>
            </div>
          </div>
          <div class="w-7 flex-shrink-0"></div> <!-- Spacer to align with scroll buttons -->
        </div>

        <!-- Year Stats with Navigation -->
        <div class="flex items-center gap-2 mb-3">
          <!-- Left scroll button -->
          <button 
            id="year-scroll-left" 
            class="flex-shrink-0 w-7 h-7 flex items-center justify-center rounded-full bg-gray-200 dark:bg-slate-700 hover:bg-gray-300 dark:hover:bg-slate-600 transition disabled:opacity-30 disabled:cursor-not-allowed"
            aria-label="Scroll years left"
          >
            <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
            </svg>
          </button>

          <!-- Year pills container with horizontal scroll -->
          <div class="overflow-hidden flex-1">
            <div id="year-pills-container" class="flex gap-2 transition-transform duration-300" style="transform: translateX(0);">
              <!-- Year pills will be inserted here by JavaScript -->
            </div>
          </div>

          <!-- Right scroll button -->
          <button 
            id="year-scroll-right" 
            class="flex-shrink-0 w-7 h-7 flex items-center justify-center rounded-full bg-gray-200 dark:bg-slate-700 hover:bg-gray-300 dark:hover:bg-slate-600 transition disabled:opacity-30 disabled:cursor-not-allowed"
            aria-label="Scroll years right"
          >
            <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
            </svg>
          </button>
        </div>

        <!-- Paper Stats -->
        <div class="flex items-center gap-2 mb-3">
          <div class="w-7 flex-shrink-0"></div> <!-- Spacer to align with scroll buttons -->
          <div class="flex flex-wrap items-center gap-2 flex-1">
            <div id="paper-pills-container" class="flex gap-2">
              <!-- Paper pills will be inserted here by JavaScript -->
            </div>
          </div>
          <div class="w-7 flex-shrink-0"></div> <!-- Spacer to align with scroll buttons -->
        </div>

        <!-- Topic Stats with Navigation -->
        <div class="flex items-center gap-2 mb-3">
          <!-- Left scroll button -->
          <button 
            id="topic-scroll-left" 
            class="flex-shrink-0 w-7 h-7 flex items-center justify-center rounded-full bg-gray-200 dark:bg-slate-700 hover:bg-gray-300 dark:hover:bg-slate-600 transition disabled:opacity-30 disabled:cursor-not-allowed"
            aria-label="Scroll topics left"
          >
            <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
            </svg>
          </button>

          <!-- Topic pills container with horizontal scroll -->
          <div class="overflow-hidden flex-1">
            <div id="topic-pills-container" class="flex gap-2 transition-transform duration-300" style="transform: translateX(0);">
              <!-- Topic pills will be inserted here by JavaScript -->
            </div>
          </div>

          <!-- Right scroll button -->
          <button 
            id="topic-scroll-right" 
            class="flex-shrink-0 w-7 h-7 flex items-center justify-center rounded-full bg-gray-200 dark:bg-slate-700 hover:bg-gray-300 dark:hover:bg-slate-600 transition disabled:opacity-30 disabled:cursor-not-allowed"
            aria-label="Scroll topics right"
          >
            <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
            </svg>
          </button>
        </div>

        <!-- Question Type Stats -->
        <div class="flex items-center gap-2">
          <div class="w-7 flex-shrink-0"></div> <!-- Spacer to align with scroll buttons -->
          <div class="flex flex-wrap items-center gap-2 flex-1">
            <div id="type-pills-container" class="flex gap-2">
              <!-- Type pills will be inserted here by JavaScript -->
            </div>
          </div>
          <div class="w-7 flex-shrink-0"></div> <!-- Spacer to align with scroll buttons -->
        </div>
      </div>
    </div>
    
    {/* Loading spinner for attempts grid */}
    <div id="attempts-loading" class="flex flex-col items-center justify-center py-24">
      <div class="w-16 h-16 border-4 border-pink-200 dark:border-pink-800 border-t-pink-600 dark:border-t-pink-400 rounded-full animate-spin mb-4"></div>
      <p class="text-gray-600 dark:text-gray-400 text-lg">Loading your attempts...</p>
    </div>
    
    {/* Auth warning removed intentionally */}
    <div id="empty-progress-state" class="hidden">
      <div class="flex flex-col items-center justify-center py-24 text-center text-gray-500 dark:text-gray-400">
        <div class="w-28 h-28 mb-6 opacity-60">
          <svg viewBox="0 0 120 120" class="w-full h-full" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="60" cy="60" r="36" stroke-dasharray="6 8" />
            <path d="M30 78c8 10 20 16 30 16 14 0 26-8 34-20M32 52c4-12 16-22 28-22 10 0 20 6 26 14M44 88c-4-4-8-10-10-16M82 84c2-6 4-14 2-20M52 34c-2 4-4 8-4 12" />
            <path d="M18 96c12 4 28 6 42 6 18 0 36-4 48-10" stroke-dasharray="4 10" />
          </svg>
        </div>
        <p class="text-lg font-medium mb-2">No completed attempts yet</p>
        <p class="max-w-md text-sm mb-6">Head over to Practice and solve your first question. Your progress will appear here once you save an attempt.</p>
        <a href="/maths/practice" class="inline-flex items-center px-5 py-2.5 rounded-lg bg-red-200 text-red-800 font-medium hover:bg-red-300 dark:bg-red-900 dark:text-red-200 dark:hover:bg-red-800 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-400 dark:focus:ring-offset-slate-900 transition">Go to Practice</a>
      </div>
    </div>
    
    {/* Empty state for filtered results */}
    <div id="filtered-empty-state" class="hidden">
      <div class="flex flex-col items-center justify-center py-24 text-center text-gray-500 dark:text-gray-400">
        <div class="w-24 h-24 mb-6 opacity-60">
          <svg viewBox="0 0 24 24" class="w-full h-full" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="11" cy="11" r="8"></circle>
            <path d="m21 21-4.35-4.35"></path>
            <line x1="11" y1="8" x2="11" y2="14"></line>
            <line x1="8" y1="11" x2="14" y2="11"></line>
          </svg>
        </div>
        <p class="text-lg font-medium mb-2">No matching attempts</p>
        <p class="max-w-md text-sm mb-6">No attempts found matching your current filters. Try selecting different filters.</p>
      </div>
    </div>
  <div id="topic-labels" data-topic-labels={JSON.stringify(TOPIC_LABELS)} class="hidden"></div>
  {stats && <div id="progress-stats" data-stats={JSON.stringify(stats)} class="hidden"></div>}
  
  <!-- Attempts Container with Header -->
  <div class="hidden" id="attempts-container">
    <div class="flex items-center justify-between mb-4">
      <!-- Filter Dropdown Button -->
      <div class="relative">
        <button id="filter-toggle-btn" class="inline-flex items-center justify-center gap-1.5 h-7 px-3 rounded-lg text-gray-600 hover:text-gray-900 dark:text-gray-400 dark:hover:text-gray-100 hover:bg-gray-100 dark:hover:bg-slate-700 transition text-xs font-medium" title="Sort attempts">
          <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"/></svg>
          <span id="filter-label">Sort</span>
        </button>
        
        <!-- Dropdown Menu -->
        <div id="filter-dropdown" class="hidden absolute left-0 top-full mt-1 w-48 bg-white dark:bg-slate-800 rounded-lg shadow-lg border border-gray-200 dark:border-slate-700 py-1 z-50">
          <button class="sort-option w-full px-4 py-2 text-left text-sm text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-slate-700 transition flex items-center justify-between" data-sort="recent">
            <span>Most Recent</span>
            <svg class="h-4 w-4 text-gray-500 dark:text-gray-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"/></svg>
          </button>
          <button class="sort-option w-full px-4 py-2 text-left text-sm text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-slate-700 transition flex items-center justify-between" data-sort="oldest">
            <span>Least Recent</span>
            <svg class="h-4 w-4 text-gray-500 dark:text-gray-400 hidden" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"/></svg>
          </button>
        </div>
      </div>
      
      <!-- Progress Circle with Count -->
      <div class="flex items-center gap-2">
        <span class="text-sm text-gray-700 dark:text-gray-300">
          <span id="completed-count-inline" class="font-semibold">{attempts.length}</span>
          <span class="text-gray-500 dark:text-gray-400">/{stats?.total || 0}</span>
        </span>
        <div class="relative w-7 h-7 flex-shrink-0">
          <svg class="w-full h-full transform -rotate-90" viewBox="0 0 48 48">
            <circle
              cx="24"
              cy="24"
              r="20"
              fill="none"
              stroke="currentColor"
              stroke-width="4"
              class="text-gray-200 dark:text-slate-700"
            />
            <circle
              id="mini-progress-bar-inline"
              cx="24"
              cy="24"
              r="20"
              fill="none"
              stroke="currentColor"
              stroke-width="4"
              stroke-linecap="round"
              class="text-blue-500 dark:text-blue-400 transition-all duration-500"
              style={`stroke-dasharray: ${2 * Math.PI * 20}; stroke-dashoffset: ${2 * Math.PI * 20 * (1 - (stats?.total ? Math.min(1, attempts.length / stats.total) : 0))}`}
            />
          </svg>
        </div>
      </div>
    </div>
  
    <div class="grid gap-4 md:gap-5" id="attempt-grid" data-backend={BACKEND_BASE}>
      {attemptViews.map(({ a, diffText, diffClasses, topics, overLimit }) => (
        <div class="rounded-xl border border-gray-200 dark:border-slate-700 bg-white dark:bg-slate-800 p-4 shadow-sm flex flex-col gap-3 transition-all duration-200 hover:shadow-md hover:bg-gray-50 dark:hover:bg-slate-750 hover:border-gray-300 dark:hover:border-slate-600 cursor-pointer" data-attempt={a.questionId} data-difficulty={diffText || ''} data-time={a.timeTakenSeconds || ''} data-question-name={a.question?.name || ''}>
          <div class="flex items-start justify-between gap-4">
            <div class="flex-1">
              <div class="flex flex-wrap items-center gap-3">
                {(() => {
                  const primaryTopic = (topics && topics.length) ? topics[0].slug : (a.questionId.split('-')[0] || 'unknown');
                  const practiceHref = `/maths/practice/${primaryTopic}?q=${a.questionId}`;
                  
                  // Format the display name
                  let displayName = a.question?.name || a.questionId;
                  // If it's a custom question (no year in name), format the ID
                  if (!a.question?.name || !/^\d{4}/.test(a.question.name)) {
                    // Format: alg-0007 -> Custom Algebra 7
                    const match = a.questionId.match(/^([a-z-]+)-0*(\d+)$/i);
                    if (match) {
                      const topicSlug = match[1];
                      const questionNum = match[2];
                      const topicLabel = TOPIC_LABELS[topicSlug] || topicSlug.split('-').map((w: string) => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
                      displayName = `Custom ${topicLabel} ${questionNum}`;
                    }
                  }
                  
                  return (
                    <h2 class="m-0 font-semibold text-gray-900 dark:text-gray-100 text-lg leading-tight">
                      <a href={practiceHref} class="focus:outline-none focus:ring-2 focus:ring-blue-500 rounded-sm">{displayName}</a>
                    </h2>
                  );
                })()}
                <div class="flex flex-wrap items-center gap-2 ml-1 pt-0.5">
                  {diffText && <span class={`inline-flex items-center px-2 py-1 rounded-md text-xs font-medium ${diffClasses}`} data-difficulty-chip>{diffText}</span>}
                  {topics.map(t => (
                    <span class="inline-flex items-center px-2 py-1 rounded-md text-xs font-medium bg-gray-100 dark:bg-slate-700 text-gray-700 dark:text-gray-300" data-topic={t.slug} title={t.slug}>{t.label}</span>
                  ))}
                </div>
              </div>
              <p class="text-xs text-gray-500 dark:text-gray-400 mt-1">{a.completedAt ? new Date(a.completedAt).toLocaleString() : ''}</p>
            </div>
            {a.timeTakenSeconds != null && a.timeTakenSeconds > 0 && (
              <div class="flex items-start gap-2">
                <span class={`inline-flex items-center h-7 px-2 py-1 rounded-md text-xs font-medium self-start ${overLimit ? 'bg-red-100 dark:bg-red-900 text-red-700 dark:text-red-300' : 'bg-blue-100 dark:bg-blue-900 text-blue-700 dark:text-blue-300'}`}
                  data-time-chip>
                  {Math.floor((a.timeTakenSeconds || 0) / 60).toString().padStart(2,'0')}:{((a.timeTakenSeconds || 0) % 60).toString().padStart(2,'0')}
                </span>
                <button class="edit-notes inline-flex items-center justify-center h-7 w-7 rounded-md border border-transparent hover:border-blue-500 text-gray-500 hover:text-blue-600 dark:text-gray-400 dark:hover:text-blue-400" title="Edit notes" data-question-id={a.questionId}>
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 3a2.83 2.83 0 0 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>
                </button>
              </div>
            )}
            {(!a.timeTakenSeconds || a.timeTakenSeconds === 0) && (
              <div class="flex items-start gap-2">
                <button class="edit-notes inline-flex items-center justify-center h-7 w-7 rounded-md border border-transparent hover:border-blue-500 text-gray-500 hover:text-blue-600 dark:text-gray-400 dark:hover:text-blue-400" title="Edit notes" data-question-id={a.questionId}>
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 3a2.83 2.83 0 0 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>
                </button>
              </div>
            )}
          </div>
          {a.notes && (
            <div class="relative">
              <div class="notes-clamped text-sm text-gray-700 dark:text-gray-300" data-full={a.notes}>{a.notes}</div>
              <button class="expand-notes absolute bottom-0 right-0 inline-flex items-center justify-center w-6 h-6 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 bg-white dark:bg-slate-800 rounded transition" title="Expand notes">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 24 24" fill="currentColor"><circle cx="12" cy="12" r="2"/><circle cx="19" cy="12" r="2"/><circle cx="5" cy="12" r="2"/></svg>
              </button>
            </div>
          )}
        </div>
      ))}
    </div>
  </div>
  </section>
  </div>

  <!-- Edit Notes Modal -->
  <div id="edit-notes-modal" class="fixed inset-0 bg-black bg-opacity-50 backdrop-blur-sm z-50 flex items-center justify-center hidden">
    <div class="bg-white dark:bg-slate-800 rounded-xl p-6 max-w-md w-full mx-4 shadow-xl">
      <h3 class="text-lg font-semibold text-gray-800 dark:text-gray-200 mb-4">Edit Attempt Notes</h3>
      <div class="mb-4">
        <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Question:</label>
        <div id="edit-modal-question-title" class="p-3 bg-gray-50 dark:bg-slate-700 rounded-lg text-gray-800 dark:text-gray-200">--</div>
      </div>
      <div class="mb-4">
        <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Time Taken:</label>
        <div id="edit-modal-time-taken" class="p-3 bg-gray-50 dark:bg-slate-700 rounded-lg font-mono text-gray-800 dark:text-gray-200">--:--</div>
      </div>
      <div class="mb-6">
        <label for="edit-attempt-notes" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Notes:</label>
        <textarea id="edit-attempt-notes" rows="4" class="w-full p-3 border border-gray-300 dark:border-slate-600 rounded-lg focus:ring-2 focus:ring-pink-500 focus:border-pink-500 dark:bg-slate-700 dark:text-gray-200 resize-none" placeholder="Update your notes for this attempt..."></textarea>
      </div>
      <div class="flex gap-3">
        <button id="cancel-edit-notes" class="flex-1 px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 dark:bg-slate-600 dark:text-gray-200 dark:hover:bg-slate-500">Cancel</button>
        <button id="confirm-edit-notes" class="flex-1 px-4 py-2 bg-pink-500 text-white rounded-lg hover:bg-pink-600 dark:bg-pink-600 dark:hover:bg-pink-700">Save Notes</button>
      </div>
    </div>
  </div>

  <!-- Toast Notification -->
  <div id="toast-notification" class="fixed bottom-0 left-1/2 -translate-x-1/2 mb-8 px-6 py-3 bg-green-500 text-white rounded-lg shadow-lg opacity-0 pointer-events-none transition-all duration-300 transform translate-y-4 z-50">
    <span id="toast-message">Profile updated successfully!</span>
  </div>

  <script>
    (function(){
      const grid = document.getElementById('attempt-grid');
      const attemptsContainer = document.getElementById('attempts-container');
      const emptyState = document.getElementById('empty-progress-state');
      const loadingSpinner = document.getElementById('attempts-loading');
      const progressStatsEl = document.getElementById('progress-stats');
      const topicLabelsEl = document.getElementById('topic-labels');
      let topicLabels: Record<string,string> = {};
      if (topicLabelsEl) { try { topicLabels = JSON.parse(topicLabelsEl.getAttribute('data-topic-labels') || '{}'); } catch { /* ignore */ } }
      const backendBase = grid?.getAttribute('data-backend') || 'http://localhost:3001';
      
      // Filter state - changed to array for stacked filters
      let currentFilters: Array<{type: string, value: string}> = [];
      let allAttempts: any[] = [];
      
      // Fetch attempts from database on page load
      async function fetchAttemptsFromDatabase() {
        try {
          const response = await fetch(`${backendBase}/api/attempts`, {
            credentials: 'include',
            headers: { 'Accept': 'application/json' }
          });
          
          if (!response.ok) {
            console.warn('Failed to fetch attempts from database:', response.status);
            // Hide loading, show empty state
            if (loadingSpinner) loadingSpinner.classList.add('hidden');
            if (emptyState) emptyState.classList.remove('hidden');
            return [];
          }
          
          const data = await response.json();
          return data.attempts || [];
        } catch (error) {
          console.error('Error fetching attempts:', error);
          // Hide loading, show empty state
          if (loadingSpinner) loadingSpinner.classList.add('hidden');
          if (emptyState) emptyState.classList.remove('hidden');
          return [];
        }
      }
      
      // Render attempts to the grid
      async function renderAttempts(attempts: any[]) {
        console.log(`renderAttempts called with ${attempts.length} attempts`);
        
        if (!grid) {
          console.error('Grid element not found!');
          return;
        }
        
        // Hide loading spinner
        if (loadingSpinner) loadingSpinner.classList.add('hidden');
        
        const filteredEmptyState = document.getElementById('filtered-empty-state');
        
        if (attempts.length === 0) {
          // Show appropriate empty state based on whether filters are active
          if (currentFilters.length > 0) {
            // Filters are active - show filtered empty state
            if (filteredEmptyState) filteredEmptyState.classList.remove('hidden');
            if (emptyState) emptyState.classList.add('hidden');
          } else {
            // No filters - show regular empty state
            if (emptyState) emptyState.classList.remove('hidden');
            if (filteredEmptyState) filteredEmptyState.classList.add('hidden');
          }
          if (attemptsContainer) attemptsContainer.classList.add('hidden');
          return;
        }
        
        // Show grid container, hide both empty states
        if (attemptsContainer) attemptsContainer.classList.remove('hidden');
        if (emptyState) emptyState.classList.add('hidden');
        if (filteredEmptyState) filteredEmptyState.classList.add('hidden');
        
        // Clear existing server-rendered attempts
        grid.innerHTML = '';
        
        console.log(`About to render ${attempts.length} cards to grid`);
        
        // Render each attempt
        attempts.forEach((attempt: any) => {
          const card = document.createElement('div');
          card.className = 'rounded-xl border border-gray-200 dark:border-slate-700 bg-white dark:bg-slate-800 p-4 shadow-sm flex flex-col gap-3 transition-all duration-200 hover:shadow-md hover:bg-gray-50 dark:hover:bg-slate-750 hover:border-gray-300 dark:hover:border-slate-600 cursor-pointer';
          
          // Format difficulty
          let diffChip = '';
          let diffText = '';
          if (attempt.difficulty) {
            const diff = attempt.difficulty.toLowerCase();
            if (diff === 'easy' || diff === '1') {
              diffChip = '<span class="inline-flex items-center px-2 py-1 rounded-md text-xs font-medium bg-green-100 text-green-700 dark:bg-green-900/40 dark:text-green-300" data-difficulty-chip>Easy</span>';
              diffText = 'Easy';
            } else if (diff === 'medium' || diff === '2') {
              diffChip = '<span class="inline-flex items-center px-2 py-1 rounded-md text-xs font-medium bg-orange-100 text-orange-700 dark:bg-orange-900/40 dark:text-orange-300" data-difficulty-chip>Medium</span>';
              diffText = 'Medium';
            } else if (diff === 'hard' || diff === '3') {
              diffChip = '<span class="inline-flex items-center px-2 py-1 rounded-md text-xs font-medium bg-red-100 text-red-700 dark:bg-red-900/40 dark:text-red-300" data-difficulty-chip>Hard</span>';
              diffText = 'Hard';
            } else {
              diffChip = '<span class="inline-flex items-center px-2 py-1 rounded-md text-xs font-medium bg-purple-100 text-purple-700 dark:bg-purple-900/40 dark:text-purple-300" data-difficulty-chip>Very Hard</span>';
              diffText = 'Very Hard';
            }
          }
          
          // Format topics
          const topics = attempt.related_topics || [];
          const topicChips = topics.map((topic: string) => {
            const label = topicLabels[topic] || topic.split(/[-_ ]+/).map(w => w ? w[0].toUpperCase() + w.slice(1) : '').join(' ');
            return `<span class="inline-flex items-center px-2 py-1 rounded-md text-xs font-medium bg-gray-100 dark:bg-slate-700 text-gray-700 dark:text-gray-300" data-topic="${topic}">${label}</span>`;
          }).join('');
          
          // Format display name
          let displayName = attempt.question_name || attempt.question_id;
          if (!attempt.question_name || !/^\d{4}/.test(attempt.question_name)) {
            const match = attempt.question_id.match(/^([a-z-]+)-0*(\d+)$/i);
            if (match) {
              const topicSlug = match[1];
              const questionNum = match[2];
              const topicLabel = topicLabels[topicSlug] || topicSlug.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
              displayName = `Custom ${topicLabel} ${questionNum}`;
            }
          }
          
          // Format time
          const timeTaken = attempt.time_taken_seconds;
          let timeChip = '';
          if (timeTaken != null && timeTaken > 0) {
            const minutes = Math.floor(timeTaken / 60);
            const seconds = timeTaken % 60;
            timeChip = `<span class="inline-flex items-center h-7 px-2 py-1 rounded-md bg-blue-100 dark:bg-blue-900 text-blue-700 dark:text-blue-300 text-xs font-medium" data-time-chip>${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}</span>`;
          }
          
          // Primary topic for link
          const primaryTopic = attempt.parent_topic || (topics.length > 0 ? topics[0] : attempt.question_id.split('-')[0]);
          const practiceHref = `/maths/practice/${primaryTopic}?q=${attempt.question_id}`;
          
          // Format timestamp
          const timestamp = attempt.completed_at || attempt.last_updated_at;
          const dateStr = timestamp ? new Date(timestamp).toLocaleString() : '';
          
          // Notes display
          const notesBlock = attempt.notes ? 
            `<div class="relative"><div class="notes-clamped text-sm text-gray-700 dark:text-gray-300" data-full="${(attempt.notes || '').replace(/"/g, '&quot;')}">${attempt.notes}</div><button class="expand-notes absolute bottom-0 right-0 inline-flex items-center justify-center w-6 h-6 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 bg-white dark:bg-slate-800 rounded transition" title="Expand notes"><svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 24 24" fill="currentColor"><circle cx="12" cy="12" r="2"/><circle cx="19" cy="12" r="2"/><circle cx="5" cy="12" r="2"/></svg></button></div>` : '';
          
          card.innerHTML = `
            <div class="flex items-start justify-between gap-4">
              <div class="flex-1">
                <div class="flex flex-wrap items-center gap-3">
                  <h2 class="m-0 font-semibold text-gray-900 dark:text-gray-100 text-lg leading-tight"><a href="${practiceHref}" class="focus:outline-none focus:ring-2 focus:ring-blue-500 rounded-sm">${displayName}</a></h2>
                  <div class="flex flex-wrap items-center gap-2 ml-1 pt-0.5">${diffChip}${topicChips}</div>
                </div>
                <p class="text-xs text-gray-500 dark:text-gray-400 mt-1">${dateStr}</p>
              </div>
              <div class="flex items-start gap-2">${timeChip}
                <button class="edit-notes inline-flex items-center justify-center h-7 w-7 rounded-md border border-transparent hover:border-blue-500 text-gray-500 hover:text-blue-600 dark:text-gray-400 dark:hover:text-blue-400" title="Edit notes" data-question-id="${attempt.question_id}">
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 3a2.83 2.83 0 0 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>
                </button>
              </div>
            </div>
            ${notesBlock}
          `;
          
          card.setAttribute('data-attempt', attempt.question_id);
          card.setAttribute('data-difficulty', diffText);
          card.setAttribute('data-time', timeTaken || '');
          card.setAttribute('data-question-name', attempt.question_name || '');
          card.setAttribute('data-question-type', attempt.question_type || '');
          card.setAttribute('data-paper', attempt.paper || '');
          
          grid.appendChild(card);
        });
        
        console.log(`Finished appending ${attempts.length} cards to grid`);
        console.log(`Cards now in grid: ${grid.querySelectorAll('[data-attempt]').length}`);
        
        // Recompute progress after rendering
        recomputeProgress();
        
        // Wait for DOM to be fully updated before counting pills
        await new Promise(resolve => requestAnimationFrame(resolve));
        
        // Verify cards are in DOM
        const testGrid = document.getElementById('attempt-grid');
        const testCards = testGrid?.querySelectorAll('[data-attempt]').length || 0;
        console.log(`Before pill updates: ${testCards} cards in DOM`);
        
        // Update all pill statistics after cards are rendered
        await updateDifficultyProportions();
        await updateYearStats();
        await updatePaperStats();
        await updateTopicStats();
        await updateTypeStats();
        
        // Apply overflow detection for notes
        setTimeout(() => applyOverflowDetection(), 50);
      }
      
      // Load attempts from database on page load
      fetchAttemptsFromDatabase().then(attempts => {
        allAttempts = attempts;
        renderAttempts(attempts);
      });
      
      // Filter attempts by criterion
      function applyFilter(type: string, value: string) {
        // Check if this filter already exists in the array
        const filterIndex = currentFilters.findIndex(f => f.type === type && f.value === value);
        
        if (filterIndex >= 0) {
          // Filter exists - remove it
          currentFilters.splice(filterIndex, 1);
        } else {
          // Filter doesn't exist - add it
          currentFilters.push({ type, value });
        }
        
        // Update pill states immediately before hiding content
        updatePillActiveStates();
        
        // Show loading indicator and hide attempts
        const attemptsContainer = document.getElementById('attempts-container');
        const loadingSpinner = document.getElementById('attempts-loading');
        if (attemptsContainer) attemptsContainer.classList.add('hidden');
        if (loadingSpinner) loadingSpinner.classList.remove('hidden');
        
        // Apply all filters cumulatively
        let filtered = allAttempts;
        
        for (const filter of currentFilters) {
          switch (filter.type) {
            case 'difficulty':
              filtered = filtered.filter(a => {
                const diff = String(a.difficulty || '').toLowerCase();
                return diff === filter.value.toLowerCase() || 
                       (filter.value === 'Easy' && diff === '1') ||
                       (filter.value === 'Medium' && diff === '2') ||
                       (filter.value === 'Hard' && diff === '3') ||
                       (filter.value === 'Very Hard' && diff === '4');
              });
              break;
            case 'year':
              filtered = filtered.filter(a => a.question_name && a.question_name.includes(filter.value));
              break;
            case 'paper':
              filtered = filtered.filter(a => a.paper === filter.value);
              break;
            case 'topic':
              filtered = filtered.filter(a => {
                if (Array.isArray(a.related_topics)) {
                  return a.related_topics.includes(filter.value);
                }
                return a.parent_topic === filter.value;
              });
              break;
            case 'type':
              filtered = filtered.filter(a => {
                if (filter.value === 'State') {
                  return a.question_type === 'state';
                } else {
                  return a.question_type === 'custom';
                }
              });
              break;
          }
        }
        
        setTimeout(() => {
          renderAttempts(filtered);
          // renderAttempts will handle showing/hiding attemptsContainer
        }, 200);
      }
      
      function updatePillActiveStates() {
        // First, remove all active classes from all pills
        document.querySelectorAll('[data-pill-type]').forEach(pill => {
          pill.classList.remove('pill-active');
          const pillType = pill.getAttribute('data-pill-type');
          if (pillType === 'difficulty') {
            pill.classList.remove('ring-2', 'ring-black', 'dark:ring-white');
          } else {
            pill.classList.remove('!bg-gray-200', 'dark:!bg-slate-600');
          }
        });
        
        // If no filters, we're done
        if (currentFilters.length === 0) return;
        
        // Find and mark all active pills
        document.querySelectorAll('[data-pill-type]').forEach(pill => {
          const pillType = pill.getAttribute('data-pill-type');
          const pillValue = pill.getAttribute('data-pill-value');
          
          // Check if this pill matches any filter in the array
          const isActive = currentFilters.some(f => f.type === pillType && f.value === pillValue);
          
          if (isActive) {
            pill.classList.add('pill-active');
            if (pillType === 'difficulty') {
              // Add black outline for difficulty pills
              pill.classList.add('ring-2', 'ring-black', 'dark:ring-white');
            } else {
              // Add darker background for regular pills (lighter than before)
              pill.classList.add('!bg-gray-200', 'dark:!bg-slate-600');
            }
          }
        });
      }
      
      function loadLocalAttempts(){
        try {
          const raw = localStorage.getItem('questionAttempts');
          if(!raw) return [];
          return JSON.parse(raw);
        } catch { return []; }
      }
      
      let statsData: { total?: number; topics?: Record<string, number> } = {};
      if (progressStatsEl) {
        try { statsData = JSON.parse(progressStatsEl.getAttribute('data-stats') || '{}'); } catch { /* ignore parse */ }
      }

      function recomputeProgress(){
        if(!('total' in statsData)) return;
        const cards = Array.from(grid?.querySelectorAll('[data-attempt]') || []);
        const unique = new Map<string, Element>();
        cards.forEach(c => { const id = c.getAttribute('data-attempt'); if(id) unique.set(id,c); });
        let total = 0; let completed = 0;
        
        // Use current filters if set
        if (currentFilters.length === 0) {
          total = (statsData.total ?? 0) as number;
          completed = unique.size;
        } else {
          // Check if any filter is a topic filter
          const topicFilter = currentFilters.find(f => f.type === 'topic');
          if (topicFilter) {
            total = statsData.topics && statsData.topics[topicFilter.value] ? statsData.topics[topicFilter.value] : 0;
          } else {
            total = (statsData.total ?? 0) as number;
          }
          
          // Count completed attempts that match all filters
          unique.forEach(card => {
            let matchesAll = true;
            
            for (const filter of currentFilters) {
              let matches = false;
              
              if (filter.type === 'topic') {
                const topics = Array.from(card.querySelectorAll('[data-topic]')).map(e=>e.getAttribute('data-topic')).filter((v): v is string => !!v);
                matches = topics.includes(filter.value);
                if (!matches && topics.length === 0) {
                  const id = card.getAttribute('data-attempt') || '';
                  if (id.split('-')[0] === filter.value) matches = true;
                }
              } else if (filter.type === 'difficulty') {
                const diffChip = card.querySelector('[data-difficulty-chip]');
                const diffText = diffChip?.textContent?.trim();
                matches = diffText === filter.value;
              }
              // Add other filter types as needed
              
              if (!matches) {
                matchesAll = false;
                break;
              }
            }
            
            if (matchesAll) completed++;
          });
        }
        
        // Update inline progress circle in attempts container
        const miniProgressBarInline = document.getElementById('mini-progress-bar-inline');
        if (miniProgressBarInline) {
          const radius = 20;
          const circumference = 2 * Math.PI * radius;
          const progress = total ? Math.min(1, completed / total) : 0;
          const offset = circumference * (1 - progress);
          (miniProgressBarInline as HTMLElement).style.strokeDashoffset = String(offset);
        }
        
        // Update inline completed count in attempts container
        const completedCountInline = document.getElementById('completed-count-inline');
        if (completedCountInline) {
          completedCountInline.textContent = String(completed);
        }
        
        // Update difficulty stats
        const easyCountEl = document.getElementById('easy-count');
        const mediumCountEl = document.getElementById('medium-count');
        const hardCountEl = document.getElementById('hard-count');
        const veryHardCountEl = document.getElementById('very-hard-count');
        
        if (easyCountEl || mediumCountEl || hardCountEl || veryHardCountEl) {
          let easyCount = 0, mediumCount = 0, hardCount = 0, veryHardCount = 0;
          
          if (currentFilters.length === 0) {
            // Count all attempts
            unique.forEach(card => {
              const diffChip = card.querySelector('[data-difficulty-chip]');
              if (diffChip) {
                const diffText = diffChip.textContent?.trim();
                if (diffText === 'Easy') easyCount++;
                else if (diffText === 'Medium') mediumCount++;
                else if (diffText === 'Hard') hardCount++;
                else if (diffText === 'Very Hard') veryHardCount++;
              }
            });
          } else {
            // Count only attempts that match all active filters
            unique.forEach(card => {
              let matchesAll = true;
              
              for (const filter of currentFilters) {
                let matches = false;
                
                if (filter.type === 'topic') {
                  const topics = Array.from(card.querySelectorAll('[data-topic]')).map(e=>e.getAttribute('data-topic')).filter((v): v is string => !!v);
                  matches = topics.includes(filter.value);
                  if (!matches && topics.length === 0) {
                    const id = card.getAttribute('data-attempt') || '';
                    if (id.split('-')[0] === filter.value) matches = true;
                  }
                } else if (filter.type === 'difficulty') {
                  const diffChip = card.querySelector('[data-difficulty-chip]');
                  const diffText = diffChip?.textContent?.trim();
                  matches = diffText === filter.value;
                }
                // Add other filter types as needed
                
                if (!matches) {
                  matchesAll = false;
                  break;
                }
              }
              
              if (matchesAll) {
                const diffChip = card.querySelector('[data-difficulty-chip]');
                if (diffChip) {
                  const diffText = diffChip.textContent?.trim();
                  if (diffText === 'Easy') easyCount++;
                  else if (diffText === 'Medium') mediumCount++;
                  else if (diffText === 'Hard') hardCount++;
                  else if (diffText === 'Very Hard') veryHardCount++;
                }
              }
            });
          }
          
          // Animate count updates
          const animateCount = (el: HTMLElement, newValue: number) => {
            const currentValue = parseInt(el.textContent || '0');
            if (currentValue !== newValue) {
              el.style.transition = 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
              el.style.transform = 'scale(1.2)';
              el.style.opacity = '0.5';
              
              setTimeout(() => {
                el.textContent = String(newValue);
                el.style.transform = 'scale(1)';
                el.style.opacity = '1';
              }, 150);
            }
          };
          
          if (easyCountEl) animateCount(easyCountEl as HTMLElement, easyCount);
          if (mediumCountEl) animateCount(mediumCountEl as HTMLElement, mediumCount);
          if (hardCountEl) animateCount(hardCountEl as HTMLElement, hardCount);
          if (veryHardCountEl) animateCount(veryHardCountEl as HTMLElement, veryHardCount);
        }
      }

      if (grid && grid.children.length === 0) {
        const local = loadLocalAttempts();
        if (local.length) {
          // Hide empty state and inject local attempts
          if (emptyState) emptyState.classList.add('hidden');
          // Sort local newest first
          local.sort((a,b) => {
            const ta = a.timestamp ? new Date(a.timestamp).getTime() : 0;
            const tb = b.timestamp ? new Date(b.timestamp).getTime() : 0;
            return tb - ta;
          });
          local.forEach(a => {
            const card = document.createElement('div');
            card.className = 'rounded-xl border border-gray-200 dark:border-slate-700 bg-white dark:bg-slate-800 p-4 shadow-sm flex flex-col gap-3';
            
            // Only show time if it's greater than 0
            const time = (a.timeTaken != null && a.timeTaken > 0) ? `<span class="inline-flex items-center h-7 px-2 py-1 rounded-md bg-blue-100 dark:bg-blue-900 text-blue-700 dark:text-blue-300 text-xs font-medium" data-time-chip>${String(Math.floor(a.timeTaken/60)).padStart(2,'0')}:${String(a.timeTaken%60).padStart(2,'0')}</span>` : '';
            
            const topic = a.topic || (a.questionId ? a.questionId.split('-')[0] : null);
            const diff = a.difficulty;
            let diffChip = '';
            if (diff !== undefined && diff !== null && diff !== '') {
              const label = String(diff);
              const num = parseInt(label,10);
              let cls=''; let norm='';
              if(!isNaN(num)) {
                if (num <=1) { cls='bg-green-100 text-green-700 dark:bg-green-900/40 dark:text-green-300'; norm='Easy'; }
                else if (num===2) { cls='bg-orange-100 text-orange-700 dark:bg-orange-900/40 dark:text-orange-300'; norm='Medium'; }
                else { cls='bg-red-100 text-red-700 dark:bg-red-900/40 dark:text-red-300'; norm='Hard'; }
              } else {
                const lower=label.toLowerCase();
                if(/(easy|low)/.test(lower)) { cls='bg-green-100 text-green-700 dark:bg-green-900/40 dark:text-green-300'; norm='Easy'; }
                else if(/(med|medium|moderate)/.test(lower)) { cls='bg-orange-100 text-orange-700 dark:bg-orange-900/40 dark:text-orange-300'; norm='Medium'; }
                else { cls='bg-red-100 text-red-700 dark:bg-red-900/40 dark:text-red-300'; norm='Hard'; }
              }
              diffChip = `<span class="inline-flex items-center px-2 py-1 rounded-md text-xs font-medium ${cls}" data-difficulty-chip>${norm || label}</span>`;
            }
            const displayTopic = topic ? (topicLabels[topic] || topic.split(/[-_ ]+/).map(w=>w? w[0].toUpperCase()+w.slice(1):'').join(' ')) : '';
            const localTopicChip = topic ? `<span class="inline-flex items-center px-2 py-1 rounded-md text-xs font-medium bg-gray-100 dark:bg-slate-700 text-gray-700 dark:text-gray-300" data-topic="${topic}" title="${topic}">${displayTopic}</span>` : '';
            const notesBlock = a.notes ? `<div class="relative"><div class="notes-clamped text-sm text-gray-700 dark:text-gray-300" data-full="${(a.notes||'').replace(/"/g,'&quot;')}">${a.notes}</div><button class="expand-notes text-xs mt-1 text-blue-600 dark:text-blue-400 hover:underline">Expand</button></div>` : '';
            
            // Format display name for custom questions
            let displayName = a.questionName || a.questionId;
            if (!a.questionName || !/^\d{4}/.test(a.questionName)) {
              // Format: alg-0007 -> Custom Algebra 7
              const match = a.questionId.match(/^([a-z-]+)-0*(\d+)$/i);
              if (match) {
                const topicSlug = match[1];
                const questionNum = match[2];
                const topicLabel = topicLabels[topicSlug] || topicSlug.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
                displayName = `Custom ${topicLabel} ${questionNum}`;
              }
            }
            
            card.innerHTML = `
              <div class="flex items-start justify-between gap-4">
                <div class="flex-1">
                  <div class="flex flex-wrap items-center gap-3">
                    ${(() => {
                      const primaryTopic = (topic || (a.questionId ? a.questionId.split('-')[0] : 'unknown'));
                      const practiceHref = `/maths/practice/${primaryTopic}?q=${a.questionId}`;
                      return `<h2 class="m-0 font-semibold text-gray-900 dark:text-gray-100 text-lg leading-tight"><a href="${practiceHref}" class="focus:outline-none focus:ring-2 focus:ring-blue-500 rounded-sm">${displayName}</a></h2>`;
                    })()}
                    <div class="flex flex-wrap items-center gap-2 ml-1 pt-0.5">${diffChip}${localTopicChip}</div>
                  </div>
                  <p class="text-xs text-gray-500 dark:text-gray-400 mt-1">${a.timestamp ? new Date(a.timestamp).toLocaleString() : ''}</p>
                </div>
                <div class="flex items-start gap-2">${time}
                  <button class="edit-notes inline-flex items-center justify-center h-7 w-7 rounded-md border border-transparent hover:border-blue-500 text-gray-500 hover:text-blue-600 dark:text-gray-400 dark:hover:text-blue-400" title="Edit notes" data-question-id="${a.questionId}">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 3a2.83 2.83 0 0 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>
                  </button>
                </div>
              </div>
              ${notesBlock}
            `;
            card.setAttribute('data-attempt', a.questionId);
            card.setAttribute('data-question-name', a.questionName || '');
            grid.appendChild(card);
          });
          recomputeProgress();
        }
      }

      // Modal state
      let editingAttemptId: string | null = null;
      const editModal = document.getElementById('edit-notes-modal');
      const editNotesTextarea = document.getElementById('edit-attempt-notes') as HTMLTextAreaElement | null;
      const editQuestionTitleEl = document.getElementById('edit-modal-question-title');
      const editTimeTakenEl = document.getElementById('edit-modal-time-taken');
      const cancelEditBtn = document.getElementById('cancel-edit-notes');
      const confirmEditBtn = document.getElementById('confirm-edit-notes');

      function openEditModal(qid: string, currentNotes: string, questionTitle: string, timeSeconds: number | null){
        editingAttemptId = qid;
        if (editNotesTextarea) editNotesTextarea.value = currentNotes;
        if (editQuestionTitleEl) editQuestionTitleEl.textContent = questionTitle || qid;
        if (editTimeTakenEl) {
          if (timeSeconds != null) {
            const m = Math.floor(timeSeconds/60).toString().padStart(2,'0');
            const s = (timeSeconds%60).toString().padStart(2,'0');
            editTimeTakenEl.textContent = `${m}:${s}`;
          } else {
            editTimeTakenEl.textContent = '--:--';
          }
        }
        if (editModal) {
          editModal.classList.remove('hidden');
          document.body.style.overflow='hidden';
          setTimeout(()=>{ editNotesTextarea?.focus({preventScroll:true}); }, 50);
        }
      }

      function closeEditModal(){
        if (editModal) editModal.classList.add('hidden');
        document.body.style.overflow='';
        editingAttemptId = null;
      }

      cancelEditBtn?.addEventListener('click', ()=> closeEditModal());
      cancelEditBtn?.addEventListener('keydown', e=>{ if(e.key==='Escape') closeEditModal(); });
      document.addEventListener('keydown', e=>{ if(e.key==='Escape' && !editModal?.classList.contains('hidden')) closeEditModal(); });
      confirmEditBtn?.addEventListener('click', async ()=>{
        if(!editingAttemptId) return;
        const newNotes = editNotesTextarea ? editNotesTextarea.value : '';
        // Update card UI
        const card = grid?.querySelector(`[data-attempt="${editingAttemptId}"]`);
        if (card) {
          let notesEl = card.querySelector('.notes-clamped') as HTMLElement | null;
          if (newNotes.trim() === '') {
            if (notesEl) { const wrapper = notesEl.parentElement; if (wrapper) wrapper.remove(); }
          } else {
            if (!notesEl) {
              const block = document.createElement('div');
              block.className = 'relative';
              block.innerHTML = `<div class="notes-clamped text-sm text-gray-700 dark:text-gray-300" data-full="${newNotes.replace(/"/g,'&quot;')}">${newNotes}</div><button class="expand-notes absolute bottom-0 right-0 inline-flex items-center justify-center w-6 h-6 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 bg-white dark:bg-slate-800 rounded transition" title="Expand notes"><svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 24 24" fill="currentColor"><circle cx="12" cy="12" r="2"/><circle cx="19" cy="12" r="2"/><circle cx="5" cy="12" r="2"/></svg></button>`;
              card.appendChild(block);
              notesEl = block.querySelector('.notes-clamped') as HTMLElement | null;
              setTimeout(() => applyOverflowDetection(), 50);
            } else {
              notesEl.textContent = newNotes;
              notesEl.setAttribute('data-full', newNotes);
              setTimeout(() => applyOverflowDetection(), 50);
            }
          }
        }
        // Save to database
        if (backendBase) {
          try { 
            const response = await fetch(`${backendBase}/api/attempts/${editingAttemptId}/notes`, { 
              method: 'PATCH', 
              headers: {'Content-Type': 'application/json'}, 
              credentials: 'include', 
              body: JSON.stringify({ notes: newNotes || null }) 
            });
            if (response.ok) {
              console.log('Notes updated in database');
            } else {
              console.warn('Failed to update notes in database:', response.status);
            }
          } catch (error) { 
            console.error('Error updating notes:', error);
          }
        }
        // Also update localStorage as backup
        try { const local = loadLocalAttempts(); const found = local.find(a=>a.questionId===editingAttemptId); if(found){ found.notes = newNotes; localStorage.setItem('questionAttempts', JSON.stringify(local)); } } catch { /* ignore */ }
        closeEditModal();
        setTimeout(applyOverflowDetection, 30);
      });

      document.addEventListener('click', async function(e){
        const target = e.target as Element | null;
        if(!target) return;

        // Make entire card clickable
        const card = target.closest('[data-attempt]');
        if (card && !target.closest('.edit-notes') && !target.closest('.expand-notes') && !target.closest('a')) {
          const titleLink = card.querySelector('h2 a') as HTMLAnchorElement | null;
          if (titleLink && titleLink.href) {
            window.location.href = titleLink.href;
            return;
          }
        }

        // Difficulty pill click
        const difficultyPill = target.closest('[data-pill-type="difficulty"]');
        if (difficultyPill) {
          const value = difficultyPill.getAttribute('data-pill-value');
          if (value) {
            applyFilter('difficulty', value);
            return;
          }
        }

        // Expand / Collapse notes
        const expandBtn = target.closest('.expand-notes');
        if (expandBtn) {
          const wrapper = (expandBtn as HTMLElement).previousElementSibling;
          if(wrapper instanceof HTMLElement) {
            if(wrapper.classList.contains('expanded')) {
              wrapper.classList.remove('expanded');
              (expandBtn as HTMLElement).style.display = '';
            } else {
              wrapper.classList.add('expanded');
              (expandBtn as HTMLElement).style.display = 'none';
            }
          }
          return;
        }

        // Edit notes button
        const editBtn = target.closest('.edit-notes');
        if (editBtn) {
          e.stopPropagation(); // Prevent card click
          const qid = (editBtn as HTMLElement).getAttribute('data-question-id');
          if(!qid) return;
          const card = (editBtn as HTMLElement).closest('[data-attempt]');
          if(!card) return;
          const notesEl = card.querySelector('.notes-clamped') as HTMLElement | null;
          const current = notesEl ? (notesEl.getAttribute('data-full') || notesEl.textContent || '') : '';
          const titleAnchor = card.querySelector('h2 a');
          const questionTitle = titleAnchor ? (titleAnchor.textContent || qid) : qid;
          const timeAttr = card.getAttribute('data-time');
          const timeSeconds = timeAttr ? parseInt(timeAttr,10) : null;
          openEditModal(qid, current, questionTitle, timeSeconds);
        }
      });

      // Overflow detection for notes: remove expand button if not needed
      function applyOverflowDetection(){
        document.querySelectorAll('.notes-clamped').forEach(el => {
          if(!(el instanceof HTMLElement)) return;
          const btn = el.parentElement?.querySelector('.expand-notes');
            if (!btn) return;
          if (el.scrollHeight <= el.clientHeight + 2) {
            btn.remove();
          }
        });
      }
      applyOverflowDetection();
      // Re-run after a tick for dynamically injected content
      setTimeout(applyOverflowDetection, 50);

      // Listen for storage changes (another tab saving attempts)
      window.addEventListener('storage', ev => {
        if (ev.key === 'questionAttempts') {
          // naive refresh strategy: if grid is empty, repopulate; else only recompute progress
          recomputeProgress();
        }
      });
      recomputeProgress();
      
      // ============ Filter Dropdown and Sort Functionality ============
      const filterToggleBtn = document.getElementById('filter-toggle-btn');
      const filterDropdown = document.getElementById('filter-dropdown');
      const filterLabel = document.getElementById('filter-label');
      const progressStatsContainer = progressStatsEl?.closest('.bg-white\\/70');
      let currentSort = 'recent'; // Track current sort order
      
      if (filterToggleBtn && filterDropdown) {
        // Toggle dropdown
        filterToggleBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          filterDropdown.classList.toggle('hidden');
        });
        
        // Close dropdown when clicking outside
        document.addEventListener('click', (e) => {
          if (!filterToggleBtn.contains(e.target as Node) && !filterDropdown.contains(e.target as Node)) {
            filterDropdown.classList.add('hidden');
          }
        });
        
        // Handle sort options
        document.querySelectorAll('.sort-option').forEach(option => {
          option.addEventListener('click', () => {
            const sortType = option.getAttribute('data-sort');
            
            // Update checkmarks
            document.querySelectorAll('.sort-option svg').forEach(svg => svg.classList.add('hidden'));
            const checkmark = option.querySelector('svg');
            if (checkmark) checkmark.classList.remove('hidden');
            
            // Sort attempts
            if (sortType) {
              currentSort = sortType;
              if (filterLabel) {
                filterLabel.textContent = sortType === 'recent' ? 'Most Recent' : 'Least Recent';
              }
              
              // Sort allAttempts array
              allAttempts.sort((a, b) => {
                const dateA = new Date(a.completed_at || a.last_updated_at || 0).getTime();
                const dateB = new Date(b.completed_at || b.last_updated_at || 0).getTime();
                return sortType === 'recent' ? dateB - dateA : dateA - dateB;
              });
              
              // Re-render with current filters
              if (currentFilters.length > 0) {
                // Re-apply all filters
                let filtered = allAttempts;
                for (const filter of currentFilters) {
                  switch (filter.type) {
                    case 'difficulty':
                      filtered = filtered.filter(a => {
                        const diff = String(a.difficulty || '').toLowerCase();
                        return diff === filter.value.toLowerCase() || 
                               (filter.value === 'Easy' && diff === '1') ||
                               (filter.value === 'Medium' && diff === '2') ||
                               (filter.value === 'Hard' && diff === '3') ||
                               (filter.value === 'Very Hard' && diff === '4');
                      });
                      break;
                    case 'year':
                      filtered = filtered.filter(a => a.question_name && a.question_name.includes(filter.value));
                      break;
                    case 'paper':
                      filtered = filtered.filter(a => a.paper === filter.value);
                      break;
                    case 'topic':
                      filtered = filtered.filter(a => {
                        if (Array.isArray(a.related_topics)) {
                          return a.related_topics.includes(filter.value);
                        }
                        return a.parent_topic === filter.value;
                      });
                      break;
                    case 'type':
                      filtered = filtered.filter(a => {
                        if (filter.value === 'State') {
                          return a.question_type === 'state';
                        } else {
                          return a.question_type === 'custom';
                        }
                      });
                      break;
                  }
                }
                renderAttempts(filtered);
              } else {
                renderAttempts(allAttempts);
              }
            }
            
            filterDropdown.classList.add('hidden');
          });
        });
      }
      
      // ============ Clear Filters Button ============
      const clearFiltersBtn = document.getElementById('clear-filters-btn');
      if (clearFiltersBtn) {
        clearFiltersBtn.addEventListener('click', () => {
          currentFilters = [];
          renderAttempts(allAttempts);
          updatePillActiveStates();
        });
      }

      // ============ Year Stats Management ============
      let currentYearScrollOffset = 0;

      // Update difficulty proportions
      async function updateDifficultyProportions() {
        const diffMap = {
          'easy': 'Easy',
          'medium': 'Medium',
          'hard': 'Hard',
          'very-hard': 'Very Hard'
        };
        
        // Fetch all questions to get totals
        const response = await fetch(`${backendBase}/api/questions/all`, { credentials: 'include' });
        const allQuestions = await response.json();
        
        // Count totals by difficulty
        const totals: Record<string, number> = { Easy: 0, Medium: 0, Hard: 0, 'Very Hard': 0 };
        allQuestions.forEach((q: any) => {
          const diff = q.difficulty;
          if (diff !== undefined && diff !== null) {
            const num = parseInt(String(diff), 10);
            let diffText = '';
            if (!isNaN(num)) {
              if (num <= 1) diffText = 'Easy';
              else if (num === 2) diffText = 'Medium';
              else if (num === 3) diffText = 'Hard';
              else diffText = 'Very Hard';
            } else {
              const lower = String(diff).toLowerCase();
              if (/(^|\b)(easy|low)(\b|$)/.test(lower)) diffText = 'Easy';
              else if (/(^|\b)(med|medium|moderate)(\b|$)/.test(lower)) diffText = 'Medium';
              else if (/(^|\b)(very.?hard|extremely.?hard|veryhard)(\b|$)/.test(lower)) diffText = 'Very Hard';
              else if (/(^|\b)(hard|difficult)(\b|$)/.test(lower)) diffText = 'Hard';
            }
            if (diffText && totals[diffText] !== undefined) {
              totals[diffText]++;
            }
          }
        });
        
        Object.entries(diffMap).forEach(([id, diffText]) => {
          const proportionEl = document.getElementById(`${id}-proportion`);
          
          if (proportionEl) {
            // Count completed from user's database attempts (rendered in grid)
            const cards = Array.from(grid?.querySelectorAll('[data-attempt]') || []);
            const unique = new Map<string, Element>();
            cards.forEach(c => { const id = c.getAttribute('data-attempt'); if(id) unique.set(id,c); });
            
            let completed = 0;
            
            unique.forEach(card => {
              const diffChip = card.querySelector('[data-difficulty-chip]');
              if (diffChip && diffChip.textContent?.trim() === diffText) {
                completed++;
              }
            });
            
            const total = totals[diffText] || 0;
            
            if (total > 0) {
              proportionEl.textContent = `(${completed}/${total})`;
            } else {
              proportionEl.textContent = '';
            }
          }
        });
      }

      // Update year pills
      async function updateYearStats() {
        // Fetch all questions to get all years and totals
        const response = await fetch(`${backendBase}/api/questions/all`, { credentials: 'include' });
        const allQuestions = await response.json();
        
        // Extract all years from all questions
        const extractYear = (name: string | null | undefined): string | null => {
          if (!name) return null;
          const match = name.match(/^(\d{4}(?:\s+(?:Deferred|Sample|Preview|[A-Z][a-z]+))?)/);
          return match ? match[1] : null;
        };
        
        const yearTotals: Record<string, number> = {};
        allQuestions.forEach((q: any) => {
          const year = extractYear(q.name);
          if (year) {
            yearTotals[year] = (yearTotals[year] || 0) + 1;
          }
        });
        
        // Get user's completed attempts by year from database-rendered grid
        const cards = Array.from(grid?.querySelectorAll('[data-attempt]') || []);
        const unique = new Map<string, Element>();
        cards.forEach(c => { const id = c.getAttribute('data-attempt'); if(id) unique.set(id,c); });
        
        const yearCompleted: Record<string, number> = {};
        
        unique.forEach(card => {
          const titleEl = card.querySelector('h2 a');
          if (titleEl) {
            const name = titleEl.textContent;
            const year = extractYear(name);
            if (year) {
              yearCompleted[year] = (yearCompleted[year] || 0) + 1;
            }
          }
        });
        
        // Get all years and sort (newest first)
        const years = Object.keys(yearTotals).sort().reverse();
        
        // Render year pills
        const container = document.getElementById('year-pills-container');
        if (!container) return;
        
        container.innerHTML = '';
        
        years.forEach(year => {
          const completed = yearCompleted[year] || 0;
          const total = yearTotals[year] || 0;
          
          // Replace "Project" with "Project Maths" in year display
          const displayYear = year.replace(/\bProject\b/i, 'Project Maths');
          
          const pill = document.createElement('div');
          pill.className = 'flex-shrink-0 flex items-center gap-1.5 px-2 py-1 rounded-full bg-gray-100 text-gray-700 dark:bg-slate-700 dark:text-gray-300 transition-all duration-300 cursor-pointer hover:bg-gray-200 dark:hover:bg-slate-600';
          pill.setAttribute('data-pill-type', 'year');
          pill.setAttribute('data-pill-value', year);
          pill.innerHTML = `
            <span class="text-xs font-medium">${displayYear}</span>
            <span class="text-xs opacity-70">(${completed}/${total})</span>
          `;
          pill.addEventListener('click', () => applyFilter('year', year));
          container.appendChild(pill);
        });
        
        // Update navigation button states
        updateYearScrollButtons();
      }

      // Year navigation handlers
      function updateYearScrollButtons() {
        const container = document.getElementById('year-pills-container');
        const leftBtn = document.getElementById('year-scroll-left');
        const rightBtn = document.getElementById('year-scroll-right');
        
        if (!container || !leftBtn || !rightBtn) return;
        
        const parentWidth = container.parentElement?.clientWidth || 0;
        const maxScroll = Math.max(0, container.scrollWidth - parentWidth);
        const currentTransform = container.style.transform;
        const currentOffset = currentTransform ? 
          parseInt(currentTransform.match(/-?\d+/)?.[0] || '0') : 0;
        
        // Disable left button if at start
        if (currentOffset >= 0) {
          leftBtn.setAttribute('disabled', 'true');
        } else {
          leftBtn.removeAttribute('disabled');
        }
        
        // Disable right button if at end
        if (Math.abs(currentOffset) >= maxScroll) {
          rightBtn.setAttribute('disabled', 'true');
        } else {
          rightBtn.removeAttribute('disabled');
        }
      }

      function scrollYears(direction: 'left' | 'right') {
        const container = document.getElementById('year-pills-container');
        if (!container || !container.parentElement) return;
        
        const parentWidth = container.parentElement.clientWidth;
        const pills = Array.from(container.children) as HTMLElement[];
        
        if (pills.length === 0) return;
        
        const currentTransform = container.style.transform;
        const currentOffset = currentTransform ? 
          parseInt(currentTransform.match(/-?\d+/)?.[0] || '0') : 0;
        
        let newOffset = currentOffset;
        
        if (direction === 'left') {
          // Scroll left - show the previous pill (one that's currently hidden on the left)
          // Find the first pill that's currently cut off or hidden on the left
          for (let i = pills.length - 1; i >= 0; i--) {
            const pillLeft = pills[i].offsetLeft + currentOffset;
            const pillRight = pillLeft + pills[i].offsetWidth;
            
            // If this pill's right edge is just before or at the container start (hidden/cut off on left)
            if (pillRight <= 0 || pillLeft < 0) {
              // Scroll to show this pill fully
              newOffset = -pills[i].offsetLeft;
              break;
            }
          }
          
          // If no hidden pill found (we're at the start), stay at 0
          if (newOffset === currentOffset) {
            newOffset = 0;
          }
        } else {
          // Scroll right - hide the leftmost visible pill and show the next one on the right
          // Find the first pill that's currently fully or partially visible
          let firstVisibleIndex = -1;
          for (let i = 0; i < pills.length; i++) {
            const pillLeft = pills[i].offsetLeft + currentOffset;
            const pillRight = pillLeft + pills[i].offsetWidth;
            
            // This pill is at least partially visible
            if (pillRight > 0 && pillLeft < parentWidth) {
              firstVisibleIndex = i;
              break;
            }
          }
          
          // Scroll to hide this pill and show the next one
          if (firstVisibleIndex >= 0 && firstVisibleIndex < pills.length - 1) {
            const nextPillIndex = firstVisibleIndex + 1;
            newOffset = -pills[nextPillIndex].offsetLeft;
          }
        }
        
        const maxScroll = Math.max(0, container.scrollWidth - parentWidth);
        currentYearScrollOffset = Math.max(-maxScroll, Math.min(0, newOffset));
        
        container.style.transform = `translateX(${currentYearScrollOffset}px)`;
        updateYearScrollButtons();
      }

      // Setup navigation buttons for years
      const yearScrollLeft = document.getElementById('year-scroll-left');
      const yearScrollRight = document.getElementById('year-scroll-right');
      
      if (yearScrollLeft) {
        yearScrollLeft.addEventListener('click', () => scrollYears('left'));
      }
      
      if (yearScrollRight) {
        yearScrollRight.addEventListener('click', () => scrollYears('right'));
      }

      // Paper pills (Paper 1, Paper 2) - no scrolling needed
      async function updatePaperStats() {
        const container = document.getElementById('paper-pills-container');
        if (!container) return;

        container.innerHTML = '';
        const papers = [
          { label: 'Paper 1', pattern: 'P1' },
          { label: 'Paper 2', pattern: 'P2' }
        ];

        // Fetch all questions to get totals
        const response = await fetch(`${backendBase}/api/questions/all`, { credentials: 'include' });
        const allQuestions = await response.json();

        for (const paper of papers) {
          // Count completed from user's database attempts in grid
          const grid = document.getElementById('attempt-grid');
          const cards = Array.from(grid?.querySelectorAll('[data-attempt]') || []);
          const unique = new Map<string, Element>();
          cards.forEach(c => { const id = c.getAttribute('data-attempt'); if(id) unique.set(id,c); });

          console.log(`Paper "${paper.label}": Found ${cards.length} cards, ${unique.size} unique`);

          let completed = 0;

          unique.forEach(card => {
            // Use data-paper attribute from database
            const paperAttr = card.getAttribute('data-paper');
            console.log(`Checking card for paper "${paper.pattern}": data-paper="${paperAttr}"`);
            if (paperAttr === paper.pattern) {
              completed++;
            }
          });

          console.log(`Paper "${paper.label}": completed=${completed}`);

          // Count total from all questions
          const total = allQuestions.filter((q: any) => {
            return q.name && q.name.includes(paper.pattern);
          }).length;

          const pill = document.createElement('div');
          pill.className = 'flex-shrink-0 flex items-center gap-1.5 px-2 py-1 rounded-full bg-gray-100 text-gray-700 dark:bg-slate-700 dark:text-gray-300 cursor-pointer hover:bg-gray-200 dark:hover:bg-slate-600';
          pill.setAttribute('data-pill-type', 'paper');
          pill.setAttribute('data-pill-value', paper.pattern);
          pill.innerHTML = `
            <span class="text-xs font-medium">${paper.label}</span>
            <span class="text-xs opacity-70">(${completed}/${total})</span>
          `;
          pill.addEventListener('click', () => applyFilter('paper', paper.pattern));
          container.appendChild(pill);
        }
      }

      // Topic pills
      let currentTopicScrollOffset = 0;

      async function updateTopicStats() {
        const container = document.getElementById('topic-pills-container');
        if (!container) return;

        container.innerHTML = '';
        const topics = [
          'algebra',
          'complex-numbers',
          'differentiation',
          'financial-mathematics',
          'geometry',
          'induction',
          'integration',
          'probability',
          'sequences-and-series',
          'statistics',
          'the-circle',
          'the-line',
          'trigonometry'
        ];

        const topicLabels: Record<string, string> = {
          'algebra': 'Algebra',
          'complex-numbers': 'Complex Numbers',
          'differentiation': 'Differentiation',
          'financial-mathematics': 'Financial Mathematics',
          'geometry': 'Geometry',
          'induction': 'Induction',
          'integration': 'Integration',
          'probability': 'Probability',
          'sequences-and-series': 'Sequences and Series',
          'statistics': 'Statistics',
          'the-circle': 'The Circle',
          'the-line': 'The Line',
          'trigonometry': 'Trigonometry'
        };

        // Fetch all questions to get totals
        const response = await fetch(`${backendBase}/api/questions/all`, { credentials: 'include' });
        const allQuestions = await response.json();

        for (const topic of topics) {
          // Count completed from user's database attempts in grid
          const grid = document.getElementById('attempt-grid');
          const cards = Array.from(grid?.querySelectorAll('[data-attempt]') || []);
          const unique = new Map<string, Element>();
          cards.forEach(c => { const id = c.getAttribute('data-attempt'); if(id) unique.set(id,c); });

          let completed = 0;
          unique.forEach(card => {
            const topics = Array.from(card.querySelectorAll('[data-topic]')).map(e=>e.getAttribute('data-topic')).filter((v): v is string => !!v);
            let match = topics.includes(topic);
            if (!match && topics.length === 0) {
              const id = card.getAttribute('data-attempt') || '';
              if (id.split('-')[0] === topic) match = true;
            }
            if (match) completed++;
          });

          // Count total from all questions
          let total = 0;
          allQuestions.forEach((q: any) => {
            if (Array.isArray(q.topic)) {
              const occurrences = q.topic.filter((t: string) => t === topic).length;
              total += occurrences;
            } else if (q.topic === topic) {
              total += 1;
            } else if (!q.topic && q.name?.startsWith(topic)) {
              total += 1;
            }
          });

          const pill = document.createElement('div');
          pill.className = 'flex-shrink-0 flex items-center gap-1.5 px-2 py-1 rounded-full bg-gray-100 text-gray-700 dark:bg-slate-700 dark:text-gray-300 cursor-pointer hover:bg-gray-200 dark:hover:bg-slate-600';
          pill.setAttribute('data-pill-type', 'topic');
          pill.setAttribute('data-pill-value', topic);
          pill.innerHTML = `
            <span class="text-xs font-medium">${topicLabels[topic] || topic}</span>
            <span class="text-xs opacity-70">(${completed}/${total})</span>
          `;
          pill.addEventListener('click', () => applyFilter('topic', topic));
          container.appendChild(pill);
        }

        updateTopicScrollButtons();
      }

      function updateTopicScrollButtons() {
        const container = document.getElementById('topic-pills-container');
        const leftBtn = document.getElementById('topic-scroll-left');
        const rightBtn = document.getElementById('topic-scroll-right');
        
        if (!container || !leftBtn || !rightBtn) return;
        
        const parentWidth = container.parentElement?.clientWidth || 0;
        const maxScroll = Math.max(0, container.scrollWidth - parentWidth);
        const currentTransform = container.style.transform;
        const currentOffset = currentTransform ? 
          parseInt(currentTransform.match(/-?\d+/)?.[0] || '0') : 0;
        
        if (currentOffset >= 0) {
          leftBtn.setAttribute('disabled', 'true');
        } else {
          leftBtn.removeAttribute('disabled');
        }
        
        if (Math.abs(currentOffset) >= maxScroll) {
          rightBtn.setAttribute('disabled', 'true');
        } else {
          rightBtn.removeAttribute('disabled');
        }
      }

      function scrollTopics(direction: 'left' | 'right') {
        const container = document.getElementById('topic-pills-container');
        if (!container || !container.parentElement) return;
        
        const parentWidth = container.parentElement.clientWidth;
        const pills = Array.from(container.children) as HTMLElement[];
        
        if (pills.length === 0) return;
        
        const currentTransform = container.style.transform;
        const currentOffset = currentTransform ? 
          parseInt(currentTransform.match(/-?\d+/)?.[0] || '0') : 0;
        
        let newOffset = currentOffset;
        
        if (direction === 'left') {
          for (let i = pills.length - 1; i >= 0; i--) {
            const pillLeft = pills[i].offsetLeft + currentOffset;
            const pillRight = pillLeft + pills[i].offsetWidth;
            if (pillRight <= 0 || pillLeft < 0) {
              newOffset = -pills[i].offsetLeft;
              break;
            }
          }
          if (newOffset === currentOffset) {
            newOffset = 0;
          }
        } else {
          let firstVisibleIndex = -1;
          for (let i = 0; i < pills.length; i++) {
            const pillLeft = pills[i].offsetLeft + currentOffset;
            const pillRight = pillLeft + pills[i].offsetWidth;
            if (pillRight > 0 && pillLeft < parentWidth) {
              firstVisibleIndex = i;
              break;
            }
          }
          if (firstVisibleIndex >= 0 && firstVisibleIndex < pills.length - 1) {
            const nextPillIndex = firstVisibleIndex + 1;
            newOffset = -pills[nextPillIndex].offsetLeft;
          }
        }
        
        const maxScroll = Math.max(0, container.scrollWidth - parentWidth);
        currentTopicScrollOffset = Math.max(-maxScroll, Math.min(0, newOffset));
        
        container.style.transform = `translateX(${currentTopicScrollOffset}px)`;
        updateTopicScrollButtons();
      }

      const topicScrollLeft = document.getElementById('topic-scroll-left');
      const topicScrollRight = document.getElementById('topic-scroll-right');
      
      if (topicScrollLeft) {
        topicScrollLeft.addEventListener('click', () => scrollTopics('left'));
      }
      
      if (topicScrollRight) {
        topicScrollRight.addEventListener('click', () => scrollTopics('right'));
      }

      // Question Type pills (State, Custom) - no scrolling needed
      async function updateTypeStats() {
        const container = document.getElementById('type-pills-container');
        if (!container) return;

        container.innerHTML = '';
        const types = ['State', 'Custom'];

        // Fetch all questions to get totals
        const response = await fetch(`${backendBase}/api/questions/all`, { credentials: 'include' });
        const allQuestions = await response.json();

        for (const type of types) {
          // Count completed from user's database attempts in grid
          const grid = document.getElementById('attempt-grid');
          const cards = Array.from(grid?.querySelectorAll('[data-attempt]') || []);
          const unique = new Map<string, Element>();
          cards.forEach(c => { const id = c.getAttribute('data-attempt'); if(id) unique.set(id,c); });

          console.log(`Type "${type}": Found ${cards.length} cards, ${unique.size} unique`);

          let completed = 0;

          unique.forEach(card => {
            // Use data-question-type attribute from database
            const questionType = card.getAttribute('data-question-type');
            console.log(`Checking card for type "${type}": data-question-type="${questionType}"`);
            if (questionType && questionType.toLowerCase() === type.toLowerCase()) {
              completed++;
            }
          });

          console.log(`Type "${type}": completed=${completed}`);

          // Count total from all questions
          const total = allQuestions.filter((q: any) => {
            const hasYear = q.name && /^\d{4}/.test(q.name);
            const isState = hasYear;
            return (type === 'State' && isState) || (type === 'Custom' && !isState);
          }).length;

          const pill = document.createElement('div');
          pill.className = 'flex-shrink-0 flex items-center gap-1.5 px-2 py-1 rounded-full bg-gray-100 text-gray-700 dark:bg-slate-700 dark:text-gray-300 cursor-pointer hover:bg-gray-200 dark:hover:bg-slate-600';
          pill.setAttribute('data-pill-type', 'type');
          pill.setAttribute('data-pill-value', type);
          pill.innerHTML = `
            <span class="text-xs font-medium">${type}</span>
            <span class="text-xs opacity-70">(${completed}/${total})</span>
          `;
          pill.addEventListener('click', () => applyFilter('type', type));
          container.appendChild(pill);
        }
      }

      // Pills will be updated after cards are rendered in renderAttempts()
      
      // Invalidate cache when new questions might be added (listen to storage events)
      window.addEventListener('storage', (ev) => {
        if (ev.key === 'questionAttempts') {
          // Don't invalidate cache for attempts, only for actual question changes
          return;
        }
      });

      // Manual cache refresh function (can be called when questions are added)
      interface WindowWithRefresh extends Window {
        refreshQuestionCache?: () => void;
      }
      (window as WindowWithRefresh).refreshQuestionCache = () => {
        updateDifficultyProportions();
        updateYearStats();
        updatePaperStats();
        updateTopicStats();
        updateTypeStats();
      };
    })();

    // Profile management
    (async function profileManagement() {
      const API_BASE = 'http://localhost:3001/api/user-auth';
      const profileLoading = document.getElementById('profile-loading');
      const profileFormContainer = document.getElementById('profile-form-container');
      const nameError = document.getElementById('name-error');
      
      let currentFirstName = '';
      let currentLastName = '';

      // Toast notification function
      function showToast(message: string) {
        const toast = document.getElementById('toast-notification');
        const toastMessage = document.getElementById('toast-message');
        
        if (toast && toastMessage) {
          toastMessage.textContent = message;
          
          // Show toast with animation
          toast.classList.remove('opacity-0', 'translate-y-4', 'pointer-events-none');
          toast.classList.add('opacity-100', 'translate-y-0');
          
          // Hide after 1.5 seconds
          setTimeout(() => {
            toast.classList.remove('opacity-100', 'translate-y-0');
            toast.classList.add('opacity-0', 'translate-y-4', 'pointer-events-none');
          }, 1500);
        }
      }

      // Load user profile
      async function loadProfile() {
        try {
          const response = await fetch(`${API_BASE}/me`, {
            credentials: 'include'
          });
          
          if (!response.ok) {
            if (response.status === 401) {
              window.location.href = '/login?returnTo=/progress';
              return;
            }
            throw new Error('Failed to load profile');
          }
          
          const data = await response.json();
          const user = data.user;
          
          // Populate form fields
          const firstNameInput = document.getElementById('firstName') as HTMLInputElement;
          const lastNameInput = document.getElementById('lastName') as HTMLInputElement;
          const emailInput = document.getElementById('email') as HTMLInputElement;
          
          if (firstNameInput) {
            firstNameInput.value = user.firstName || '';
            currentFirstName = user.firstName || '';
          }
          if (lastNameInput) {
            lastNameInput.value = user.lastName || '';
            currentLastName = user.lastName || '';
          }
          if (emailInput) emailInput.value = user.email || '';
          
          // Show profile form
          if (profileLoading) profileLoading.classList.add('hidden');
          if (profileFormContainer) profileFormContainer.classList.remove('hidden');
        } catch (error) {
          console.error('Error loading profile:', error);
          if (profileLoading) {
            profileLoading.innerHTML = '<p class="text-red-500">Failed to load profile</p>';
          }
        }
      }

      // Update profile function
      async function updateProfile(firstName: string, lastName: string) {
        if (nameError) nameError.classList.add('hidden');
        
        if (!firstName.trim()) {
          if (nameError) {
            nameError.textContent = 'First name is required';
            nameError.classList.remove('hidden');
          }
          return false;
        }
        
        try {
          const response = await fetch(`${API_BASE}/update-profile`, {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json',
            },
            credentials: 'include',
            body: JSON.stringify({
              firstName: firstName.trim(),
              lastName: lastName.trim()
            })
          });
          
          if (!response.ok) {
            const data = await response.json();
            throw new Error(data.message || 'Failed to update profile');
          }
          
          // Update stored values
          currentFirstName = firstName.trim();
          currentLastName = lastName.trim();
          
          // Show toast notification
          showToast('Profile updated successfully!');
          
          // Update the header username if it exists
          const authStatus = document.getElementById('auth-status');
          if (authStatus) {
            const menuBtn = authStatus.querySelector('#user-menu-btn');
            if (menuBtn) {
              // Update the button text to show new name
              const nameText = menuBtn.childNodes[2]; // The text node between the SVGs
              if (nameText && nameText.nodeType === Node.TEXT_NODE) {
                nameText.textContent = ` ${firstName.trim()} `;
              }
            }
          }
          
          return true;
        } catch (error) {
          if (nameError) {
            nameError.textContent = error instanceof Error ? error.message : 'Failed to update profile';
            nameError.classList.remove('hidden');
          }
          return false;
        }
      }

      // Handle input changes to show/hide save buttons
      const firstNameInput = document.getElementById('firstName') as HTMLInputElement;
      const lastNameInput = document.getElementById('lastName') as HTMLInputElement;
      const saveFirstNameBtn = document.getElementById('save-firstName');
      const saveLastNameBtn = document.getElementById('save-lastName');
      
      if (firstNameInput && saveFirstNameBtn) {
        // Show save button when user types
        firstNameInput.addEventListener('input', () => {
          const newFirstName = firstNameInput.value.trim();
          if (newFirstName !== currentFirstName) {
            saveFirstNameBtn.classList.remove('hidden');
          } else {
            saveFirstNameBtn.classList.add('hidden');
          }
        });
        
        // Handle save button click
        saveFirstNameBtn.addEventListener('click', async (e) => {
          e.preventDefault();
          const newFirstName = firstNameInput.value.trim();
          const currentLastNameValue = lastNameInput?.value.trim() || '';
          
          if (newFirstName !== currentFirstName) {
            const success = await updateProfile(newFirstName, currentLastNameValue);
            if (success) {
              saveFirstNameBtn.classList.add('hidden');
            }
          }
        });
      }
      
      if (lastNameInput && saveLastNameBtn) {
        // Show save button when user types
        lastNameInput.addEventListener('input', () => {
          const newLastName = lastNameInput.value.trim();
          if (newLastName !== currentLastName) {
            saveLastNameBtn.classList.remove('hidden');
          } else {
            saveLastNameBtn.classList.add('hidden');
          }
        });
        
        // Handle save button click
        saveLastNameBtn.addEventListener('click', async (e) => {
          e.preventDefault();
          const newLastName = lastNameInput.value.trim();
          const currentFirstNameValue = firstNameInput?.value.trim() || '';
          
          if (newLastName !== currentLastName) {
            const success = await updateProfile(currentFirstNameValue, newLastName);
            if (success) {
              saveLastNameBtn.classList.add('hidden');
            }
          }
        });
      }

      // Load profile on page load
      loadProfile();
    })();
  </script>
  <style>
    .notes-clamped { max-height: 4.5rem; overflow: hidden; position: relative; }
    .notes-clamped.expanded { max-height: none; }
    .notes-clamped::after { content: ''; position: absolute; bottom: 0; left:0; right:0; height:1.5rem; background: linear-gradient(to bottom, rgba(255,255,255,0), var(--tw-bg-opacity,#fff)); pointer-events:none; }
    .dark .notes-clamped::after { background: linear-gradient(to bottom, rgba(15,23,42,0), rgba(15,23,42,1)); }
    .notes-clamped.expanded::after { display: none; }
  </style>
</Layout>
