---
import Layout from '~/layouts/PageLayout.astro';

interface QuestionMeta { name?: string; topic?: string | string[]; difficulty?: number | string; timeLimitSeconds?: number }
interface Attempt {
  questionId: string;
  completedAt?: string;
  timeTakenSeconds?: number | null;
  notes: string;
  question?: QuestionMeta | null;
  difficulty?: number | string | null;
}
interface RawAttempt {
  questionId: string;
  completedAt?: string;
  timestamp?: string;
  lastUpdatedAt?: string;
  timeTakenSeconds?: number;
  timeTaken?: number;
  notes?: string;
  question?: QuestionMeta | null;
  difficulty?: number | string;
}

const BACKEND_BASE = import.meta.env.PUBLIC_BACKEND_URL || 'http://localhost:3001';
let attempts: Attempt[] = [];
let stats: { total: number; topics: Record<string, number> } | null = null;
let TOPIC_LABELS: Record<string, string> = {};

try {
  const r = await fetch(`${BACKEND_BASE}/api/progress/completed`, {
    headers: { 'Accept': 'application/json' },
    credentials: 'include'
  });
  if (r.ok) {
    const json = await r.json();
    attempts = (json.attempts || []).map((a: RawAttempt) => ({
      questionId: a.questionId,
      completedAt: a.completedAt || a.timestamp || a.lastUpdatedAt,
      timeTakenSeconds: a.timeTakenSeconds ?? a.timeTaken ?? null,
      notes: a.notes || '',
      question: a.question || null,
      difficulty: a.difficulty ?? a.question?.difficulty ?? null
    }));
  } else if (r.status === 401) {
     // 401 or other status; proceed silently with local attempts per requirements.
  } else {
     // Handle other errors silently
  }
} catch {
  // Backend unreachable; falling back to local attempts (silent per requirements).
}

// Load question stats (counts) for progress bars
try {
  const sr = await fetch(`${BACKEND_BASE}/api/questions/stats`);
  if (sr.ok) {
    stats = await sr.json();
  }
  if (stats && stats.topics) {
    const topicsObj = stats.topics; // local alias for non-null assertion clarity
    // Merge Financial Maths variants into a single canonical key 'financial-maths'
    const financialVariants = ['financial-mathematics', 'financial mathematics'];
    let financialMerged = 0;
    financialVariants.forEach(v => {
      if (topicsObj[v]) { financialMerged += topicsObj[v]; delete topicsObj[v]; }
    });
    if (financialMerged) topicsObj['financial-maths'] = (topicsObj['financial-maths'] || 0) + financialMerged;

    // Remove combined Probability-Statistics synthetic grouping (prob-stat variants)
    const probCombined = ['prob-stat','prob stat','probability-statistics','probability statistics'];
  probCombined.forEach(v => { if (topicsObj[v]) delete topicsObj[v]; });

    // Build labels with special mappings, excluding combined group completely
    const toTitle = (slug: string) => slug.split(/[-_ ]+/).map(w => w ? w[0].toUpperCase() + w.slice(1) : '').join(' ');
    const specialLabelMap: Record<string,string> = {
      'financial-maths': 'Financial Maths'
    };
    TOPIC_LABELS = Object.fromEntries(
  Object.keys(topicsObj)
        .filter(k => !probCombined.includes(k.toLowerCase()))
        .map(k => {
          const lower = k.toLowerCase();
          if (specialLabelMap[lower]) return [k, specialLabelMap[lower]];
          if (lower === 'financial-mathematics' || lower === 'financial mathematics') return [k, 'Financial Maths'];
          if (probCombined.includes(lower)) return [k, '']; // shouldn't reach due to filter
          return [k, toTitle(k)];
        })
    );
  }
} catch { /* ignore stats fetch failure */ }

// Sort attempts newest first
attempts.sort((a,b) => {
  const ta = a.completedAt ? new Date(a.completedAt).getTime() : 0;
  const tb = b.completedAt ? new Date(b.completedAt).getTime() : 0;
  return tb - ta;
});

// Precompute display meta to simplify template (avoids complex logic in JSX section)
interface DisplayTopic { slug: string; label: string }
interface AttemptView { a: Attempt; diffLabel: string | null; diffText: string | null; diffClasses: string; topics: DisplayTopic[]; timeLimitSeconds: number | null; overLimit: boolean }
const attemptViews: AttemptView[] = attempts.map(a => {
  const diffRaw = a.difficulty ?? a.question?.difficulty;
  let diffLabel: string | null = null; // original raw label
  let diffText: string | null = null; // normalized Easy / Medium / Hard
  let diffClasses = '';
  if (diffRaw !== undefined && diffRaw !== null && diffRaw !== '') {
    diffLabel = String(diffRaw);
    const num = parseInt(diffLabel, 10);
    if (!isNaN(num)) {
      if (num <= 1) { diffText = 'Easy'; diffClasses = 'bg-green-100 text-green-700 dark:bg-green-900/40 dark:text-green-300'; }
      else if (num === 2) { diffText = 'Medium'; diffClasses = 'bg-orange-100 text-orange-700 dark:bg-orange-900/40 dark:text-orange-300'; }
      else { diffText = 'Hard'; diffClasses = 'bg-red-100 text-red-700 dark:bg-red-900/40 dark:text-red-300'; }
    } else {
      const lower = diffLabel.toLowerCase();
      if (/(^|\b)(easy|low)(\b|$)/.test(lower)) { diffText = 'Easy'; diffClasses = 'bg-green-100 text-green-700 dark:bg-green-900/40 dark:text-green-300'; }
      else if (/(^|\b)(med|medium|moderate)(\b|$)/.test(lower)) { diffText = 'Medium'; diffClasses = 'bg-orange-100 text-orange-700 dark:bg-orange-900/40 dark:text-orange-300'; }
      else { diffText = 'Hard'; diffClasses = 'bg-red-100 text-red-700 dark:bg-red-900/40 dark:text-red-300'; }
    }
  }
  const topicSlugs: string[] = a.question ? (Array.isArray(a.question.topic) ? a.question.topic : [a.question.topic]).filter(Boolean) as string[] : [];
  const canonical = (slug: string) => {
    const lower = slug.toLowerCase();
    if (lower === 'financial-mathematics' || lower === 'financial mathematics') return 'financial-maths';
    if (lower === 'prob-stat' || lower === 'prob stat' || lower === 'probability-statistics' || lower === 'probability statistics') return ''; // drop combined
    return slug;
  };
  const seenLabels = new Set<string>();
  const topics: DisplayTopic[] = [];
  topicSlugs.forEach(raw => {
    const slug = canonical(raw);
    if (!slug) return; // dropped combined group
    const label = TOPIC_LABELS[slug] || slug.split(/[-_ ]+/).map(w=>w? w[0].toUpperCase()+w.slice(1):'').join(' ');
    if (seenLabels.has(label)) return;
    seenLabels.add(label);
    topics.push({ slug, label });
  });
  const timeLimitSeconds = a.question?.timeLimitSeconds ?? null;
  const overLimit = timeLimitSeconds != null && a.timeTakenSeconds != null && a.timeTakenSeconds > timeLimitSeconds;
  return { a, diffLabel, diffText, diffClasses, topics, timeLimitSeconds, overLimit };
});

// Client will optionally augment with local attempts if none from server.
---

<Layout metadata={{ title: 'Your Progress' }}>
  <div class="min-h-screen bg-gradient-to-br from-pink-50 via-white to-pink-50 dark:from-slate-900 dark:via-slate-800 dark:to-slate-900">
  <section class="max-w-6xl mx-auto px-4 py-10">
    <h1 class="text-3xl font-bold text-gray-800 dark:text-gray-100 mb-4">Progress</h1>
    <div class="flex items-stretch gap-4 mb-8 flex-wrap">
      <div class="w-56">
        {stats ? (
          <select id="topic-filter" class="h-8 w-full text-sm rounded-md border border-gray-300 dark:border-slate-600 bg-white dark:bg-slate-800 text-gray-800 dark:text-gray-100 px-2 focus:outline-none focus:ring-2 focus:ring-blue-500">
            <option value="__all">All Topics</option>
            {Object.keys(stats.topics).sort().map(t => <option value={t}>{TOPIC_LABELS[t] || t.replace(/[-_]/g,' ').replace(/\b\w/g, c=>c.toUpperCase())}</option>)}
          </select>
        ) : (
          <div class="h-8 animate-pulse bg-gray-200 dark:bg-slate-700 rounded-md" />
        )}
      </div>
      <div class="flex-1 min-w-[240px] h-8">
        {stats ? (
          <div class="relative h-full rounded-md bg-gray-200 dark:bg-slate-700 overflow-hidden text-[11px] sm:text-xs">
            <div id="overall-bar-fill" class="absolute inset-y-0 left-0 bg-pink-500 dark:bg-pink-600 transition-all duration-500 ease-out" style={`width:${stats.total ? Math.min(100,(attempts.length / stats.total)*100) : 0}%`}></div>
            <div id="overall-bar-text" class="absolute inset-0 flex items-center justify-center font-medium text-gray-800 dark:text-gray-100" data-mode="all">
              {attempts.length}/{stats.total} ({stats.total ? Math.round((attempts.length / stats.total)*100) : 0}%)
            </div>
          </div>
        ) : (
          <div class="h-full animate-pulse bg-gray-200 dark:bg-slate-700 rounded-md" />
        )}
      </div>
    </div>
    {/* Auth warning removed intentionally */}
    <div id="empty-progress-state" class={attempts.length === 0 ? '' : 'hidden'}>
      <div class="flex flex-col items-center justify-center py-24 text-center text-gray-500 dark:text-gray-400">
        <div class="w-28 h-28 mb-6 opacity-60">
          <svg viewBox="0 0 120 120" class="w-full h-full" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="60" cy="60" r="36" stroke-dasharray="6 8" />
            <path d="M30 78c8 10 20 16 30 16 14 0 26-8 34-20M32 52c4-12 16-22 28-22 10 0 20 6 26 14M44 88c-4-4-8-10-10-16M82 84c2-6 4-14 2-20M52 34c-2 4-4 8-4 12" />
            <path d="M18 96c12 4 28 6 42 6 18 0 36-4 48-10" stroke-dasharray="4 10" />
          </svg>
        </div>
        <p class="text-lg font-medium mb-2">No completed attempts yet</p>
        <p class="max-w-md text-sm mb-6">Head over to Practice and solve your first question. Your progress will appear here once you save an attempt.</p>
        <a href="/maths/practice" class="inline-flex items-center px-5 py-2.5 rounded-lg bg-red-200 text-red-800 font-medium hover:bg-red-300 dark:bg-red-900 dark:text-red-200 dark:hover:bg-red-800 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-400 dark:focus:ring-offset-slate-900 transition">Go to Practice</a>
      </div>
    </div>
  <div id="topic-labels" data-topic-labels={JSON.stringify(TOPIC_LABELS)} class="hidden"></div>
  {stats && <div id="progress-stats" data-stats={JSON.stringify(stats)} class="hidden"></div>}
  <div class="grid gap-4 md:gap-6" id="attempt-grid" data-backend={BACKEND_BASE}>
      {attemptViews.map(({ a, diffText, diffClasses, topics, overLimit }) => (
        <div class="rounded-xl border border-gray-200 dark:border-slate-700 bg-white dark:bg-slate-800 p-4 shadow-sm flex flex-col gap-3" data-attempt={a.questionId} data-difficulty={diffText || ''} data-time={a.timeTakenSeconds || ''}>
          <div class="flex items-start justify-between gap-4">
            <div class="flex-1">
              <div class="flex flex-wrap items-center gap-3">
                {(() => {
                  const primaryTopic = (topics && topics.length) ? topics[0].slug : (a.questionId.split('-')[0] || 'unknown');
                  const practiceHref = `/maths/practice/${primaryTopic}?q=${a.questionId}`;
                  return (
                    <h2 class="m-0 font-semibold text-gray-900 dark:text-gray-100 text-lg leading-tight">
                      <a href={practiceHref} class="hover:underline focus:outline-none focus:ring-2 focus:ring-blue-500 rounded-sm">{a.question?.name || a.questionId}</a>
                    </h2>
                  );
                })()}
                <div class="flex flex-wrap items-center gap-2 ml-1 pt-0.5">
                  {diffText && <span class={`inline-flex items-center px-2 py-1 rounded-md text-xs font-medium ${diffClasses}`} data-difficulty-chip>{diffText}</span>}
                  {topics.map(t => (
                    <span class="inline-flex items-center px-2 py-1 rounded-md text-xs font-medium bg-gray-100 dark:bg-slate-700 text-gray-700 dark:text-gray-300" data-topic={t.slug} title={t.slug}>{t.label}</span>
                  ))}
                </div>
              </div>
              <p class="text-xs text-gray-500 dark:text-gray-400 mt-1">{a.completedAt ? new Date(a.completedAt).toLocaleString() : ''}</p>
            </div>
            {a.timeTakenSeconds != null && (
              <div class="flex items-start gap-2">
                <span class={`inline-flex items-center h-7 px-2 py-1 rounded-md text-xs font-medium self-start ${overLimit ? 'bg-red-100 dark:bg-red-900 text-red-700 dark:text-red-300' : 'bg-blue-100 dark:bg-blue-900 text-blue-700 dark:text-blue-300'}`}
                  data-time-chip>
                  {Math.floor((a.timeTakenSeconds || 0) / 60).toString().padStart(2,'0')}:{((a.timeTakenSeconds || 0) % 60).toString().padStart(2,'0')}
                </span>
                <button class="edit-notes inline-flex items-center justify-center h-7 w-7 rounded-md border border-transparent hover:border-blue-500 text-gray-500 hover:text-blue-600 dark:text-gray-400 dark:hover:text-blue-400" title="Edit notes" data-question-id={a.questionId}>
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path d="M13.586 3.586a2 2 0 0 1 2.828 2.828l-8.486 8.486a1 1 0 0 1-.293.195l-3 1a1 1 0 0 1-1.272-1.272l1-3a1 1 0 0 1 .195-.293l8.486-8.486ZM11.172 5 5 11.172V13h1.828L13 6.828 11.172 5Z" /></svg>
                </button>
              </div>
            )}
          </div>
          {a.notes && (
            <div class="relative">
              <div class="notes-clamped text-sm text-gray-700 dark:text-gray-300" data-full={a.notes}>{a.notes}</div>
              <button class="expand-notes text-xs mt-1 text-blue-600 dark:text-blue-400 hover:underline">Expand</button>
            </div>
          )}
        </div>
      ))}
    </div>
  </section>
  </div>

  <!-- Edit Notes Modal -->
  <div id="edit-notes-modal" class="fixed inset-0 bg-black bg-opacity-50 backdrop-blur-sm z-50 flex items-center justify-center hidden">
    <div class="bg-white dark:bg-slate-800 rounded-xl p-6 max-w-md w-full mx-4 shadow-xl">
      <h3 class="text-lg font-semibold text-gray-800 dark:text-gray-200 mb-4">Edit Attempt Notes</h3>
      <div class="mb-4">
        <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Question:</label>
        <div id="edit-modal-question-title" class="p-3 bg-gray-50 dark:bg-slate-700 rounded-lg text-gray-800 dark:text-gray-200">--</div>
      </div>
      <div class="mb-4">
        <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Time Taken:</label>
        <div id="edit-modal-time-taken" class="p-3 bg-gray-50 dark:bg-slate-700 rounded-lg font-mono text-gray-800 dark:text-gray-200">--:--</div>
      </div>
      <div class="mb-6">
        <label for="edit-attempt-notes" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Notes:</label>
        <textarea id="edit-attempt-notes" rows="4" class="w-full p-3 border border-gray-300 dark:border-slate-600 rounded-lg focus:ring-2 focus:ring-pink-500 focus:border-pink-500 dark:bg-slate-700 dark:text-gray-200 resize-none" placeholder="Update your notes for this attempt..."></textarea>
      </div>
      <div class="flex gap-3">
        <button id="cancel-edit-notes" class="flex-1 px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 dark:bg-slate-600 dark:text-gray-200 dark:hover:bg-slate-500">Cancel</button>
        <button id="confirm-edit-notes" class="flex-1 px-4 py-2 bg-pink-500 text-white rounded-lg hover:bg-pink-600 dark:bg-pink-600 dark:hover:bg-pink-700">Save Notes</button>
      </div>
    </div>
  </div>

  <script>
    (function(){
      function loadLocalAttempts(){
        try {
          const raw = localStorage.getItem('questionAttempts');
          if(!raw) return [];
          return JSON.parse(raw);
        } catch { return []; }
      }
      const grid = document.getElementById('attempt-grid');
      const emptyState = document.getElementById('empty-progress-state');
  const progressStatsEl = document.getElementById('progress-stats');
    const topicSelect = document.getElementById('topic-filter') as HTMLSelectElement | null;
    const topicLabelsEl = document.getElementById('topic-labels');
    let topicLabels: Record<string,string> = {};
  if (topicLabelsEl) { try { topicLabels = JSON.parse(topicLabelsEl.getAttribute('data-topic-labels') || '{}'); } catch { /* ignore */ } }
    const backendBase = grid?.getAttribute('data-backend') || '';
      let statsData: { total?: number; topics?: Record<string, number> } = {};
      if (progressStatsEl) {
        try { statsData = JSON.parse(progressStatsEl.getAttribute('data-stats') || '{}'); } catch { /* ignore parse */ }
      }

      function recomputeProgress(){
        if(!('total' in statsData)) return;
        const selectedTopic = topicSelect && topicSelect.value !== '__all' ? topicSelect.value : null;
        const cards = Array.from(grid?.querySelectorAll('[data-attempt]') || []);
        const unique = new Map<string, Element>();
        cards.forEach(c => { const id = c.getAttribute('data-attempt'); if(id) unique.set(id,c); });
        let total = 0; let completed = 0;
        if (!selectedTopic) {
          total = (statsData.total ?? 0) as number;
          completed = unique.size;
        } else {
          total = statsData.topics && statsData.topics[selectedTopic] ? statsData.topics[selectedTopic] : 0;
          unique.forEach(card => {
            const topics = Array.from(card.querySelectorAll('[data-topic]')).map(e=>e.getAttribute('data-topic')).filter((v): v is string => !!v);
            let match = topics.includes(selectedTopic);
            if (!match && topics.length === 0) {
              const id = card.getAttribute('data-attempt') || '';
              if (id.split('-')[0] === selectedTopic) match = true;
            }
            if (match) completed++;
          });
        }
        const pct = total ? Math.min(100,(completed/total)*100) : 0;
        const fill = document.getElementById('overall-bar-fill');
        const text = document.getElementById('overall-bar-text');
        if (fill) (fill as HTMLElement).style.width = pct + '%';
        if (text) {
          text.textContent = `${completed}/${total} (${Math.round(pct)}%)`;
          text.setAttribute('data-mode', selectedTopic ? 'topic' : 'all');
          text.setAttribute('data-topic', selectedTopic || '');
        }
      }

      if (grid && grid.children.length === 0) {
        const local = loadLocalAttempts();
        if (local.length) {
          // Hide empty state and inject local attempts
          if (emptyState) emptyState.classList.add('hidden');
          // Sort local newest first
          local.sort((a,b) => {
            const ta = a.timestamp ? new Date(a.timestamp).getTime() : 0;
            const tb = b.timestamp ? new Date(b.timestamp).getTime() : 0;
            return tb - ta;
          });
          local.forEach(a => {
            const card = document.createElement('div');
            card.className = 'rounded-xl border border-gray-200 dark:border-slate-700 bg-white dark:bg-slate-800 p-4 shadow-sm flex flex-col gap-3';
            const time = a.timeTaken != null ? `<span class="inline-flex items-center h-7 px-2 py-1 rounded-md bg-blue-100 dark:bg-blue-900 text-blue-700 dark:text-blue-300 text-xs font-medium" data-time-chip>${String(Math.floor(a.timeTaken/60)).padStart(2,'0')}:${String(a.timeTaken%60).padStart(2,'0')}</span>` : '';
            const topic = a.topic || (a.questionId ? a.questionId.split('-')[0] : null);
            const diff = a.difficulty;
            let diffChip = '';
            if (diff !== undefined && diff !== null && diff !== '') {
              const label = String(diff);
              const num = parseInt(label,10);
              let cls=''; let norm='';
              if(!isNaN(num)) {
                if (num <=1) { cls='bg-green-100 text-green-700 dark:bg-green-900/40 dark:text-green-300'; norm='Easy'; }
                else if (num===2) { cls='bg-orange-100 text-orange-700 dark:bg-orange-900/40 dark:text-orange-300'; norm='Medium'; }
                else { cls='bg-red-100 text-red-700 dark:bg-red-900/40 dark:text-red-300'; norm='Hard'; }
              } else {
                const lower=label.toLowerCase();
                if(/(easy|low)/.test(lower)) { cls='bg-green-100 text-green-700 dark:bg-green-900/40 dark:text-green-300'; norm='Easy'; }
                else if(/(med|medium|moderate)/.test(lower)) { cls='bg-orange-100 text-orange-700 dark:bg-orange-900/40 dark:text-orange-300'; norm='Medium'; }
                else { cls='bg-red-100 text-red-700 dark:bg-red-900/40 dark:text-red-300'; norm='Hard'; }
              }
              diffChip = `<span class="inline-flex items-center px-2 py-1 rounded-md text-xs font-medium ${cls}" data-difficulty-chip>${norm || label}</span>`;
            }
            const displayTopic = topic ? (topicLabels[topic] || topic.split(/[-_ ]+/).map(w=>w? w[0].toUpperCase()+w.slice(1):'').join(' ')) : '';
            const localTopicChip = topic ? `<span class="inline-flex items-center px-2 py-1 rounded-md text-xs font-medium bg-gray-100 dark:bg-slate-700 text-gray-700 dark:text-gray-300" data-topic="${topic}" title="${topic}">${displayTopic}</span>` : '';
            const notesBlock = a.notes ? `<div class="relative"><div class="notes-clamped text-sm text-gray-700 dark:text-gray-300" data-full="${(a.notes||'').replace(/"/g,'&quot;')}">${a.notes}</div><button class="expand-notes text-xs mt-1 text-blue-600 dark:text-blue-400 hover:underline">Expand</button></div>` : '';
            card.innerHTML = `
              <div class="flex items-start justify-between gap-4">
                <div class="flex-1">
                  <div class="flex flex-wrap items-center gap-3">
                    ${(() => {
                      const primaryTopic = (topic || (a.questionId ? a.questionId.split('-')[0] : 'unknown'));
                      const practiceHref = `/maths/practice/${primaryTopic}?q=${a.questionId}`;
                      return `<h2 class="m-0 font-semibold text-gray-900 dark:text-gray-100 text-lg leading-tight"><a href="${practiceHref}" class="hover:underline focus:outline-none focus:ring-2 focus:ring-blue-500 rounded-sm">${a.questionName || a.questionId}</a></h2>`;
                    })()}
                    <div class="flex flex-wrap items-center gap-2 ml-1 pt-0.5">${diffChip}${localTopicChip}</div>
                  </div>
                  <p class="text-xs text-gray-500 dark:text-gray-400 mt-1">${a.timestamp ? new Date(a.timestamp).toLocaleString() : ''}</p>
                </div>
                <div class="flex items-start gap-2">${time}
                  <button class="edit-notes inline-flex items-center justify-center h-7 w-7 rounded-md border border-transparent hover:border-blue-500 text-gray-500 hover:text-blue-600 dark:text-gray-400 dark:hover:text-blue-400" title="Edit notes" data-question-id="${a.questionId}">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path d="M13.586 3.586a2 2 0 0 1 2.828 2.828l-8.486 8.486a1 1 0 0 1-.293.195l-3 1a1 1 0 0 1-1.272-1.272l1-3a1 1 0 0 1 .195-.293l8.486-8.486ZM11.172 5 5 11.172V13h1.828L13 6.828 11.172 5Z" /></svg>
                  </button>
                </div>
              </div>
              ${notesBlock}
            `;
            card.setAttribute('data-attempt', a.questionId);
            grid.appendChild(card);
          });
          recomputeProgress();
        }
      }

      // Modal state
      let editingAttemptId: string | null = null;
      const editModal = document.getElementById('edit-notes-modal');
      const editNotesTextarea = document.getElementById('edit-attempt-notes') as HTMLTextAreaElement | null;
      const editQuestionTitleEl = document.getElementById('edit-modal-question-title');
      const editTimeTakenEl = document.getElementById('edit-modal-time-taken');
      const cancelEditBtn = document.getElementById('cancel-edit-notes');
      const confirmEditBtn = document.getElementById('confirm-edit-notes');

      function openEditModal(qid: string, currentNotes: string, questionTitle: string, timeSeconds: number | null){
        editingAttemptId = qid;
        if (editNotesTextarea) editNotesTextarea.value = currentNotes;
        if (editQuestionTitleEl) editQuestionTitleEl.textContent = questionTitle || qid;
        if (editTimeTakenEl) {
          if (timeSeconds != null) {
            const m = Math.floor(timeSeconds/60).toString().padStart(2,'0');
            const s = (timeSeconds%60).toString().padStart(2,'0');
            editTimeTakenEl.textContent = `${m}:${s}`;
          } else {
            editTimeTakenEl.textContent = '--:--';
          }
        }
        if (editModal) {
          editModal.classList.remove('hidden');
          document.body.style.overflow='hidden';
          setTimeout(()=>{ editNotesTextarea?.focus({preventScroll:true}); }, 50);
        }
      }

      function closeEditModal(){
        if (editModal) editModal.classList.add('hidden');
        document.body.style.overflow='';
        editingAttemptId = null;
      }

      cancelEditBtn?.addEventListener('click', ()=> closeEditModal());
      cancelEditBtn?.addEventListener('keydown', e=>{ if(e.key==='Escape') closeEditModal(); });
      document.addEventListener('keydown', e=>{ if(e.key==='Escape' && !editModal?.classList.contains('hidden')) closeEditModal(); });
      confirmEditBtn?.addEventListener('click', async ()=>{
        if(!editingAttemptId) return;
        const newNotes = editNotesTextarea ? editNotesTextarea.value : '';
        // Update card UI
        const card = grid?.querySelector(`[data-attempt="${editingAttemptId}"]`);
        if (card) {
          let notesEl = card.querySelector('.notes-clamped') as HTMLElement | null;
          if (newNotes.trim() === '') {
            if (notesEl) { const wrapper = notesEl.parentElement; if (wrapper) wrapper.remove(); }
          } else {
            if (!notesEl) {
              const block = document.createElement('div');
              block.className = 'relative';
              block.innerHTML = `<div class="notes-clamped text-sm text-gray-700 dark:text-gray-300" data-full="${newNotes.replace(/"/g,'&quot;')}">${newNotes}</div><button class="expand-notes text-xs mt-1 text-blue-600 dark:text-blue-400 hover:underline">Expand</button>`;
              card.appendChild(block);
              notesEl = block.querySelector('.notes-clamped') as HTMLElement | null;
            } else {
              notesEl.textContent = newNotes;
              notesEl.setAttribute('data-full', newNotes);
            }
          }
        }
        // Persist
        if (backendBase) {
          try { await fetch(`${backendBase}/api/progress/${editingAttemptId}/attempt`, { method:'POST', headers:{'Content-Type':'application/json'}, credentials:'include', body: JSON.stringify({ notes: newNotes }) }); } catch { /* ignore */ }
        }
        try { const local = loadLocalAttempts(); const found = local.find(a=>a.questionId===editingAttemptId); if(found){ found.notes = newNotes; localStorage.setItem('questionAttempts', JSON.stringify(local)); } } catch { /* ignore */ }
        closeEditModal();
        setTimeout(applyOverflowDetection, 30);
      });

      document.addEventListener('click', async function(e){
        const target = e.target as Element | null;
        if(!target) return;

        // Expand / Collapse notes
        const expandBtn = target.closest('.expand-notes');
        if (expandBtn) {
          const wrapper = (expandBtn as HTMLElement).previousElementSibling;
          if(wrapper instanceof HTMLElement) {
            if(wrapper.classList.contains('expanded')) {
              wrapper.classList.remove('expanded');
              (expandBtn as HTMLElement).textContent = 'Expand';
            } else {
              wrapper.classList.add('expanded');
              (expandBtn as HTMLElement).textContent = 'Collapse';
            }
          }
          return;
        }

        // Edit notes button
        const editBtn = target.closest('.edit-notes');
        if (editBtn) {
          const qid = (editBtn as HTMLElement).getAttribute('data-question-id');
          if(!qid) return;
          const card = (editBtn as HTMLElement).closest('[data-attempt]');
          if(!card) return;
          const notesEl = card.querySelector('.notes-clamped') as HTMLElement | null;
          const current = notesEl ? (notesEl.getAttribute('data-full') || notesEl.textContent || '') : '';
          const titleAnchor = card.querySelector('h2 a');
          const questionTitle = titleAnchor ? (titleAnchor.textContent || qid) : qid;
          const timeAttr = card.getAttribute('data-time');
          const timeSeconds = timeAttr ? parseInt(timeAttr,10) : null;
          openEditModal(qid, current, questionTitle, timeSeconds);
        }
      });

      // Overflow detection for notes: remove expand button if not needed
      function applyOverflowDetection(){
        document.querySelectorAll('.notes-clamped').forEach(el => {
          if(!(el instanceof HTMLElement)) return;
          const btn = el.parentElement?.querySelector('.expand-notes');
            if (!btn) return;
          if (el.scrollHeight <= el.clientHeight + 2) {
            btn.remove();
          }
        });
      }
      applyOverflowDetection();
      // Re-run after a tick for dynamically injected content
      setTimeout(applyOverflowDetection, 50);

      // Listen for storage changes (another tab saving attempts)
      window.addEventListener('storage', ev => {
        if (ev.key === 'questionAttempts') {
          // naive refresh strategy: if grid is empty, repopulate; else only recompute progress
          recomputeProgress();
        }
      });
      recomputeProgress();
      if (topicSelect) topicSelect.addEventListener('change', recomputeProgress);
    })();
  </script>
  <style>
    .notes-clamped { max-height: 4.5rem; overflow: hidden; position: relative; }
    .notes-clamped.expanded { max-height: none; }
    .notes-clamped::after { content: ''; position: absolute; bottom: 0; left:0; right:0; height:1.5rem; background: linear-gradient(to bottom, rgba(255,255,255,0), var(--tw-bg-opacity,#fff)); pointer-events:none; }
    .dark .notes-clamped::after { background: linear-gradient(to bottom, rgba(15,23,42,0), rgba(15,23,42,1)); }
    .notes-clamped.expanded::after { display: none; }
  </style>
</Layout>
