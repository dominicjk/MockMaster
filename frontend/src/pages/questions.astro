---
// src/pages/questions.astro
import Layout from '~/layouts/PageLayout.astro';
// Bundle thumbnails - commented out for now, will be used later
// import bundleThumbnail from '~/assets/images/bundle_questions/Geometric_Theoream_PNG.png';
// import constructionThumbnail from '~/assets/images/bundle_questions/Constructions_Question.png';

const metadata = {
  title: 'Questions - Browse All Problems',
  description: 'Browse and practice all available mathematics problems organized by topic and difficulty.',
};
---

<Layout metadata={metadata}>
  <!-- Loading Screen Overlay -->
  <div id="loading-overlay" class="fixed inset-0 bg-white dark:bg-slate-900 z-50 flex items-center justify-center">
    <div class="text-center">
      <div class="inline-block animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mb-4"></div>
      <h2 class="text-xl font-semibold text-gray-800 dark:text-gray-200 mb-2">Loading Questions</h2>
      <p class="text-gray-600 dark:text-gray-400" id="loading-message">Fetching question database...</p>
    </div>
  </div>

  <!-- Pink background similar to practice page -->
  <div class="min-h-screen bg-gradient-to-br from-pink-50 via-white to-pink-50 dark:from-slate-900 dark:via-slate-800 dark:to-slate-900">
    <div class="mx-auto w-full px-4 sm:px-6 lg:px-8 py-8">
      
      {/* Question Bundles Section - COMMENTED OUT - Will be used later
      <div class="mb-8">
        <h2 class="text-2xl font-bold text-gray-900 dark:text-white mb-4">Question Bundles</h2>
        <div class="relative">
          <div class="overflow-x-auto scrollbar-hide bundle-cards-container" style="scroll-behavior: smooth;">
            <div class="flex gap-4 pb-2">
              Bundle cards here...
            </div>
          </div>
        </div>
      </div>
      */}

      <!-- Quick Filter Pills (LeetCode style) -->
      <div class="mb-6">
        <div class="flex flex-wrap gap-2">
          <button 
            data-quick-filter="all" 
            class="quick-filter-pill active px-4 py-2 rounded-full text-sm font-medium transition-all duration-200 bg-blue-100 text-blue-700 dark:bg-blue-900/30 dark:text-blue-300 hover:bg-blue-200 dark:hover:bg-blue-900/50"
          >
            All Questions
          </button>
          <button 
            data-quick-filter="paper1" 
            class="quick-filter-pill px-4 py-2 rounded-full text-sm font-medium transition-all duration-200 bg-gray-200 text-gray-700 dark:bg-slate-700 dark:text-gray-300 hover:bg-gray-300 dark:hover:bg-slate-600 flex items-center gap-1.5"
          >
            <svg class="w-3.5 h-3.5 text-gray-500 dark:text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
            </svg>
            <span>Paper 1</span>
          </button>
          <button 
            data-quick-filter="paper2" 
            class="quick-filter-pill px-4 py-2 rounded-full text-sm font-medium transition-all duration-200 bg-gray-200 text-gray-700 dark:bg-slate-700 dark:text-gray-300 hover:bg-gray-300 dark:hover:bg-slate-600 flex items-center gap-1.5"
          >
            <svg class="w-3.5 h-3.5 text-gray-500 dark:text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
            </svg>
            <span>Paper 2</span>
          </button>
          <button 
            data-quick-filter="calculus" 
            class="quick-filter-pill px-4 py-2 rounded-full text-sm font-medium transition-all duration-200 bg-gray-200 text-gray-700 dark:bg-slate-700 dark:text-gray-300 hover:bg-gray-300 dark:hover:bg-slate-600 flex items-center gap-1.5"
          >
            <svg class="w-4 h-4 text-gray-500 dark:text-gray-400" fill="currentColor" viewBox="0 0 24 24">
              <path d="M12 2C10.5 2 9.5 3 9.5 4.5C9.5 5 9.7 5.5 10 6L8 12C7.5 13.5 6.5 14.5 5 14.5C4.5 14.5 4 14.3 4 14C4 13.5 4.5 13 5 13C5.5 13 6 13.5 6 14H8C8 12.5 7 11.5 5.5 11.5C4 11.5 2.5 12.5 2.5 14C2.5 15.5 3.5 17 5.5 17C7.5 17 9 15.5 9.5 13.5L11.5 7.5C11.8 7.8 12.2 8 12.5 8C13.3 8 14 7.3 14 6.5C14 5.7 13.3 5 12.5 5C11.7 5 11 5.7 11 6.5C11 6.7 11.1 6.9 11.2 7.1L9.2 13.1C9.1 12.9 9 12.7 9 12.5C9 11.1 10.1 10 11.5 10C11.8 10 12.1 10.1 12.4 10.2L14.4 4.2C14.1 3.9 14 3.5 14 3C14 1.9 14.9 1 16 1C17.1 1 18 1.9 18 3C18 4.1 17.1 5 16 5C15.7 5 15.4 4.9 15.1 4.8L13.1 10.8C14.2 11.5 15 12.7 15 14C15 16.2 13.2 18 11 18C8.8 18 7 16.2 7 14C7 13.4 7.1 12.8 7.4 12.3L9.4 6.3C9.2 6.1 9 5.8 9 5.5C9 4.1 10.1 3 11.5 3C12 3 12.4 3.2 12.7 3.5L10.7 9.5C11.5 9.2 12.2 9 13 9C15.2 9 17 10.8 17 13C17 15.2 15.2 17 13 17C12.4 17 11.8 16.9 11.3 16.6L13.3 10.6C13.1 10.2 13 9.8 13 9.5C13 8.1 14.1 7 15.5 7C16.9 7 18 8.1 18 9.5C18 10.9 16.9 12 15.5 12C15 12 14.6 11.8 14.3 11.5L12.3 17.5C12.5 17.7 12.8 18 13 18.5C13 19.9 11.9 21 10.5 21C9.1 21 8 19.9 8 18.5C8 17.1 9.1 16 10.5 16C10.8 16 11.1 16.1 11.4 16.2L13.4 10.2C12.6 9.5 12 8.3 12 7C12 4.8 13.8 3 16 3C18.2 3 20 4.8 20 7C20 9.2 18.2 11 16 11C15.4 11 14.8 10.9 14.3 10.6L12.3 16.6C12.8 17.4 13 18.2 13 19C13 21.2 11.2 23 9 23C6.8 23 5 21.2 5 19C5 16.8 6.8 15 9 15C9.6 15 10.2 15.1 10.7 15.4L12.7 9.4C12.5 9.1 12.3 8.7 12.2 8.3L10.2 14.3C9.4 13.6 8.2 13 7 13C4.8 13 3 14.8 3 17C3 19.2 4.8 21 7 21C9.2 21 11 19.2 11 17C11 16.4 10.9 15.8 10.6 15.3L12.6 9.3C13.4 10 14.6 10.5 16 10.5C18.2 10.5 20 8.7 20 6.5C20 4.3 18.2 2.5 16 2.5C14.6 2.5 13.4 3.2 12.6 4.3L10.6 10.3C10.2 10.1 9.8 10 9.5 10C8.1 10 7 11.1 7 12.5C7 13.9 8.1 15 9.5 15C10 15 10.4 14.8 10.7 14.5L12.7 8.5C12.9 8.7 13.2 9 13.5 9C14.3 9 15 8.3 15 7.5C15 6.7 14.3 6 13.5 6C12.7 6 12 6.7 12 7.5C12 7.8 12.1 8 12.3 8.2L10.3 14.2C10 14 9.6 14 9.5 14C8.1 14 7 15.1 7 16.5C7 17.9 8.1 19 9.5 19C10.9 19 12 17.9 12 16.5C12 16 11.8 15.6 11.5 15.3L13.5 9.3C13.8 9.7 14.2 10 14.5 10C15.3 10 16 9.3 16 8.5C16 7.7 15.3 7 14.5 7C14 7 13.6 7.2 13.3 7.5L11.3 13.5C11 13.2 10.6 13 10.5 13C9.1 13 8 14.1 8 15.5C8 16.9 9.1 18 10.5 18C11.9 18 13 16.9 13 15.5C13 15 12.8 14.6 12.5 14.3L14.5 8.3C14.8 8.7 15.2 9 15.5 9C16.3 9 17 8.3 17 7.5C17 6.7 16.3 6 15.5 6C15 6 14.6 6.2 14.3 6.5L12.3 12.5C12 12.2 11.6 12 11.5 12C10.1 12 9 13.1 9 14.5C9 15.9 10.1 17 11.5 17C12.9 17 14 15.9 14 14.5C14 14 13.8 13.6 13.5 13.3L15.5 7.3C15.8 7.7 16.2 8 16.5 8C17.3 8 18 7.3 18 6.5C18 5.7 17.3 5 16.5 5C16 5 15.6 5.2 15.3 5.5L13.3 11.5C13 11.2 12.6 11 12.5 11C11.1 11 10 12.1 10 13.5C10 14.9 11.1 16 12.5 16C13.9 16 15 14.9 15 13.5C15 13 14.8 12.6 14.5 12.3L16.5 6.3C16.8 6.7 17.2 7 17.5 7C18.3 7 19 6.3 19 5.5C19 4.7 18.3 4 17.5 4C17 4 16.6 4.2 16.3 4.5L14.3 10.5C14 10.2 13.6 10 13.5 10C12.1 10 11 11.1 11 12.5C11 13.9 12.1 15 13.5 15C14.9 15 16 13.9 16 12.5C16 12 15.8 11.6 15.5 11.3L17.5 5.3C17.8 5.7 18.2 6 18.5 6C19.3 6 20 5.3 20 4.5C20 3.7 19.3 3 18.5 3C18 3 17.6 3.2 17.3 3.5L15.3 9.5C15 9.2 14.6 9 14.5 9C13.1 9 12 10.1 12 11.5C12 12.9 13.1 14 14.5 14C15.9 14 17 12.9 17 11.5C17 11 16.8 10.6 16.5 10.3L18.5 4.3C18.8 4.7 19.2 5 19.5 5C20.3 5 21 4.3 21 3.5C21 2.7 20.3 2 19.5 2C19 2 18.6 2.2 18.3 2.5L16.3 8.5C16 8.2 15.6 8 15.5 8C14.1 8 13 9.1 13 10.5C13 11.9 14.1 13 15.5 13C16.9 13 18 11.9 18 10.5C18 10 17.8 9.6 17.5 9.3L19.5 3.3C19.8 3.7 20.2 4 20.5 4C21.3 4 22 3.3 22 2.5C22 1.7 21.3 1 20.5 1C20 1 19.6 1.2 19.3 1.5L17.3 7.5C17 7.2 16.6 7 16.5 7C15.1 7 14 8.1 14 9.5C14 10.9 15.1 12 16.5 12C17.9 12 19 10.9 19 9.5C19 9 18.8 8.6 18.5 8.3L20.5 2.3C20.8 2.7 21.2 3 21.5 3C22.3 3 23 2.3 23 1.5C23 0.7 22.3 0 21.5 0C21 0 20.6 0.2 20.3 0.5L18.3 6.5C18 6.2 17.6 6 17 6C16 6 15 7 15 8C15 9 16 10 17 10C17.5 10 18 9.8 18.3 9.5L20.3 3.5C20.6 3.8 21 4 21.5 4C22.3 4 23 3.3 23 2.5C23 1.7 22.3 1 21.5 1C21 1 20.6 1.2 20.3 1.5L18.3 7.5C18 7.2 17.6 7 17 7C16 7 15 8 15 9C15 10 16 11 17 11C17.5 11 18 10.8 18.3 10.5L20.3 4.5C20.6 4.8 21 5 21.5 5C22.3 5 23 4.3 23 3.5C23 2.7 22.3 2 21.5 2C21 2 20.6 2.2 20.3 2.5L18.3 8.5C18 8.2 17.6 8 17 8C16 8 15 9 15 10C15 11 16 12 17 12"/>
            </svg>
            <span>Calculus</span>
          </button>
          <button 
            data-quick-filter="recent5years" 
            class="quick-filter-pill px-4 py-2 rounded-full text-sm font-medium transition-all duration-200 bg-gray-200 text-gray-700 dark:bg-slate-700 dark:text-gray-300 hover:bg-gray-300 dark:hover:bg-slate-600 flex items-center gap-1.5"
          >
            <svg class="w-3.5 h-3.5 text-gray-500 dark:text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
            <span>&lt; 5 Years</span>
          </button>
        </div>
      </div>

      <!-- Questions List Section -->
      <div class="bg-white/80 dark:bg-slate-800/80 backdrop-blur-sm rounded-xl shadow-lg overflow-hidden border border-pink-100/50 dark:border-slate-700/50">
      <!-- Header -->
      <div class="px-6 py-4 border-b border-gray-200 dark:border-slate-600">
        <div class="flex items-center justify-end">
          <div class="flex items-center gap-4">
            <!-- Sort Dropdown -->
            <select id="sort-filter" class="px-3 py-1.5 text-sm border border-gray-300 dark:border-slate-600 rounded-lg bg-white dark:bg-slate-700 text-gray-600 dark:text-gray-400">
              <option value="year-desc" selected>Newest First</option>
              <option value="year-asc">Oldest First</option>
              <option value="favourites">‚≠ê Favourites</option>
              <option value="completed">Completed</option>
              <option value="incomplete">Incomplete</option>
              <option value="state-exams">State Exams</option>
              <option value="custom-questions">Custom Questions</option>
            </select>
            
            <!-- Filters -->
            <select id="topic-filter" class="px-3 py-1.5 text-sm border border-gray-300 dark:border-slate-600 rounded-lg bg-white dark:bg-slate-700 text-gray-600 dark:text-gray-400">
              <option value="">All Topics</option>
              <option value="__paper1">Paper 1</option>
              <option value="__paper2">Paper 2</option>
            </select>
            <select id="difficulty-filter" class="px-3 py-1.5 text-sm border border-gray-300 dark:border-slate-600 rounded-lg bg-white dark:bg-slate-700 text-gray-600 dark:text-gray-400">
              <option value="">All Difficulties</option>
              <option value="1">Easy</option>
              <option value="2">Medium</option>
              <option value="3">Hard</option>
            </select>
          </div>
        </div>
      </div>

      <!-- Questions Table -->
      <div class="overflow-hidden">
        <!-- Table Header -->
        <div class="px-6 py-3 bg-gray-50 dark:bg-slate-700 border-b border-gray-200 dark:border-slate-600">
            <div class="grid grid-cols-12 gap-4 text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
              <div class="col-span-1 text-center">
                <button id="sort-status" class="inline-flex items-center gap-1 hover:text-blue-600 dark:hover:text-blue-400 hover:bg-gray-100 dark:hover:bg-slate-600 px-2 py-1 rounded transition-all cursor-pointer font-semibold">
                  Status
                  <svg class="w-3.5 h-3.5 opacity-60" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16V4m0 0L3 8m4-4l4 4m6 0v12m0 0l4-4m-4 4l-4-4"/>
                  </svg>
                </button>
              </div>
              <div class="col-span-5">
                <button id="sort-title" class="inline-flex items-center gap-1 hover:text-blue-600 dark:hover:text-blue-400 hover:bg-gray-100 dark:hover:bg-slate-600 px-2 py-1 rounded transition-all cursor-pointer font-semibold">
                  Title
                  <svg class="w-3.5 h-3.5 opacity-60" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16V4m0 0L3 8m4-4l4 4m6 0v12m0 0l4-4m-4 4l-4-4"/>
                  </svg>
                </button>
              </div>
              <div class="col-span-4">Topics</div>
              <div class="col-span-2">
                <button id="sort-difficulty" class="inline-flex items-center gap-1 hover:text-blue-600 dark:hover:text-blue-400 hover:bg-gray-100 dark:hover:bg-slate-600 px-2 py-1 rounded transition-all cursor-pointer font-semibold">
                  Difficulty
                  <svg class="w-3.5 h-3.5 opacity-60" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16V4m0 0L3 8m4-4l4 4m6 0v12m0 0l4-4m-4 4l-4-4"/>
                  </svg>
                </button>
              </div>
            </div>
          </div>

        <!-- Questions List Container -->
        <div id="questions-container" class="divide-y divide-gray-200 dark:divide-slate-600">
          <!-- Questions will be dynamically loaded here -->
        </div>

        <!-- Loading More Indicator -->
        <div id="loading-more" class="hidden px-6 py-4 text-center">
          <div class="inline-block animate-spin rounded-full h-6 w-6 border-b-2 border-blue-600"></div>
          <span class="ml-2 text-gray-600 dark:text-gray-400">Loading more questions...</span>
        </div>

        <!-- Load More Button -->
        <div id="load-more-section" class="hidden px-6 py-6 text-center border-t border-gray-200 dark:border-slate-600">
          <button id="load-more-btn" class="inline-flex items-center px-6 py-3 bg-blue-600 hover:bg-blue-700 text-white font-medium rounded-lg transition-all duration-200 hover:scale-105 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2">
            <span class="mr-2">Load More Questions</span>
            <svg class="w-5 h-5 animate-bounce" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 14l-7 7m0 0l-7-7m7 7V3"/>
            </svg>
          </button>
          <p class="text-sm text-gray-500 dark:text-gray-400 mt-2">
            Showing <span id="questions-shown">0</span> of <span id="questions-total">0</span> questions
          </p>
        </div>

        <!-- End of Results Message -->
        <div id="end-of-results" class="hidden px-6 py-4 text-center border-t border-gray-200 dark:border-slate-600">
          <div class="flex items-center justify-center text-gray-500 dark:text-gray-400">
            <svg class="w-5 h-5 mr-2" fill="currentColor" viewBox="0 0 20 20">
              <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-8.293l-3-3a1 1 0 00-1.414-1.414L9 5.586 7.707 4.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4a1 1 0 00-1.414-1.414z" clip-rule="evenodd"/>
            </svg>
            <span>You've reached the end of all questions!</span>
          </div>
        </div>

        <!-- No Results Message -->
        <div id="no-results" class="hidden px-6 py-12 text-center">
          <svg class="w-12 h-12 text-gray-400 mx-auto mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/>
          </svg>
          <h3 class="text-lg font-medium text-gray-900 dark:text-white mb-2">No questions found</h3>
          <p class="text-gray-500 dark:text-gray-400">Try adjusting your filters or check back later.</p>
        </div>
      </div>
    </div>
  </div>

  <script>
    interface Question {
        id: string;
        name?: string;
        topic?: string | string[];
        subject?: string | string[];
        difficulty?: number | string;
        tags?: string[];
        completed?: boolean;
        title?: string;
        // Allow any additional fields
        [key: string]: unknown;
      }

    // Client-side formatting functions (must be defined early)
    function formatDifficulty(difficulty: number | string | undefined) {
      const difficultyValue = difficulty || 1;
      const difficultyNum = typeof difficultyValue === 'string' ? parseInt(difficultyValue) || 1 : difficultyValue;
      const normalizedDifficulty = Math.min(Math.max(difficultyNum, 1), 3);
      
      const difficultyConfig: { [key: number]: { label: string; color: string } } = {
        1: { label: 'Easy', color: 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-300' },
        2: { label: 'Medium', color: 'bg-orange-100 text-orange-800 dark:bg-orange-900 dark:text-orange-300' },
        3: { label: 'Hard', color: 'bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-300' }
      };
      
      return difficultyConfig[normalizedDifficulty];
    }

    function formatTopicName(topic: string | number | undefined | null): string {
      if (!topic) return '';
      
      const topicStr = String(topic).toLowerCase();
      
      const specialMappings: { [key: string]: string } = {
        'sequences-and-series': 'Sequences & Series',
        'sequences-series': 'Sequences & Series',
        'sequences and series': 'Sequences & Series',
        'prob-stat': 'Probability-Statistics',
        'probability-statistics': 'Probability-Statistics',
        'prob stat': 'Probability-Statistics',
        'the-line': 'The Line',
        'complex-numbers': 'Complex Numbers',
        'complex numbers': 'Complex Numbers',
        'financial-maths': 'Financial Maths',
        'financial maths': 'Financial Maths',
        'compound-interest': 'Compound Interest',
        'compound interest': 'Compound Interest',
        'mathematical-induction': 'Mathematical Induction',
        'mathematical induction': 'Mathematical Induction',
        'proof-by-induction': 'Proof by Induction',
        'proof by induction': 'Proof by Induction',
        'differentiation': 'Differentiation',
        'integration': 'Integration',
        'algebra': 'Algebra',
        'geometry': 'Geometry',
        'trigonometry': 'Trigonometry',
        'statistics': 'Statistics',
        'probability': 'Probability',
        'the-circle': 'The Circle',
        'functions': 'Functions',
        'induction': 'Induction',
        'number': 'Number Systems',
        'number-systems': 'Number Systems',
        'number systems': 'Number Systems'
      };
      
      if (specialMappings[topicStr]) {
        return specialMappings[topicStr];
      }
      
      for (const [key, value] of Object.entries(specialMappings)) {
        if (topicStr.includes(key) || key.includes(topicStr)) {
          return value;
        }
      }
      
      return topicStr
        .replace(/[-_]/g, ' ')
        .split(' ')
        .map(word => word.charAt(0).toUpperCase() + word.slice(1))
        .join(' ');
    }

      let allQuestions: Question[] = [];
      let displayedQuestions: Question[] = [];
      let filteredQuestions: Question[] = [];
      let currentlyShown = 0;
      let currentSort = 'year-desc';
      const questionsPerPage = 20;
      let loadingTimeout: number | null = null;
      let warningTimeout: number | null = null;
      let isLoaded = false;

      // Persisted filter state (initialized from URL params or sessionStorage)
      interface FilterState { topic: string; difficulty: string; sort: string; }
      let initialFilterState: FilterState | null = null;

      function getInitialFilterState(): FilterState {
        if (initialFilterState) return initialFilterState;
        const params = new URLSearchParams(window.location.search);
        let topic = params.get('topic') || '';
        let difficulty = params.get('difficulty') || '';
        let sort = params.get('sort') || 'year-desc';
        // Fallback to sessionStorage if URL lacks values
        try {
          const stored = sessionStorage.getItem('questionsFilters');
          if (stored) {
            const parsed = JSON.parse(stored);
            if (!topic && parsed.topic) topic = parsed.topic;
            if (!difficulty && parsed.difficulty) difficulty = parsed.difficulty;
            if ((!sort || sort === 'year-desc') && parsed.sort) sort = parsed.sort;
          }
        } catch {
          console.warn('Failed to parse stored filters');
        }
        initialFilterState = { topic, difficulty, sort };
        return initialFilterState;
      }

      function persistFilters(topic: string, difficulty: string, sort: string) {
        // Update URL (replaceState to avoid history spam)
        const params = new URLSearchParams(window.location.search);
        if (topic) params.set('topic', topic); else params.delete('topic');
        if (difficulty) params.set('difficulty', difficulty); else params.delete('difficulty');
        if (sort && sort !== 'year-desc') params.set('sort', sort); else params.delete('sort');
        const newQuery = params.toString();
        const newUrl = window.location.pathname + (newQuery ? `?${newQuery}` : '');
        window.history.replaceState(null, '', newUrl);
        try {
          sessionStorage.setItem('questionsFilters', JSON.stringify({ topic, difficulty, sort }));
        } catch {
          /* ignore storage issues */
        }
      }

    // Caching variables
    let questionsCache: Question[] | null = null;
    let cacheTimestamp: number | null = null;
    const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes in milliseconds

    // Cache management functions
    function isCacheValid(): boolean {
      if (!questionsCache || !cacheTimestamp) return false;
      return (Date.now() - cacheTimestamp) < CACHE_DURATION;
    }

    function setCacheData(data: Question[]): void {
      questionsCache = data;
      cacheTimestamp = Date.now();
      // Also store in sessionStorage for persistence across navigation
      try {
        sessionStorage.setItem('questionsCache', JSON.stringify({
          data: data,
          timestamp: cacheTimestamp
        }));
        console.log('üì¶ Questions cached to sessionStorage');
      } catch (e) {
        console.warn('Failed to store cache in sessionStorage:', e);
      }
    }

    function getCacheData(): Question[] | null {
      // First check memory cache
      if (isCacheValid()) {
        console.log('üì¶ Using memory cache');
        return questionsCache;
      }
      
      // Then check sessionStorage
      try {
        const stored = sessionStorage.getItem('questionsCache');
        if (stored) {
          const parsed = JSON.parse(stored);
          const age = Date.now() - parsed.timestamp;
          if (age < CACHE_DURATION) {
            questionsCache = parsed.data;
            cacheTimestamp = parsed.timestamp;
            const minutes = Math.floor(age / 60000);
            console.log(`üì¶ Using sessionStorage cache (${minutes} minute${minutes !== 1 ? 's' : ''} old)`);
            return questionsCache;
          } else {
            console.log('üóëÔ∏è Cache expired, removing old data');
            sessionStorage.removeItem('questionsCache');
          }
        }
      } catch (e) {
        console.warn('Failed to retrieve cache from sessionStorage:', e);
      }
      
      return null;
    }

    function clearCache(): void {
      questionsCache = null;
      cacheTimestamp = null;
      try {
        sessionStorage.removeItem('questionsCache');
        console.log('üóëÔ∏è Cache cleared');
      } catch (e) {
        console.warn('Failed to clear cache from sessionStorage:', e);
      }
    }

    async function loadAllQuestions() {
      try {
        // Check if we have valid cached data
        const cachedData = getCacheData();
        if (cachedData) {
          showLoadingScreen("Loading from cache...");
          
          allQuestions = cachedData;
          
          // Add completed field if not present (default to false)
          allQuestions = allQuestions.map((q, index) => ({
            ...q,
            id: q.id || `question-${index}`,
            completed: q.completed || false
          }));

          // Overlay local attempts for immediate completion feedback
          try {
            const localAttemptsRaw = localStorage.getItem('questionAttempts');
            if (localAttemptsRaw) {
              const localAttempts = JSON.parse(localAttemptsRaw);
              const completedSet = new Set((localAttempts as Array<{questionId?: string}>).map(a => a.questionId).filter(Boolean));
              allQuestions.forEach(q => { if (completedSet.has(q.id)) q.completed = true; });
            }
          } catch { /* ignore local overlay errors */ }

          console.log(`‚úÖ Loaded ${allQuestions.length} questions from cache`);
          
          // Populate topic filter (then attempt filtered display)
          populateTopicFilter();
          const initFilters = getInitialFilterState();
          if (initFilters.topic || initFilters.difficulty || initFilters.sort !== 'year-desc') {
            // Apply persisted filters immediately
            displayQuestions(initFilters.topic, initFilters.difficulty, initFilters.sort, true);
          } else {
            displayQuestions();
          }
          updateTotalCount();
          
          hideLoadingScreen();
          // Notify listeners data is ready
          document.dispatchEvent(new CustomEvent('questions-data-ready'));
          return; // Exit early with cached data
        }

        // No valid cache, fetch fresh data
        console.log('üåê Fetching fresh questions data from API');
        showLoadingScreen("Fetching questions from database...");
        
        // Get all available topics first
        const topicsResponse = await fetch('http://localhost:3001/api/topics');
        if (!topicsResponse.ok) {
          throw new Error(`Failed to fetch topics: ${topicsResponse.status}`);
        }
        
        const topicsData = await topicsResponse.json();
        const topics = topicsData.topics || [];
        
        showLoadingScreen("Loading questions for all topics...");
        
        // Fetch questions for all topics
        const questionsResponse = await fetch('http://localhost:3001/api/topics/questions', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ topics })
        });

        if (!questionsResponse.ok) {
          throw new Error(`Failed to fetch questions: ${questionsResponse.status}`);
        }

        const questionsData = await questionsResponse.json();
        const freshQuestions = questionsData.matchingQuestions || [];
        
        // Cache the fresh data
        setCacheData(freshQuestions);
        
        allQuestions = freshQuestions;
        
        // Add completed field if not present (default to false)
        allQuestions = allQuestions.map((q, index) => ({
          ...q,
          id: q.id || `question-${index}`,
          completed: q.completed || false
        }));

        // Overlay local attempts (fresh fetch scenario)
        try {
          const localAttemptsRaw = localStorage.getItem('questionAttempts');
          if (localAttemptsRaw) {
            const localAttempts = JSON.parse(localAttemptsRaw);
            const completedSet = new Set((localAttempts as Array<{questionId?: string}>).map(a => a.questionId).filter(Boolean));
            allQuestions.forEach(q => { if (completedSet.has(q.id)) q.completed = true; });
          }
        } catch { /* ignore */ }

        console.log(`Loaded ${allQuestions.length} questions`);
        
        // Populate topic filter
        populateTopicFilter();
        const initFilters2 = getInitialFilterState();
        if (initFilters2.topic || initFilters2.difficulty || initFilters2.sort !== 'year-desc') {
          displayQuestions(initFilters2.topic, initFilters2.difficulty, initFilters2.sort, true);
        } else {
          displayQuestions();
        }
        updateTotalCount();
        document.dispatchEvent(new CustomEvent('questions-data-ready'));
        
      } catch (error) {
        console.error('Error loading questions:', error);
        showError('Failed to load questions. Please try refreshing the page.');
      } finally {
        hideLoadingScreen();
      }
    }

    function populateTopicFilter() {
      const topicFilter = document.getElementById('topic-filter') as HTMLSelectElement;
      if (!topicFilter) return;

      // Get unique topics
      const topics = new Set<string>();
      allQuestions.forEach(q => {
        const topicData = q.topic || q.subject;
        if (topicData) {
          // Handle both string and array cases
          if (Array.isArray(topicData)) {
            topicData.forEach(t => {
              if (typeof t === 'string') topics.add(t);
            });
          } else if (typeof topicData === 'string') {
            topics.add(topicData);
          }
        }
      });

      // Clear existing options entirely; will rebuild static + dynamic
      while (topicFilter.firstChild) {
        topicFilter.removeChild(topicFilter.firstChild);
      }

      const init = getInitialFilterState();

      // Static options (bold styled via CSS at bottom)
      const allOpt = document.createElement('option'); allOpt.value=''; allOpt.textContent='All Topics'; topicFilter.appendChild(allOpt);
      const p1Opt = document.createElement('option'); p1Opt.value='__paper1'; p1Opt.textContent='Paper 1'; topicFilter.appendChild(p1Opt);
      const p2Opt = document.createElement('option'); p2Opt.value='__paper2'; p2Opt.textContent='Paper 2'; topicFilter.appendChild(p2Opt);

      // Helper to decide if topic is the combined Probability-Statistics grouping
      const isCombinedProbStat = (val: string) => {
        const v = val.toLowerCase();
        return v === 'prob-stat' || v === 'probability-statistics' || v === 'probability-stat' || v === 'prob stat' || v === 'probability statistics';
      };
      // Normalize label capitalization (each word capitalised) with special mappings
      const formatLabel = (raw: string) => {
        const lower = raw.toLowerCase();
        const special: Record<string,string> = {
          'complex': 'Complex Numbers',
          'complex-numbers': 'Complex Numbers',
          'complex numbers': 'Complex Numbers',
          'financial-maths': 'Financial Maths',
          'sequences-and-series': 'Sequences & Series',
          'sequences': 'Sequences & Series',
          'probability': 'Probability',
          'statistics': 'Statistics',
          'number': 'Number Systems',
          'number-systems': 'Number Systems',
          'number systems': 'Number Systems'
        };
        if (special[lower]) return special[lower];
        return lower.replace(/-/g,' ').split(/\s+/).filter(Boolean).map(w => w.charAt(0).toUpperCase()+w.slice(1)).join(' ');
      };
      // Dynamic topic options (exclude combined Prob-Stat group; individual Probability / Statistics will still appear)
      Array.from(topics)
        .filter(t => !isCombinedProbStat(t))
        .sort((a,b) => a.localeCompare(b))
        .forEach(topic => {
          const option = document.createElement('option');
          option.value = topic;
          option.textContent = formatLabel(topic);
          topicFilter.appendChild(option);
        });

      // Pre-select if persisted
      if (init.topic) {
        topicFilter.value = init.topic;
      }

      // Explicitly apply bold styling (some browsers ignore CSS selector on option)
      try {
        const specialValues = ['', '__paper1', '__paper2'];
        Array.from(topicFilter.options).forEach(opt => {
          if (specialValues.includes(opt.value)) {
            opt.style.fontWeight = '600';
          }
        });
      } catch { /* ignore styling issues */ }
    }

    // Paper 1 topics: algebra, complex numbers, differentiation, integration, sequences, financial maths, induction
    const paper1Topics = [
      'algebra', 'algebraic', 'polynomial', 'quadratic',
      'complex', 'complex-numbers', 'imaginary',
      'differentiation', 'derivative', 'diff',
      'integration', 'integral', 'integrate',
      'sequences', 'sequence', 'series', 'arithmetic', 'geometric',
      'financial', 'financial-maths', 'compound-interest', 'annuity',
      'induction', 'mathematical-induction', 'proof-by-induction'
    ];
    
    function isPaper1Question(question: Question): boolean {
      // First check the title for P1 or P2 markers
      const title = (question.name || question.title || '').toUpperCase();
      
      // If title explicitly contains P2, it's Paper 2
      if (title.includes('P2')) {
        return false;
      }
      
      // If title explicitly contains P1, it's Paper 1
      if (title.includes('P1')) {
        return true;
      }
      
      // Fallback to topic-based detection
      const topics = Array.isArray(question.topic) ? question.topic : [question.topic || question.subject];
      return topics.some(topic => {
        const topicStr = String(topic || '').toLowerCase().replace(/[-_\s]/g, '');
        return paper1Topics.some(p1Topic => {
          const p1TopicStr = p1Topic.toLowerCase().replace(/[-_\s]/g, '');
          return topicStr.includes(p1TopicStr) || p1TopicStr.includes(topicStr);
        });
      });
    }

    function compareExamQuestions(a: Question, b: Question, oldestFirst: boolean = false): number {
      const titleA = a.name || a.title || '';
      const titleB = b.name || b.title || '';
      
      // Extract exam info including priority
      const examInfoA = parseExamInfo(titleA, a);
      const examInfoB = parseExamInfo(titleB, b);
      
      // Sort by exam priority (which already encodes year and exam type order)
      if (examInfoA.examTypePriority !== examInfoB.examTypePriority) {
        return oldestFirst ? examInfoB.examTypePriority - examInfoA.examTypePriority : examInfoA.examTypePriority - examInfoB.examTypePriority;
      }
      
      // Same exam, sort by paper (P1 before P2)
      if (examInfoA.paper !== examInfoB.paper) {
        return examInfoA.paper - examInfoB.paper;
      }
      
      // Same paper, sort by question number
      return examInfoA.questionNumber - examInfoB.questionNumber;
    }
    
    function parseExamInfo(title: string, question?: Question): {
      year: number;
      examTypePriority: number;
      paper: number;
      questionNumber: number;
    } {
      const year = extractYearFromTitle(title);
      const titleLower = title.toLowerCase();
      
      // Define exact exam order based on your specification
      const examOrder = [
        { year: 2024, type: 'main', priority: 1 },
        { year: 2024, type: 'deferred', priority: 2 },
        { year: 2023, type: 'main', priority: 3 },
        { year: 2023, type: 'deferred', priority: 4 },
        { year: 2022, type: 'main', priority: 5 },
        { year: 2022, type: 'deferred', priority: 6 },
        { year: 2021, type: 'main', priority: 7 },
        { year: 2020, type: 'main', priority: 8 },
        { year: 2019, type: 'main', priority: 9 },
        { year: 2018, type: 'main', priority: 10 },
        { year: 2017, type: 'main', priority: 11 },
        { year: 2016, type: 'main', priority: 12 },
        { year: 2015, type: 'main', priority: 13 },
        { year: 2014, type: 'main', priority: 14 },
        { year: 2014, type: 'project', priority: 15 },
        { year: 2014, type: 'sample', priority: 16 },
        { year: 2013, type: 'main', priority: 17 },
        { year: 2013, type: 'project', priority: 18 },
        { year: 2012, type: 'project', priority: 19 }
      ];
      
      // Determine exam type and get priority
      let examTypePriority = 999; // Default for unknown exams
      
      if (titleLower.includes('project maths') || titleLower.includes('project-maths')) {
        const match = examOrder.find(e => e.year === year && e.type === 'project');
        if (match) examTypePriority = match.priority;
      } else if (titleLower.includes('deferred')) {
        const match = examOrder.find(e => e.year === year && e.type === 'deferred');
        if (match) examTypePriority = match.priority;
      } else if (titleLower.includes('sample')) {
        const match = examOrder.find(e => e.year === year && e.type === 'sample');
        if (match) examTypePriority = match.priority;
      } else {
        // Main exam (no special keywords)
        const match = examOrder.find(e => e.year === year && e.type === 'main');
        if (match) examTypePriority = match.priority;
      }
      
      // Determine paper number
      let paper = 1; // Default to Paper 1
      
      // First, try to get paper from title explicitly
      const paperMatch = title.match(/p(?:aper)?\s*(\d+)|section\s*([ab])/i);
      if (paperMatch) {
        if (paperMatch[1]) {
          paper = parseInt(paperMatch[1]);
        } else if (paperMatch[2]) {
          // Handle Section A/B format (A=1, B=2)
          paper = paperMatch[2].toLowerCase() === 'a' ? 1 : 2;
        }
      } else if (question) {
        // If no explicit paper info in title, determine by topics
        paper = isPaper1Question(question) ? 1 : 2;
      }
      
      // Extract question number - try multiple patterns
      let questionNumber = 0;
      const questionPatterns = [
        /(?:question|q)\s*(\d+)/i,
        /(\d+)\s*$/,  // Number at the end
        /#(\d+)/,     // Hashtag format
        /\b(\d+)\b/   // Any number
      ];
      
      for (const pattern of questionPatterns) {
        const match = title.match(pattern);
        if (match) {
          questionNumber = parseInt(match[1]);
          break;
        }
      }
      
      return {
        year,
        examTypePriority,
        paper,
        questionNumber
      };
    }

    function isStateExam(question: Question): boolean {
      const id = question.id || '';
      const match = id.match(/(\w+)-(\d+)/);
      return match ? match[2].startsWith('1') : false; // IDs starting with 1 are state exams
    }
    
    function isCustomQuestion(question: Question): boolean {
      const id = question.id || '';
      const match = id.match(/(\w+)-(\d+)/);
      return match ? match[2].startsWith('0') : false; // IDs starting with 0 are custom questions
    }

    function sortQuestions(questions: Question[], sortBy: string): Question[] {
      const sorted = [...questions];
      
      switch (sortBy) {
        case 'year-asc':
          return sorted.sort((a, b) => {
            return compareExamQuestions(a, b, true); // true = oldest first
          });
          
        case 'year-desc':
          return sorted.sort((a, b) => {
            return compareExamQuestions(a, b, false); // false = newest first
          });
          
        case 'favourites':
          // Filter to show only favourited questions
          return sorted.filter(q => userFavourites.has(q.id));
          
        case 'completed':
          return sorted.filter(q => q.completed);
          
        case 'incomplete':
          return sorted.filter(q => !q.completed);
          
        case 'state-exams':
          return sorted.filter(q => isStateExam(q));
          
        case 'custom-questions':
          return sorted.filter(q => isCustomQuestion(q));
          
        default:
          return sorted; // Keep original order
      }
    }

    function extractYearFromTitle(title: string): number {
      // Look for 4-digit years in the title
      const yearMatch = title.match(/\b(19|20)\d{2}\b/);
      if (yearMatch) {
        return parseInt(yearMatch[0]);
      }
      
      // Look for common year patterns
      const patterns = [
        /year\s*(\d{4})/i,
        /(\d{4})\s*paper/i,
        /exam\s*(\d{4})/i
      ];
      
      for (const pattern of patterns) {
        const match = title.match(pattern);
        if (match) {
          const year = parseInt(match[1]);
          if (year >= 1900 && year <= 2030) {
            return year;
          }
        }
      }
      
      // Default year if no year found (will sort to end)
      return 0;
    }

    function displayQuestions(filterTopic = '', filterDifficulty = '', sortBy = '', reset = true) {
      const container = document.getElementById('questions-container');
      const noResults = document.getElementById('no-results');
      const loadMoreSection = document.getElementById('load-more-section');
      const endOfResults = document.getElementById('end-of-results');
      
      if (!container || !noResults) return;

      // Update current sort if provided, otherwise use default
      if (sortBy) {
        currentSort = sortBy;
      } else if (!sortBy && currentSort === 'year-desc') {
        // Use the default sort when no sort is specified
        currentSort = 'year-desc';
      }

      // Filter questions
      filteredQuestions = allQuestions;
      
      if (filterTopic === '__paper1') {
        filteredQuestions = filteredQuestions.filter(q => isPaper1Question(q));
      } else if (filterTopic === '__paper2') {
        filteredQuestions = filteredQuestions.filter(q => !isPaper1Question(q));
      } else if (filterTopic) {
        filteredQuestions = filteredQuestions.filter(q => {
          const topicData = q.topic || q.subject;
          if (Array.isArray(topicData)) {
            return topicData.includes(filterTopic);
          }
          return topicData === filterTopic;
        });
      }
      
      if (filterDifficulty) {
        filteredQuestions = filteredQuestions.filter(q => 
          String(q.difficulty || '') === filterDifficulty
        );
      }

      // Apply sorting
      filteredQuestions = sortQuestions(filteredQuestions, currentSort);

      // Reset pagination when filters change
      if (reset) {
        currentlyShown = 0;
        container.innerHTML = '';
      }

      displayedQuestions = filteredQuestions;

      if (displayedQuestions.length === 0) {
        noResults.classList.remove('hidden');
        loadMoreSection?.classList.add('hidden');
        endOfResults?.classList.add('hidden');
        return;
      }

      noResults.classList.add('hidden');

      // Calculate which questions to show
      const startIndex = currentlyShown;
      const endIndex = Math.min(currentlyShown + questionsPerPage, displayedQuestions.length);
      const questionsToShow = displayedQuestions.slice(startIndex, endIndex);

      // Add questions to container
      questionsToShow.forEach((question, index) => {
        const questionRow = createQuestionRow(question, startIndex + index);
        container.appendChild(questionRow);
      });

      // Update pagination state
      currentlyShown = endIndex;
      updatePaginationControls();
    }

    function loadMoreQuestions() {
      if (currentlyShown < filteredQuestions.length) {
        const loadingMore = document.getElementById('loading-more');
        const loadMoreBtn = document.getElementById('load-more-btn');
        
        // Show loading state
        loadingMore?.classList.remove('hidden');
        loadMoreBtn?.setAttribute('disabled', 'true');
        
        // Simulate network delay for better UX
        setTimeout(() => {
          // Calculate how many more questions to show
          const endIndex = Math.min(currentlyShown + questionsPerPage, filteredQuestions.length);
          const questionsToShow = filteredQuestions.slice(currentlyShown, endIndex);
          
          // Append the new questions to the container
          const container = document.getElementById('questions-container');
          questionsToShow.forEach((question, index) => {
            const questionRow = createQuestionRow(question, currentlyShown + index);
            if (container) container.appendChild(questionRow);
          });
          
          // Update the counter
          currentlyShown = endIndex;
          updatePaginationControls();
          
          loadingMore?.classList.add('hidden');
          loadMoreBtn?.removeAttribute('disabled');
        }, 300);
      }
    }

    function updatePaginationControls() {
      const questionsShown = document.getElementById('questions-shown');
      const questionsTotal = document.getElementById('questions-total');
      const loadMoreSection = document.getElementById('load-more-section');
      const endOfResults = document.getElementById('end-of-results');

      if (questionsShown) questionsShown.textContent = currentlyShown.toString();
      if (questionsTotal) questionsTotal.textContent = filteredQuestions.length.toString();

      // Show/hide load more button based on remaining questions
      if (currentlyShown < filteredQuestions.length) {
        loadMoreSection?.classList.remove('hidden');
        endOfResults?.classList.add('hidden');
      } else {
        loadMoreSection?.classList.add('hidden');
        if (currentlyShown > 0) {
          endOfResults?.classList.remove('hidden');
        }
      }
    }

    function getFavouriteIds(): string[] { try { return JSON.parse(localStorage.getItem('favouriteQuestions') || '[]'); } catch { return []; } }
    function isFavourite(id: string): boolean { return getFavouriteIds().includes(id); }
    
    // Favourites management - Fetch from backend
    let userFavourites: Set<string> = new Set();
    
    async function loadUserFavourites() {
      try {
        const response = await fetch('http://localhost:3001/api/favourites', {
          method: 'GET',
          credentials: 'include' // Include session cookie
        });
        
        if (response.ok) {
          const data = await response.json();
          userFavourites = new Set(data.favourites.map((f: any) => f.question_id));
          console.log(`‚ú® Loaded ${userFavourites.size} favourites from database`);
          
          // Update UI to show favourite stars
          refreshFavouriteStars();
        } else if (response.status === 401) {
          // User not authenticated, use localStorage fallback
          console.log('User not authenticated, using localStorage for favourites');
          userFavourites = new Set(getFavouriteIds());
        }
      } catch (error) {
        console.error('Error loading favourites:', error);
        // Fallback to localStorage
        userFavourites = new Set(getFavouriteIds());
      }
    }
    
    function refreshFavouriteStars() {
      // Update all visible star icons
      const questionRows = document.querySelectorAll('.question-row-enter');
      questionRows.forEach((row) => {
        const starContainer = row.querySelector('.relative.flex.items-center.justify-center');
        if (starContainer) {
          const questionId = (row as any)._questionId; // We'll store this when creating rows
          if (questionId && userFavourites.has(questionId)) {
            // Add star if not present
            if (!starContainer.querySelector('svg')) {
              const star = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
              star.setAttribute('class', 'absolute -top-2 -left-2 w-3.5 h-3.5 text-yellow-500');
              star.setAttribute('fill', 'currentColor');
              star.setAttribute('viewBox', '0 0 24 24');
              star.setAttribute('aria-label', 'Favourite');
              star.innerHTML = '<path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>';
              starContainer.insertBefore(star, starContainer.firstChild);
            }
          } else {
            // Remove star if present
            const star = starContainer.querySelector('svg');
            if (star) star.remove();
          }
        }
      });
    }
    
    async function toggleFavourite(questionId: string, questionData?: any) {
      const isFav = userFavourites.has(questionId);
      
      console.log('üîÑ toggleFavourite called', { questionId, isFav, questionData });
      
      try {
        if (isFav) {
          // Remove from favourites
          console.log(`üóëÔ∏è Attempting to remove ${questionId} from favourites...`);
          const response = await fetch(`http://localhost:3001/api/favourites/remove/${encodeURIComponent(questionId)}`, {
            method: 'DELETE',
            credentials: 'include'
          });
          
          console.log('Response status:', response.status, response.statusText);
          
          if (response.ok) {
            userFavourites.delete(questionId);
            console.log(`‚úÖ Removed ${questionId} from favourites`);
          } else {
            const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
            console.error('‚ùå Failed to remove favourite:', errorData);
            throw new Error(errorData.error || 'Failed to remove favourite');
          }
        } else {
          // Add to favourites
          const payload = {
            questionId: questionId,
            questionName: questionData?.name || questionData?.title || '',
            parentTopic: Array.isArray(questionData?.topic) ? questionData.topic[0] : questionData?.topic || '',
            difficulty: questionData?.difficulty || '',
            paper: questionData?.paper || '',
            year: questionData?.year || '',
            questionType: questionData?.questionType || 'state'
          };
          
          console.log('‚ûï Attempting to add to favourites...', payload);
          
          const response = await fetch('http://localhost:3001/api/favourites/add', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            credentials: 'include',
            body: JSON.stringify(payload)
          });
          
          console.log('Response status:', response.status, response.statusText);
          
          if (response.ok) {
            const data = await response.json();
            console.log('‚úÖ Server response:', data);
            userFavourites.add(questionId);
            console.log(`‚úÖ Added ${questionId} to favourites`);
          } else {
            const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
            console.error('‚ùå Failed to add favourite:', errorData);
            throw new Error(errorData.error || 'Failed to add favourite');
          }
        }
        
        // Update UI
        refreshFavouriteStars();
        
        // Also update localStorage as backup
        localStorage.setItem('favouriteQuestions', JSON.stringify([...userFavourites]));
        
      } catch (error) {
        console.error('‚ùå Error toggling favourite:', error);
        alert('Failed to update favourite. Please try again. Check console for details.');
      }
    }
    
    function createQuestionRow(question: Question, index: number): HTMLElement {
      const row = document.createElement('div');
      row.className = 'px-4 py-2 hover:bg-pink-50/50 dark:hover:bg-slate-700/50 cursor-pointer transition-all duration-200 question-row-enter hover:shadow-md hover:scale-[1.01] border-b border-pink-100/30 dark:border-slate-700/30';
      
      const difficultyInfo = formatDifficulty(question.difficulty);
      
      // Handle topic data (can be string or array) and expand combined Probability-Statistics group into two badges
      const rawTopicData = question.topic || question.subject;
      const isCombinedProbStat = (val: string) => {
        const v = val.toLowerCase();
        return v === 'prob-stat' || v === 'probability-statistics' || v === 'probability-stat' || v === 'probability_statistics' || v === 'prob stat' || v === 'probability statistics';
      };
      let displayTopics: string[] = [];
      if (Array.isArray(rawTopicData)) {
        rawTopicData.forEach(t => {
          if (typeof t === 'string' && isCombinedProbStat(t)) {
            displayTopics.push('probability','statistics');
          } else if (t) {
            displayTopics.push(String(t));
          }
        });
      } else if (typeof rawTopicData === 'string') {
        if (isCombinedProbStat(rawTopicData)) {
          displayTopics = ['probability','statistics'];
        } else if (rawTopicData) {
          displayTopics = [rawTopicData];
        }
      }
      if (displayTopics.length === 0) displayTopics = ['--'];
      // Deduplicate while preserving original order (avoid double 'Statistics' when combined + single appear)
      const seen = new Set<string>();
      displayTopics = displayTopics.filter(t => {
        const key = t.toLowerCase();
        if (seen.has(key)) return false;
        seen.add(key);
        return true;
      });
      const topicsHtml = displayTopics.map(topic => `
        <span class="inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium bg-gray-100 text-gray-700 dark:bg-slate-700 dark:text-slate-300 whitespace-nowrap">
          ${formatTopicName(topic)}
        </span>`).join('');
      
      // Handle custom question naming based on ID (Custom {Topic} {n})
      let name;
      const id = question.id || '';
      const match = id.match(/([a-zA-Z0-9-]+)-(\d{3,})$/); // final numeric segment (>=3 digits)
      if (match) {
        const numeric = match[2];
        if (numeric.startsWith('0')) {
          // Derive topic slug: prefer first explicit topic; fallback to id prefix before numeric segment
          let topicSlug = '';
          const topicData = question.topic || question.subject;
          if (Array.isArray(topicData)) topicSlug = (topicData[0] || '').toString();
          else if (typeof topicData === 'string') topicSlug = topicData;
          if (!topicSlug) {
            // Remove numeric tail
            topicSlug = match[1].replace(/-$/,'');
          }
            const prettyTopic = formatTopicName(topicSlug || 'Custom');
            const customNumber = parseInt(numeric, 10); // strip leading zeros
            name = `Custom ${prettyTopic} ${customNumber}`;
        } else {
          name = question.name || question.title || `Question ${index + 1}`;
        }
      } else {
        name = question.name || question.title || `Question ${index + 1}`;
      }
      
      // Combined status icon: completed/incomplete + favourite
      const isFav = userFavourites.has(question.id);
      const isComplete = question.completed;
      
      let statusIcon = '';
      if (isFav && isComplete) {
        // Favourite + Complete: Green checkmark with yellow star
        statusIcon = '<div class="flex items-center gap-0.5"><svg class="w-3.5 h-3.5 text-green-500" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"></path></svg><svg class="w-3 h-3 text-yellow-500" fill="currentColor" viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/></svg></div>';
      } else if (isFav && !isComplete) {
        // Favourite + Incomplete: Grey circle with yellow star
        statusIcon = '<div class="flex items-center gap-0.5"><div class="w-3 h-3 rounded-full bg-gray-300 dark:bg-slate-600"></div><svg class="w-3 h-3 text-yellow-500" fill="currentColor" viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/></svg></div>';
      } else if (!isFav && isComplete) {
        // Complete only: Green checkmark
        statusIcon = '<svg class="w-4 h-4 text-green-500" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"></path></svg>';
      } else {
        // Incomplete only: Grey circle
        statusIcon = '<div class="w-3.5 h-3.5 rounded-full bg-gray-300 dark:bg-slate-600"></div>';
      }
      
      row.innerHTML = `
        <div class="grid grid-cols-12 gap-3 items-center question-grid py-1">
          <!-- Status Column -->
          <div class="col-span-1 flex justify-center">
            <div class="status-icon cursor-pointer hover:scale-110 transition-transform">
              ${statusIcon}
            </div>
          </div>
          <!-- Title Column -->
          <div class="col-span-5 title-column">
            <div class="font-medium text-gray-900 dark:text-white transition-colors truncate pr-2" title="${name}">
              ${name}
            </div>
          </div>
          <!-- Topics Column -->
          <div class="col-span-4">
            <div class="flex flex-wrap items-center gap-1 max-h-8 overflow-hidden">
              ${topicsHtml}
            </div>
          </div>
          <!-- Difficulty Column -->
          <div class="col-span-2">
            <span class="inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium ${difficultyInfo.color} whitespace-nowrap">
              ${difficultyInfo.label}
            </span>
          </div>
        </div>`;

      // Store question ID on the row for later use
      (row as any)._questionId = question.id;
      
      // Add click handler to navigate to practice page with specific question
      row.addEventListener('click', (e) => {
        const target = e.target as HTMLElement;
        
        // Check if clicking on status icon to toggle favourite
        if (target.classList.contains('status-icon') || target.closest('.status-icon')) {
          e.stopPropagation();
          toggleFavourite(question.id, question);
          return;
        }
        
        const topicData = question.topic || question.subject || '';
        let topicForUrl = '';
        
        if (Array.isArray(topicData)) {
          topicForUrl = topicData.length > 0 ? topicData[0] : '';
        } else if (typeof topicData === 'string') {
          topicForUrl = topicData;
        }
        
        // Verify question data before navigation
        if (!question.id) {
          console.error('‚ùå Cannot navigate: Question has no ID', question);
          alert('Error: This question has no ID. Please try another question.');
          return;
        }
        
        if (!topicForUrl) {
          console.error('‚ùå Cannot navigate: Question has no topic', question);
          alert('Error: This question has no topic. Please try another question.');
          return;
        }
        
        // Log navigation attempt for debugging
        console.log(`üéØ Navigating to specific question:`, {
          id: question.id,
          name: question.name || question.title || 'Unknown',
          topic: topicForUrl,
          url: `/maths/practice/${topicForUrl}?q=${encodeURIComponent(question.id)}`
        });

        // --- Build ordered sequence (year group or topic group) and stash in sessionStorage ---
        try {
          const extractYear = (nm: unknown) => {
            const m = /^([0-9]{4})/.exec(String(nm || ''));
            return m ? m[1] : '';
          };
          const primaryTopic = (q: Question) => {
            const t = (q.topic as unknown) || (q.subject as unknown) || '';
            if (Array.isArray(t)) return (t as string[])[0] || '';
            return t as string;
          };
          const sortSelect = document.getElementById('sort-filter') as HTMLSelectElement | null;
            const sortValue = sortSelect?.value || currentSort || '';
          let sequenceIds: string[] = [];
          let mode = '';
          let groupValue = '';
          if (sortValue.startsWith('year')) {
            mode = 'year';
            groupValue = extractYear(question.name || question.title || '');
            if (groupValue) {
              sequenceIds = displayedQuestions
                .filter(q => extractYear((q.name || q.title || '')) === groupValue)
                .map(q => q.id)
                .filter(Boolean) as string[];
            }
          } else {
            mode = 'topic';
            groupValue = primaryTopic(question);
            if (groupValue) {
              sequenceIds = displayedQuestions
                .filter(q => primaryTopic(q) === groupValue)
                .map(q => q.id)
                .filter(Boolean) as string[];
            }
          }
          // Persist only if we have at least 2 items (else navigation is trivial)
          if (sequenceIds.length > 1) {
            sessionStorage.setItem('practiceSequence', JSON.stringify({ ids: sequenceIds, mode, group: groupValue, ts: Date.now() }));
          } else {
            sessionStorage.removeItem('practiceSequence');
          }
        } catch (err) {
          console.warn('Failed to build/store practice sequence', err);
        }
        
        if (topicForUrl && question.id) {
          // Navigate to practice page with specific question ID; include sequence=session if we stored one
          const hasSequence = !!sessionStorage.getItem('practiceSequence');
          const navigationUrl = `/maths/practice/${topicForUrl}?q=${encodeURIComponent(question.id)}${hasSequence ? '&sequence=session' : ''}`;
          console.log(`üöÄ Navigating to: ${navigationUrl}`);
          window.location.href = navigationUrl;
        } else if (topicForUrl) {
          // This should not happen due to the checks above, but keep as fallback
          console.warn('‚ö†Ô∏è Fallback navigation to topic only (no question ID)');
          window.location.href = `/maths/practice/${topicForUrl}`;
        }
      });

      return row;
    }

    function toggleQuestionCompleted(questionId: string, completed: boolean) {
      // Find and update the question
      const question = allQuestions.find(q => q.id === questionId);
      if (question) {
        question.completed = completed;
        // Here you would typically send this update to the backend
        console.log(`Question ${questionId} marked as ${completed ? 'completed' : 'not completed'}`);
      }
    }

    function updateTotalCount() {
      const totalElement = document.getElementById('total-questions');
      if (totalElement) {
        totalElement.textContent = allQuestions.length.toString();
      }
    }

    function showLoadingScreen(message = "Loading questions...") {
      const overlay = document.getElementById('loading-overlay');
      const messageEl = document.getElementById('loading-message');
      if (overlay) overlay.style.display = 'flex';
      if (messageEl) messageEl.textContent = message;
    }

    function hideLoadingScreen() {
      const overlay = document.getElementById('loading-overlay');
      if (overlay) {
        overlay.style.opacity = '0';
        setTimeout(() => {
          overlay.style.display = 'none';
          overlay.style.opacity = '1';
        }, 300);
      }
      
      // Clear loading timeout since page has successfully loaded
      clearLoadingTimeout();
    }

    function showError(message: string) {
      const container = document.getElementById('questions-container');
      if (container) {
        container.innerHTML = `
          <div class="px-6 py-12 text-center">
            <svg class="w-12 h-12 text-red-400 mx-auto mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
            </svg>
            <h3 class="text-lg font-medium text-gray-900 dark:text-white mb-2">Error Loading Questions</h3>
            <p class="text-gray-500 dark:text-gray-400">${message}</p>
          </div>
        `;
      }
    }

    // Auto-refresh timeout mechanism
    function startLoadingTimeout() {
      if (loadingTimeout) {
        clearTimeout(loadingTimeout);
      }
      if (warningTimeout) {
        clearTimeout(warningTimeout);
      }
      
      console.log('‚è±Ô∏è Starting 3-second loading timeout...');
      
      // Show warning at 2.5 seconds, then refresh at 3 seconds
      warningTimeout = window.setTimeout(() => {
        if (!isLoaded) {
          console.warn('‚ö†Ô∏è Questions loading slowly, preparing to refresh...');
          showLoadingScreen("Loading taking longer than expected. Auto-refresh in 1 second...");
        }
      }, 2500);
      
      loadingTimeout = window.setTimeout(() => {
        if (!isLoaded) {
          console.warn('üîÑ Questions taking too long to load, auto-refreshing page...');
          showLoadingScreen("Refreshing page for faster loading...");
          
          // Add a small delay to show the message, then refresh
          setTimeout(() => {
            console.log('üîÑ Auto-refreshing page now...');
            window.location.reload();
          }, 800);
        } else {
          if (warningTimeout) clearTimeout(warningTimeout);
        }
      }, 3000); // 3 seconds timeout
    }

    function clearLoadingTimeout() {
      if (loadingTimeout) {
        clearTimeout(loadingTimeout);
        loadingTimeout = null;
      }
      if (warningTimeout) {
        clearTimeout(warningTimeout);
        warningTimeout = null;
      }
      isLoaded = true;
      console.log('‚úÖ Loading completed successfully, timeout cleared');
    }

    // Enhanced loadAllQuestions with timeout handling
    async function loadAllQuestionsWithTimeout() {
      startLoadingTimeout();
      
      try {
        await loadAllQuestions();
        clearLoadingTimeout();
      } catch (error) {
        console.error('Failed to load questions:', error);
        clearLoadingTimeout();
        throw error;
      }
    }

    // Initialize page function
    function initializePage() {
      // Load favourites from database
      loadUserFavourites();
      
      // Load questions when page loads with timeout protection
      loadAllQuestionsWithTimeout();

      // Filter event listeners
      const topicFilter = document.getElementById('topic-filter') as HTMLSelectElement;
      const difficultyFilter = document.getElementById('difficulty-filter') as HTMLSelectElement;
      const sortFilter = document.getElementById('sort-filter') as HTMLSelectElement;
      const loadMoreBtn = document.getElementById('load-more-btn');

      // Apply initial filter values to UI (in case of bfcache or early existing selects)
      const init = getInitialFilterState();
      if (topicFilter && init.topic) topicFilter.value = init.topic;
      if (difficultyFilter && init.difficulty) difficultyFilter.value = init.difficulty;
      if (sortFilter && init.sort) sortFilter.value = init.sort;

      if (topicFilter) {
        topicFilter.addEventListener('change', () => {
          persistFilters(topicFilter.value, difficultyFilter?.value || '', sortFilter?.value || 'year-desc');
          displayQuestions(topicFilter.value, difficultyFilter?.value || '', sortFilter?.value || 'year-desc', true);
        });
      }

      if (difficultyFilter) {
        difficultyFilter.addEventListener('change', () => {
          persistFilters(topicFilter?.value || '', difficultyFilter.value, sortFilter?.value || 'year-desc');
          displayQuestions(topicFilter?.value || '', difficultyFilter.value, sortFilter?.value || 'year-desc', true);
        });
      }

      if (sortFilter) {
        if (!init.sort) sortFilter.value = 'year-desc';
        sortFilter.addEventListener('change', () => {
          persistFilters(topicFilter?.value || '', difficultyFilter?.value || '', sortFilter.value || 'year-desc');
          displayQuestions(topicFilter?.value || '', difficultyFilter?.value || '', sortFilter.value || 'year-desc', true);
        });
      }

      // Column header sort functionality
      let statusSortState = 'none'; // none, completed, incomplete
      let titleSortState = 'none'; // none, asc, desc
      let difficultySortState = 'none'; // none, asc, desc

      const sortStatusBtn = document.getElementById('sort-status');
      const sortTitleBtn = document.getElementById('sort-title');
      const sortDifficultyBtn = document.getElementById('sort-difficulty');

      if (sortStatusBtn) {
        sortStatusBtn.addEventListener('click', () => {
          // Cycle through: none -> completed -> incomplete -> none
          if (statusSortState === 'none') {
            statusSortState = 'completed';
            if (sortFilter) sortFilter.value = 'completed';
          } else if (statusSortState === 'completed') {
            statusSortState = 'incomplete';
            if (sortFilter) sortFilter.value = 'incomplete';
          } else {
            statusSortState = 'none';
            if (sortFilter) sortFilter.value = 'year-desc';
          }
          
          // Reset other column sorts
          titleSortState = 'none';
          difficultySortState = 'none';
          
          persistFilters(topicFilter?.value || '', difficultyFilter?.value || '', sortFilter?.value || 'year-desc');
          displayQuestions(topicFilter?.value || '', difficultyFilter?.value || '', sortFilter?.value || 'year-desc', true);
        });
      }

      if (sortTitleBtn) {
        sortTitleBtn.addEventListener('click', () => {
          // Cycle through: none -> asc -> desc -> none
          if (titleSortState === 'none') {
            titleSortState = 'asc';
            // Sort by title A-Z
            filteredQuestions = filteredQuestions.sort((a, b) => {
              const titleA = (a.name || a.title || '').toLowerCase();
              const titleB = (b.name || b.title || '').toLowerCase();
              return titleA.localeCompare(titleB);
            });
          } else if (titleSortState === 'asc') {
            titleSortState = 'desc';
            // Sort by title Z-A
            filteredQuestions = filteredQuestions.sort((a, b) => {
              const titleA = (a.name || a.title || '').toLowerCase();
              const titleB = (b.name || b.title || '').toLowerCase();
              return titleB.localeCompare(titleA);
            });
          } else {
            titleSortState = 'none';
            if (sortFilter) sortFilter.value = 'year-desc';
            displayQuestions(topicFilter?.value || '', difficultyFilter?.value || '', 'year-desc', true);
            return;
          }
          
          // Reset other column sorts
          statusSortState = 'none';
          difficultySortState = 'none';
          
          // Re-display with new sort
          currentlyShown = 0;
          const container = document.getElementById('questions-container');
          if (container) container.innerHTML = '';
          displayedQuestions = filteredQuestions;
          const endIndex = Math.min(questionsPerPage, filteredQuestions.length);
          const questionsToShow = filteredQuestions.slice(0, endIndex);
          questionsToShow.forEach((question, index) => {
            const questionRow = createQuestionRow(question, index);
            if (container) container.appendChild(questionRow);
          });
          currentlyShown = endIndex;
          updatePaginationControls();
        });
      }

      if (sortDifficultyBtn) {
        sortDifficultyBtn.addEventListener('click', () => {
          // Cycle through: none -> easy-hard -> hard-easy -> none
          if (difficultySortState === 'none') {
            difficultySortState = 'asc';
            // Sort by difficulty easy to hard
            filteredQuestions = filteredQuestions.sort((a, b) => {
              const diffA = parseInt(a.difficulty) || 0;
              const diffB = parseInt(b.difficulty) || 0;
              return diffA - diffB;
            });
          } else if (difficultySortState === 'asc') {
            difficultySortState = 'desc';
            // Sort by difficulty hard to easy
            filteredQuestions = filteredQuestions.sort((a, b) => {
              const diffA = parseInt(a.difficulty) || 0;
              const diffB = parseInt(b.difficulty) || 0;
              return diffB - diffA;
            });
          } else {
            difficultySortState = 'none';
            if (sortFilter) sortFilter.value = 'year-desc';
            displayQuestions(topicFilter?.value || '', difficultyFilter?.value || '', 'year-desc', true);
            return;
          }
          
          // Reset other column sorts
          statusSortState = 'none';
          titleSortState = 'none';
          
          // Re-display with new sort
          currentlyShown = 0;
          const container = document.getElementById('questions-container');
          if (container) container.innerHTML = '';
          displayedQuestions = filteredQuestions;
          const endIndex = Math.min(questionsPerPage, filteredQuestions.length);
          const questionsToShow = filteredQuestions.slice(0, endIndex);
          questionsToShow.forEach((question, index) => {
            const questionRow = createQuestionRow(question, index);
            if (container) container.appendChild(questionRow);
          });
          currentlyShown = endIndex;
          updatePaginationControls();
        });
      }

      // Load more button event listener
      if (loadMoreBtn) {
        loadMoreBtn.addEventListener('click', loadMoreQuestions);
      }

      // Quick Filter Pills functionality
      const quickFilterPills = document.querySelectorAll('.quick-filter-pill');
      quickFilterPills.forEach(pill => {
        pill.addEventListener('click', () => {
          // Remove active class from all pills
          quickFilterPills.forEach(p => {
            p.classList.remove('active', 'bg-blue-100', 'text-blue-700', 'dark:bg-blue-900/30', 'dark:text-blue-300');
            p.classList.add('bg-gray-200', 'text-gray-700', 'dark:bg-slate-700', 'dark:text-gray-300');
          });
          
          // Add active class to clicked pill (subtle blue background)
          pill.classList.add('active', 'bg-blue-100', 'text-blue-700', 'dark:bg-blue-900/30', 'dark:text-blue-300');
          pill.classList.remove('bg-gray-200', 'text-gray-700', 'dark:bg-slate-700', 'dark:text-gray-300');
          
          // Get filter type
          const filterType = pill.getAttribute('data-quick-filter');
          
          // Apply filter based on type
          switch (filterType) {
            case 'all':
              // Reset all filters
              if (topicFilter) topicFilter.value = '';
              if (difficultyFilter) difficultyFilter.value = '';
              persistFilters('', '', sortFilter?.value || 'year-desc');
              displayQuestions('', '', sortFilter?.value || 'year-desc', true);
              break;
              
            case 'paper1':
              // Filter for Paper 1
              if (topicFilter) topicFilter.value = '__paper1';
              persistFilters('__paper1', difficultyFilter?.value || '', sortFilter?.value || 'year-desc');
              displayQuestions('__paper1', difficultyFilter?.value || '', sortFilter?.value || 'year-desc', true);
              break;
              
            case 'paper2':
              // Filter for Paper 2
              if (topicFilter) topicFilter.value = '__paper2';
              persistFilters('__paper2', difficultyFilter?.value || '', sortFilter?.value || 'year-desc');
              displayQuestions('__paper2', difficultyFilter?.value || '', sortFilter?.value || 'year-desc', true);
              break;
              
            case 'calculus': {
              // Filter for questions with differentiation OR integration
              // Use the same filtering logic as the topic dropdown
              const calculusQuestions = allQuestions.filter(q => {
                const topicData = q.topic || q.subject;
                
                // Check if topics contain differentiation or integration
                if (Array.isArray(topicData)) {
                  return topicData.some(topic => {
                    const topicLower = String(topic || '').toLowerCase();
                    return topicLower.includes('differentiation') || 
                           topicLower.includes('integration') ||
                           topicLower.includes('calculus');
                  });
                } else {
                  const topicLower = String(topicData || '').toLowerCase();
                  return topicLower.includes('differentiation') || 
                         topicLower.includes('integration') ||
                         topicLower.includes('calculus');
                }
              });
              
              // Reset dropdown filters
              if (topicFilter) topicFilter.value = '';
              if (difficultyFilter) difficultyFilter.value = '';
              
              // Sort the filtered questions
              filteredQuestions = sortQuestions(calculusQuestions, currentSort);
              displayedQuestions = filteredQuestions;
              
              // Reset pagination and display
              currentlyShown = 0;
              const container = document.getElementById('questions-container');
              if (container) container.innerHTML = '';
              
              // Display all filtered questions with pagination
              const noResults = document.getElementById('no-results');
              if (filteredQuestions.length === 0 && noResults) {
                noResults.classList.remove('hidden');
              } else {
                if (noResults) noResults.classList.add('hidden');
                
                // Show first page of results
                const endIndex = Math.min(questionsPerPage, filteredQuestions.length);
                const questionsToShow = filteredQuestions.slice(0, endIndex);
                
                questionsToShow.forEach((question, index) => {
                  const questionRow = createQuestionRow(question, index);
                  if (container) container.appendChild(questionRow);
                });
                
                currentlyShown = endIndex;
                updatePaginationControls();
              }
              break;
            }
              
            case 'recent5years': {
              // Filter for questions from last 5 years (2020-2024)
              const currentYear = 2025;
              const last5Years: string[] = [];
              
              // Generate year strings: 2024, 2024 Deferred, 2023, 2023 Deferred, ..., 2020, 2020 Deferred
              for (let year = currentYear - 1; year >= currentYear - 5; year--) {
                last5Years.push(String(year));
                last5Years.push(`${year} Deferred`);
              }
              
              console.log('üîç Recent 5 Years filter activated');
              console.log('Years to match:', last5Years);
              
              // Reset dropdown filters
              if (topicFilter) topicFilter.value = '';
              if (difficultyFilter) difficultyFilter.value = '';
              
              // Helper function to extract year from question name/title
              const extractYear = (nm: unknown) => {
                const nameStr = String(nm || '');
                const m = /^([0-9]{4})/.exec(nameStr);
                return m ? m[1] : '';
              };
              
              const recent5YearsQuestions = allQuestions.filter(q => {
                const yearFromName = extractYear(q.name || q.title || '');
                const matches = last5Years.some(y => 
                  yearFromName === y || 
                  yearFromName === y.split(' ')[0] // Match "2024" to "2024 Deferred"
                );
                // Debug: log first few matches/misses
                if (allQuestions.indexOf(q) < 5) {
                  console.log(`Question name: "${q.name || q.title}" - Year: "${yearFromName}" - Matches: ${matches}`);
                }
                return matches;
              });
              
              console.log(`Filtered ${recent5YearsQuestions.length} questions out of ${allQuestions.length}`);
              
              // Sort the filtered questions
              filteredQuestions = sortQuestions(recent5YearsQuestions, currentSort);
              displayedQuestions = filteredQuestions;
              
              // Reset pagination and display
              currentlyShown = 0;
              const container = document.getElementById('questions-container');
              if (container) container.innerHTML = '';
              
              // Display all filtered questions with pagination
              const noResults = document.getElementById('no-results');
              if (filteredQuestions.length === 0 && noResults) {
                noResults.classList.remove('hidden');
              } else {
                if (noResults) noResults.classList.add('hidden');
                
                // Show first page of results
                const endIndex = Math.min(questionsPerPage, filteredQuestions.length);
                const questionsToShow = filteredQuestions.slice(0, endIndex);
                
                questionsToShow.forEach((question, index) => {
                  const questionRow = createQuestionRow(question, index);
                  if (container) container.appendChild(questionRow);
                });
                
                currentlyShown = endIndex;
                updatePaginationControls();
              }
              break;
            }
          }
        });
      });

      // Scroll-to-load functionality (optional enhancement)
      let isLoadingMore = false;
      window.addEventListener('scroll', () => {
        if (isLoadingMore) return;
        
        const { scrollTop, scrollHeight, clientHeight } = document.documentElement;
        const scrollPercentage = (scrollTop + clientHeight) / scrollHeight;
        
        // Trigger load more when 80% scrolled
        if (scrollPercentage > 0.8 && currentlyShown < filteredQuestions.length) {
          isLoadingMore = true;
          loadMoreQuestions();
          setTimeout(() => { isLoadingMore = false; }, 1000);
        }
      });

      // Add cache refresh functionality
      function refreshCache() {
        clearCache();
        console.log('üîÑ Manual cache refresh triggered');
        loadAllQuestions();
      }

      // Add keyboard shortcut to refresh cache (Ctrl+Shift+R)
      document.addEventListener('keydown', (e) => {
        if (e.ctrlKey && e.shiftKey && e.key === 'R') {
          e.preventDefault();
          refreshCache();
        }
      });

      // Optional: Add a refresh button to the UI (you can uncomment this)
      /*
      const refreshBtn = document.createElement('button');
      refreshBtn.textContent = 'üîÑ Refresh Cache';
      refreshBtn.className = 'px-3 py-1 text-sm bg-blue-500 text-white rounded hover:bg-blue-600';
      refreshBtn.onclick = refreshCache;
      document.querySelector('.flex.flex-wrap.gap-4.mb-6')?.appendChild(refreshBtn);
      */

      // Make function available globally for the onclick handler
      (window as Window & typeof globalThis & { toggleQuestionCompleted: typeof toggleQuestionCompleted }).toggleQuestionCompleted = toggleQuestionCompleted;

      // When data ready & filters persisted, reapply filtered view (avoids race where initial display shows all)
      document.addEventListener('questions-data-ready', () => {
        const f = getInitialFilterState();
        if (f.topic || f.difficulty || f.sort !== 'year-desc') {
          const topicFilterEl = document.getElementById('topic-filter') as HTMLSelectElement | null;
            const difficultyFilterEl = document.getElementById('difficulty-filter') as HTMLSelectElement | null;
            const sortFilterEl = document.getElementById('sort-filter') as HTMLSelectElement | null;
            if (topicFilterEl && f.topic) topicFilterEl.value = f.topic;
            if (difficultyFilterEl && f.difficulty) difficultyFilterEl.value = f.difficulty;
            if (sortFilterEl && f.sort) sortFilterEl.value = f.sort;
            displayQuestions(f.topic, f.difficulty, f.sort, true);
        }
      }, { once: true });
    }

    // Event listeners - support both DOMContentLoaded and Astro navigation
    document.addEventListener('DOMContentLoaded', initializePage);
    
    // Support Astro View Transitions - this fires on client-side navigation
    document.addEventListener('astro:page-load', initializePage);
  </script>

  <style>
    #loading-overlay {
      transition: opacity 0.3s ease;
    }

    /* Remove all focus outlines and rings */
    *:focus {
      outline: none !important;
      box-shadow: none !important;
    }

    button:focus,
    select:focus,
    input:focus {
      outline: none !important;
      box-shadow: none !important;
      border-color: inherit !important;
    }

    /* Enhanced hover effects for question rows */
    .question-row-enter:hover {
      background: linear-gradient(135deg, rgba(252, 231, 243, 0.6), rgba(255, 255, 255, 0.8)) !important;
      border-left: 3px solid #ec4899;
      padding-left: 13px; /* Adjust for border */
    }

    /* Dark mode hover effects */
    .dark .question-row-enter:hover {
      background: linear-gradient(135deg, rgba(100, 116, 139, 0.3), rgba(51, 65, 85, 0.8)) !important;
      border-left: 3px solid #f472b6;
    }

    /* Status indicator hover effect */
    .w-3.h-3.rounded-full:hover {
      transform: scale(1.2);
      cursor: pointer;
    }

    /* Smooth transitions for all interactive elements */
    .transition-colors,
    .transition-all {
      transition: all 0.2s ease;
    }

    /* Load More Button Animations */
    #load-more-btn {
      transition: all 0.2s ease;
    }

    #load-more-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
    }

    #load-more-btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }

    /* Bounce animation for the arrow */
    @keyframes bounce-gentle {
      0%, 100% {
        transform: translateY(0);
      }
      50% {
        transform: translateY(-2px);
      }
    }

    .animate-bounce {
      animation: bounce-gentle 1s ease-in-out infinite;
    }

    /* Fade in animation for newly loaded questions */
    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .question-row-enter {
      animation: fadeInUp 0.3s ease-out;
    }

    /* Loading state styling */
    #loading-more {
      animation: fadeInUp 0.2s ease-out;
    }

    /* Topic tags styling to prevent overflow */
    .topic-tag {
      max-width: calc(100% - 4px);
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* Improved grid layout for better space utilization - thinner rows */
    .question-grid {
      min-height: 40px;
      align-items: center;
    }

    /* Title column truncation for better space management */
    .title-column {
      min-width: 0; /* Allows flex shrinking */
    }

    /* Bold special options in topic filter */
    #topic-filter option:first-child,
    #topic-filter option[value='__paper1'],
    #topic-filter option[value='__paper2'] { font-weight:600; }

    /* Quick Filter Pills Styling */
    .quick-filter-pill {
      cursor: pointer;
      user-select: none;
      border: 1px solid transparent;
    }

    .quick-filter-pill:active {
      transform: scale(0.98);
    }

    .quick-filter-pill.active {
      border-color: rgb(59 130 246 / 0.3);
      box-shadow: 0 1px 3px 0 rgb(59 130 246 / 0.1), 0 1px 2px -1px rgb(59 130 246 / 0.1);
    }

    /* Bundle cards hover effect */
    .bg-white.rounded-lg.shadow-md:hover,
    .dark .dark\\:bg-slate-800.rounded-lg.shadow-md:hover {
      transform: translateY(-2px);
      transition: all 0.3s ease;
    }
  </style>
</Layout>
