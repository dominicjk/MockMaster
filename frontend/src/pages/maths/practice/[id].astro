---
// src/pages/maths/practice/[id].astro
import Layout from '~/layouts/PageLayout.astro';

export function getStaticPaths() {
  const ids = [
    'number','algebra','complex-numbers','sequences-and-series','financial-maths','induction',
    'functions','differentiation','integration','the-line','the-circle','geometry','trigonometry',
    'probability','statistics',
  ];
  return ids.map((id) => ({ params: { id } }));
}

const { id } = Astro.params;
const metadata = { title: `Practice - ${id}` };
---

<Layout metadata={metadata}>
  <!-- Main Content Container -->
  <div class="min-h-screen pb-24" style="margin-top: 10px;">
    <div class="p-6">
      <div class="flex gap-6">
        <!-- Fixed Left Sidebar -->
        <div id="sidebar" class="fixed w-80 bg-white dark:bg-slate-800 border border-gray-200 dark:border-slate-700 rounded-xl shadow-lg z-10 overflow-hidden" style="top: 135px; left: 24px; height: calc(100vh - 130px);">
          <!-- Top Toggle Tabs (true top slice of sidebar) -->
          <div class="w-full rounded-t-lg overflow-hidden mb-2" style="background: #e5e7eb;">
            <div class="flex flex-row w-full">
              <button id="tab-question" class="flex-1 py-2 text-center font-semibold text-gray-700 bg-white hover:bg-gray-300 border-r border-gray-300 transition" style="outline:none;">Question</button>
              <button id="tab-solution" class="flex-1 py-2 text-center font-semibold text-gray-700 bg-gray-100 hover:bg-gray-300 transition" style="outline:none;">Solution</button>
            </div>
          </div>
          <div class="p-6 h-full">
        <!-- Question Name Display -->
        <div class="mb-3">
          <div id="question-year" class="text-lg font-semibold text-gray-800 dark:text-gray-200 text-left">--</div>
        </div>
        
        <!-- Favorite Star -->
        <div class="flex items-center justify-between mb-3">
          <!-- Star (favourite) icon on the left -->
          <button id="sidebar-favourite" class="p-2 rounded-xl hover:bg-yellow-100 dark:hover:bg-yellow-900 mr-2" title="Add to Favourites" style="display: block;" >
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
            </svg>
          </button>
          <!-- Zoom controls on the right -->
          <div class="flex items-center gap-1 bg-gray-100 dark:bg-slate-700 rounded px-1 py-1 shadow text-xs ml-auto">
            <button id="zoom-out" class="px-0.5 py-0.5 text-base font-bold rounded hover:bg-gray-200 dark:hover:bg-slate-600" title="Zoom Out" style="min-width:1.5em;">-</button>
            <span id="zoom-level" class="w-8 text-center">100%</span>
            <button id="zoom-in" class="px-0.5 py-0.5 text-base font-bold rounded hover:bg-gray-200 dark:hover:bg-slate-600" title="Zoom In" style="min-width:1.5em;">+</button>
          </div>
        </div>
      <!-- LeetCode-style Options Panel with Top Toggle Slice -->
      <div class="mb-8 sidebar-content">
        <div class="bg-gray-50 dark:bg-slate-700 rounded-b-lg p-4 flex flex-col gap-4">
          <!-- Timer Section -->
          <div class="flex flex-row items-center gap-3">
            <div class="text-xl font-mono font-bold bg-gray-200 dark:bg-slate-600 px-3 py-2 rounded-lg" id="sidebar-timer">00:00</div>
            <button id="timer-start" class="p-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors" title="Start Timer">
              <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24">
                <path d="M8 5v14l11-7z"/>
              </svg>
            </button>
            <button id="timer-reset" class="p-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition-colors" title="Reset Timer">
              <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24">
                <path d="M4 12a8 8 0 0 1 8-8V2.5L14.5 5 12 7.5V6a6 6 0 1 0-6 6H4z"/>
              </svg>
            </button>
          </div>
          <!-- Similar Questions Panel -->
          <div class="border-t border-gray-200 dark:border-slate-600 pt-3">
            <button class="w-full flex items-center justify-between text-sm font-semibold text-gray-700 dark:text-gray-200 py-2 hover:bg-gray-100 dark:hover:bg-slate-800 rounded transition" type="button" onclick="this.nextElementSibling.classList.toggle('hidden')">
              <span><svg class="w-4 h-4 inline mr-1 text-gray-400" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M17 17v-6a2 2 0 0 0-2-2H9a2 2 0 0 0-2 2v6"/></svg>Similar Questions</span>
              <svg class="w-3 h-3 ml-2" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M19 9l-7 7-7-7"/></svg>
            </button>
            <div class="hidden pl-5 pt-2 text-xs text-gray-600 dark:text-gray-300">
              <!-- Example similar questions -->
              <div class="mb-1">• How to solve quadratic equations?</div>
              <div class="mb-1">• What is the binomial theorem?</div>
              <div>• Integration by parts explained</div>
            </div>
          </div>
        </div>
      </div>

      <!-- Question Metadata -->
      <div class="mb-8 sidebar-content">
        <div class="space-y-3 text-sm">
          <div class="flex justify-between items-center">
            <span id="meta-topic" class="font-medium flex items-center"></span>
          </div>
        </div>
      </div>

      <!-- Navigation -->
      <div class="mb-6 sidebar-content">
        <div class="flex gap-2 mb-4">
          <button id="prev-question" class="flex-1 px-4 py-2 bg-white text-gray-700 border border-gray-300 rounded-xl hover:bg-gray-50 flex items-center justify-center" title="Previous Question">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
            </svg>
          </button>
          <button id="next-question" class="flex-1 px-4 py-2 bg-white text-gray-700 border border-gray-300 rounded-xl hover:bg-gray-50 flex items-center justify-center" title="Next Question">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
            </svg>
          </button>
        </div>
        <button id="skip-question" class="w-full px-4 py-2 bg-yellow-500 text-white rounded-xl hover:bg-yellow-600">
          Skip Question
        </button>
      </div>

      <!-- Report Section -->
      <div class="sidebar-content">
        <button id="report-question" class="w-full p-3 rounded-lg bg-transparent text-gray-400 hover:text-red-500 hover:bg-red-50 dark:hover:bg-red-900/20 transition-colors flex items-center justify-center gap-2" title="Report Question">
          <svg class="w-5 h-5" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
            <path d="M12 9v2m0 4h.01M21 12c0 4.97-4.03 9-9 9s-9-4.03-9-9 4.03-9 9-9 9 4.03 9 9z"/>
          </svg>
          <span class="text-sm">Report Question</span>
        </button>
      </div>
        </div>
      </div>

        <!-- Question Panel -->
        <div id="question-panel" class="flex-1 transition-all duration-300" style="margin-left: 20rem;">
      <!-- Question Container -->
      <div id="question-container" class="border-2 border-gray-300 dark:border-slate-600 rounded-lg overflow-hidden">
        <div class="flex items-center justify-center h-96 text-gray-500 bg-white dark:bg-slate-900">
          Loading question...
        </div>
      </div>

      <!-- Solution Container (Hidden initially) -->
      <div id="solution-container" class="mt-6" style="display: none;">
        <h3 class="text-lg font-semibold mb-3">Solution</h3>
        <div id="solution-content" class="border-2 border-gray-300 dark:border-slate-600 rounded-lg overflow-hidden">
          <!-- Solution will be loaded here -->
        </div>
      </div>
    </div>
  </div>



  <script>
    interface PracticeQuestion {
      id?: string;
      topic?: string;
      subject?: string;
      difficulty?: string | number;
      timeLimitMinute?: number;
      timeLimit?: number;
      tags?: string[];
      questionImageUrl?: string;
      questionImagePath?: string;
      solutionImageUrl?: string;
      solutionImagePath?: string;
      image?: string;
      name?: string;
      // Accept any extra fields (for solutionTifUrl, etc)
      [key: string]: any;
    }

    // Rectangle type for highlights
    type HighlightRect = { x: number, y: number, w: number, h: number };
    let highlightRects: HighlightRect[] = [];
    let questionHistory: Array<{
      question: PracticeQuestion,
      timerSeconds: number,
      zoomLevel: number,
      highlightRects: HighlightRect[],
      showingSolution: boolean
    }> = [];


    let currentQuestion: PracticeQuestion | null = null; // Holds the currently loaded question object from the API
    let timerSeconds = 0;
    let timerInterval: ReturnType<typeof setInterval> | null = null;
    let showingSolution = false;
    let questionCounter = 1; // Global counter starting from 1

    // State history for each question
  // (Removed duplicate declaration of questionHistory)

    // Timer functions
    function startTimer() {
      if (!timerInterval) {
        timerInterval = setInterval(() => {
          timerSeconds++;
          updateTimerDisplay();

        }, 1000);
        updateTimerButtons(true);
      }
    }

    function pauseTimer() {
      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
        updateTimerButtons(false);
      }
    }

    function resetTimer() {
      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }
      timerSeconds = 0;
      updateTimerDisplay();
      updateTimerButtons(false);
    }

    function updateTimerDisplay() {
      const minutes = Math.floor(timerSeconds / 60);
      const seconds = timerSeconds % 60;
      const display = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      const el = document.getElementById('sidebar-timer');
      if (el) el.textContent = display;
    }

    function updateTimerButtons(isRunning) {
      const startButton = document.getElementById('timer-start');
      if (startButton) {
        if (isRunning) {
          startButton.innerHTML = `
            <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24">
              <path d="M6 4h4v16H6V4zm8 0h4v16h-4V4z"/>
            </svg>
          `;
          startButton.title = 'Pause Timer';
          startButton.className = 'p-2 bg-yellow-500 text-white rounded-lg hover:bg-yellow-600 transition-colors';
        } else {
          startButton.innerHTML = `
            <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24">
              <path d="M8 5v14l11-7z"/>
            </svg>
          `;
          startButton.title = 'Start Timer';
          startButton.className = 'p-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors';
        }
      }
    }

    // Question loading and display

    async function loadQuestion({fromHistory = false, historyIndex = null} = {}) {
      if (fromHistory && historyIndex !== null && questionHistory[historyIndex]) {
        // Restore from history
        const state = questionHistory[historyIndex];
        currentQuestion = state.question;
        timerSeconds = state.timerSeconds;
        zoomLevel = state.zoomLevel;
        highlightRects = JSON.parse(JSON.stringify(state.highlightRects || []));
        showingSolution = state.showingSolution;
        updateTimerDisplay();
        updateTimerButtons(false);
        if (showingSolution) {
          displaySolution();
        } else {
          displayQuestion(currentQuestion);
        }
        updateMetadata(currentQuestion);
        updateQuestionTitle();
        updateTabAppearance();
        drawHighlights();
        return;
      }
      try {
        // Use the topic from the Astro.params id
        const topic = window.location.pathname.split('/').pop();
        const response = await fetch('http://localhost:3001/api/topics/questions', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ topics: [topic] })
        });

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        const result = await response.json();
        if (!result.matchingQuestions || result.matchingQuestions.length === 0) {
          const qc = document.getElementById('question-container');
          if (qc) qc.innerHTML = '<div class="flex items-center justify-center h-full text-gray-500">No question found for this topic.</div>';
          return;
        }

        // Pick a random question from the matches
        const data = result.matchingQuestions[Math.floor(Math.random() * result.matchingQuestions.length)];
        currentQuestion = data;

        // Reset solution state
        showingSolution = false;
        const button = document.getElementById('show-solution');
        if (button) {
          button.textContent = 'Show Solution';
        }

        // Save state to history
        questionHistory = questionHistory.slice(0, questionCounter - 1); // Truncate forward history if any
        questionHistory.push({
          question: currentQuestion,
          timerSeconds,
          zoomLevel,
          highlightRects: JSON.parse(JSON.stringify(highlightRects)),
          showingSolution
        });

        displayQuestion(data);
        updateMetadata(data);
        updateTabAppearance();

      } catch (error) {
        console.error('Error loading question:', error);
        const qc = document.getElementById('question-container');
        if (qc) qc.innerHTML = '<div class="flex items-center justify-center h-full text-red-500">Error loading question</div>';
      }
    }

    let zoomLevel = 1.0;
    function displayQuestion(question) {
      const container = document.getElementById('question-container');
      if (!container) return;
      if (!question) {
        container.innerHTML = '<div class="flex items-center justify-center h-full text-red-500">No question data</div>';
        return;
      }
      // Support legacy and new API fields for image path
      const rawUrl = question.questionTifUrl || question.questionImageUrl || question.questionImagePath || question.tifUrl || question.image || '';
      if (rawUrl) {
        const imageUrl = rawUrl.startsWith('http') ? rawUrl : `http://localhost:3001${rawUrl}`;
        container.innerHTML = `
      <div class="flex justify-center items-start h-full">
        <img id="question-img" src="${imageUrl}" 
          alt="Question Image" 
          class="w-full max-w-[700px] h-auto"
          style="width: 100%; max-width: 1000px; height: auto; transform: scale(${zoomLevel}); transform-origin: top center; transition: transform 0.2s; display: block; margin-top: 0;"
          loading="lazy"
          crossorigin="anonymous"
          onerror="this.closest('div').innerHTML='Failed to load question image';">
      </div>
    `;
    updateZoomDisplay();
    // Scroll 10% down by default
    setTimeout(() => {
      container.scrollTop = container.scrollHeight * 0.1;
    }, 0);
      } else {
        container.innerHTML = '<div class="flex items-center justify-center h-full text-gray-500">No question image available</div>';
      }
    }

    function updateZoomDisplay() {
      const zoomDisplay = document.getElementById('zoom-level');
      if (zoomDisplay) zoomDisplay.textContent = Math.round(zoomLevel * 100) + '%';
      const img = document.getElementById('question-img');
      if (img) img.style.transform = `scale(${zoomLevel})`;
    }

    // Dictionary mapping topic to mini-icon filename (without extension)
    const topicMiniIcons = {
      'number': 'number-mini-icon',
      'algebra': 'algebra-mini-icon',
      'complex-numbers': 'complex-numbers-mini-icon',
      'sequences-and-series': 'sequences-and-series-mini-icon',
      'financial-maths': 'financial-mathematics-mini-icon',
      'induction': 'induction-mini-icon',
      'functions': 'functions-mini-icon',
      'differentiation': 'differentiation-mini-icon',
      'integration': 'integration-mini-icon',
      'the-line': 'the-line-mini-icon',
      'the-circle': 'the-circle-mini-icon',
      'geometry': 'geometry-mini-icon',
      'trigonometry': 'trigonometry-mini-icon',
      'probability': 'probability-mini-icon',
      'statistics': 'statistics-mini-icon',
    };

    function updateMetadata(question) {
      // Debug: log the question object to see available fields
      console.log('Question data:', question);
      console.log('Available fields:', Object.keys(question));
      
      // Update year display
      const yearEl = document.getElementById('question-year');
      if (yearEl) {
        const name = question.name || question.Name || question.title || question.Title || '--';
        console.log('Name field value:', name);
        yearEl.textContent = name;
      }
      
      // Only update elements that actually exist in the markup
      const topicEl = document.getElementById('meta-topic');
      const diffEl = document.getElementById('meta-difficulty');
      const timeEl = document.getElementById('meta-time-limit');
      // API returns: id, topic, difficulty, timeLimitMinute, tags
      if (topicEl) {
        // Clear previous content
        topicEl.innerHTML = '';
        let topics = question.topic || question.subject || '--';
        // If topics is a string, make it an array for uniform handling
        if (typeof topics === 'string') {
          topics = [topics];
        }
        if (Array.isArray(topics)) {
          let foundIcon = false;
          topics.forEach(topic => {
            if (topicMiniIcons[topic]) {
              const iconPath = `/mini-icons/${topicMiniIcons[topic]}.svg`;
              const img = document.createElement('img');
              img.src = iconPath;
              img.alt = topic;
              img.title = topic;
              img.style.width = '2.5em';
              img.style.height = '2.5em';
              img.style.display = 'inline';
              img.style.verticalAlign = 'middle';
              img.style.marginRight = '0.25em';
              topicEl.appendChild(img);
              foundIcon = true;
            }
          });
          // If no icons found, fallback to showing the topic(s) as text
          if (!foundIcon) {
            topicEl.textContent = topics.join(', ');
          }
        } else {
          // fallback for unexpected types
          topicEl.textContent = String(topics);
        }
      }
      if (diffEl) diffEl.textContent = (question.difficulty != null ? question.difficulty : '--');
      const limit = question.timeLimitMinute || question.timeLimit;
      if (timeEl) timeEl.textContent = limit ? `${limit} min` : '--';
    }

    function updateQuestionTitle() {
      const titleElement = document.getElementById('question-title');
      if (titleElement) {
        titleElement.textContent = `Question ${questionCounter}`;
      }
    }


    function nextQuestion() {
      // Save current state before moving forward
      if (currentQuestion) {
        if (questionHistory.length < questionCounter) {
          questionHistory.push({
            question: currentQuestion,
            timerSeconds,
            zoomLevel,
            highlightRects: JSON.parse(JSON.stringify(highlightRects)),
            showingSolution
          });
        } else {
          questionHistory[questionCounter - 1] = {
            question: currentQuestion,
            timerSeconds,
            zoomLevel,
            highlightRects: JSON.parse(JSON.stringify(highlightRects)),
            showingSolution
          };
        }
      }
      questionCounter++;
      updateQuestionTitle();
      // Reset solution state
      showingSolution = false;
      const button = document.getElementById('show-solution');
      if (button) {
        button.textContent = 'Show Solution';
      }
      // Load a new question
      loadQuestion();
    }


    function skipQuestion() {
      // Save current state before skipping
      if (currentQuestion) {
        if (questionHistory.length < questionCounter) {
          questionHistory.push({
            question: currentQuestion,
            timerSeconds,
            zoomLevel,
            highlightRects: JSON.parse(JSON.stringify(highlightRects)),
            showingSolution
          });
        } else {
          questionHistory[questionCounter - 1] = {
            question: currentQuestion,
            timerSeconds,
            zoomLevel,
            highlightRects: JSON.parse(JSON.stringify(highlightRects)),
            showingSolution
          };
        }
      }
      questionCounter++;
      updateQuestionTitle();
      // Reset solution state
      showingSolution = false;
      const button = document.getElementById('show-solution');
      if (button) {
        button.textContent = 'Show Solution';
      }
      const statusMsg = document.getElementById('status-message');
      if (statusMsg) {
        statusMsg.innerHTML = '<span class="text-yellow-600 font-medium">Question skipped</span>';
      }
      // Load a new question
      loadQuestion();
    }

    function prevQuestion() {
      if (questionCounter <= 1) return;
      // Save current state before moving back
      if (currentQuestion) {
        questionHistory[questionCounter - 1] = {
          question: currentQuestion,
          timerSeconds,
          zoomLevel,
          highlightRects: JSON.parse(JSON.stringify(highlightRects)),
          showingSolution
        };
      }
      questionCounter--;
      updateQuestionTitle();
      // Restore previous state ONLY from history
      const idx = questionCounter - 1;
      if (questionHistory[idx]) {
        const state = questionHistory[idx];
        currentQuestion = state.question;
        timerSeconds = state.timerSeconds;
        zoomLevel = state.zoomLevel;
        highlightRects = JSON.parse(JSON.stringify(state.highlightRects || []));
        showingSolution = state.showingSolution;
        updateTimerDisplay();
        updateTimerButtons(false);
        if (showingSolution) {
          displaySolution();
        } else {
          displayQuestion(currentQuestion);
          // Scroll 10% down by default when restoring
          const container = document.getElementById('question-container');
          if (container) setTimeout(() => { container.scrollTop = container.scrollHeight * 0.1; }, 0);
        }
        updateMetadata(currentQuestion);
        updateQuestionTitle();
        drawHighlights();
      }
      // If no history, do nothing (do not generate a new question)
    }

  function displaySolution() {
    const container = document.getElementById('question-container');
    if (!container || !currentQuestion) return;
    // Accept solutionImageUrl, solutionImagePath, or solutionTifUrl (if present)
    const rawSolutionUrl = currentQuestion.solutionTifUrl || currentQuestion.solutionImageUrl || currentQuestion.solutionImagePath;
    if (rawSolutionUrl) {
      const imageUrl = rawSolutionUrl.startsWith('http') ? rawSolutionUrl : `http://localhost:3001${rawSolutionUrl}`;
      container.innerHTML = `
        <div class="flex justify-center" style="position: relative;">
          <img id="solution-img" src="${imageUrl}" 
               alt="Solution Image" 
               class="max-w-full h-auto rounded"
               style="transform: scale(${zoomLevel}); transform-origin: top center; transition: transform 0.2s; display: block; margin-top: 0;"
               loading="lazy"
               crossorigin="anonymous"
               onerror="this.closest('div').innerHTML='Failed to load solution image';">
          <canvas id="highlight-canvas" style="position: absolute; left: 0; top: 0; pointer-events: none;"></canvas>
        </div>
      `;
      updateZoomDisplay();
      setTimeout(setupHighlighter, 100);
    } else {
      container.innerHTML = '<div class="flex items-center justify-center h-full text-gray-500">No solution available</div>';
    }
  }

  function drawHighlights() {
    const img = document.getElementById('question-img') || document.getElementById('solution-img');
    const canvas = document.getElementById('highlight-canvas') as HTMLCanvasElement | null;
    if (!img || !canvas) return;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    highlightRects.forEach(rect => drawRect(rect, 'rgba(255,255,0,0.3)'));
  }

  function drawRect(rect: HighlightRect, color: string) {
    const canvas = document.getElementById('highlight-canvas') as HTMLCanvasElement | null;
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;
    ctx.save();
    ctx.strokeStyle = 'rgba(255,215,0,0.8)';
    ctx.lineWidth = 2;
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.rect(rect.x, rect.y, rect.w, rect.h);
    ctx.fill();
    ctx.stroke();
    ctx.restore();
  }

  function setupHighlighter() {
    // Dummy function for now, implement as needed for highlight interaction
    // This should set up mouse events for drawing highlights
  }

  function toggleSolution() {
    if (!currentQuestion) return;
    const button = document.getElementById('show-solution');
    const statusMsg = document.getElementById('status-message');
    if (!button) return;
    if (!showingSolution) {
      displaySolution();
      button.textContent = 'Show Question';
      if (statusMsg) statusMsg.innerHTML = '<span class="text-blue-600 font-medium">Solution displayed</span>';
      showingSolution = true;
    } else {
      displayQuestion(currentQuestion);
      button.textContent = 'Show Solution';
      if (statusMsg) statusMsg.innerHTML = '<span class="text-gray-600 font-medium">Question displayed</span>';
      showingSolution = false;
    }
    updateTabAppearance();
  }

  function updateTabAppearance() {
    const questionTab = document.getElementById('tab-question');
    const solutionTab = document.getElementById('tab-solution');
    
    if (questionTab && solutionTab) {
      if (showingSolution) {
        // Solution tab is active (white background)
        questionTab.className = 'flex-1 py-2 text-center font-semibold text-gray-700 bg-gray-100 hover:bg-gray-300 border-r border-gray-300 transition';
        solutionTab.className = 'flex-1 py-2 text-center font-semibold text-gray-700 bg-white hover:bg-gray-300 transition';
      } else {
        // Question tab is active (white background)
        questionTab.className = 'flex-1 py-2 text-center font-semibold text-gray-700 bg-white hover:bg-gray-300 border-r border-gray-300 transition';
        solutionTab.className = 'flex-1 py-2 text-center font-semibold text-gray-700 bg-gray-100 hover:bg-gray-300 transition';
      }
    }
  }

    // Event listeners
  document.addEventListener('DOMContentLoaded', () => {
      // Zoom controls
      const zoomInBtn = document.getElementById('zoom-in');
      const zoomOutBtn = document.getElementById('zoom-out');
      if (zoomInBtn) zoomInBtn.addEventListener('click', () => {
        zoomLevel = Math.min(zoomLevel + 0.1, 3.0);
        updateZoomDisplay();
      });
      if (zoomOutBtn) zoomOutBtn.addEventListener('click', () => {
        zoomLevel = Math.max(zoomLevel - 0.1, 0.2);
        updateZoomDisplay();
      });
      // Update initial question title
      updateQuestionTitle();
      
      // Load question
      loadQuestion();
      
      // Initialize tab appearance
      updateTabAppearance();
      
      // Timer controls
      const startBtn = document.getElementById('timer-start');
      if (startBtn) {
        startBtn.addEventListener('click', () => {
          if (timerInterval) {
            pauseTimer();
          } else {
            startTimer();
          }
        });
      }
      const resetBtn = document.getElementById('timer-reset');
      if (resetBtn) resetBtn.addEventListener('click', resetTimer);

      // Favourite (star) button
      const favBtn = document.getElementById('sidebar-favourite');
      if (favBtn) favBtn.addEventListener('click', () => {
        // TODO: Implement add/remove favourite logic here
        favBtn.classList.toggle('text-yellow-400');
        favBtn.classList.toggle('fill-yellow-400');
      });

      // Tab switching
      const questionTab = document.getElementById('tab-question');
      const solutionTab = document.getElementById('tab-solution');
      
      if (questionTab) {
        questionTab.addEventListener('click', () => {
          if (showingSolution && currentQuestion) {
            displayQuestion(currentQuestion);
            showingSolution = false;
            updateTabAppearance();
          }
        });
      }
      
      if (solutionTab) {
        solutionTab.addEventListener('click', () => {
          if (!showingSolution && currentQuestion) {
            displaySolution();
            showingSolution = true;
            updateTabAppearance();
          }
        });
      }

      // Action buttons
      const solutionBtn = document.getElementById('show-solution');
      if (solutionBtn) solutionBtn.addEventListener('click', toggleSolution);

      // Navigation buttons
      const nextBtn = document.getElementById('next-question');
      if (nextBtn) nextBtn.addEventListener('click', nextQuestion);
      const skipBtn = document.getElementById('skip-question');
      if (skipBtn) skipBtn.addEventListener('click', skipQuestion);
      const prevBtn = document.getElementById('prev-question');
      if (prevBtn) prevBtn.addEventListener('click', prevQuestion);
    });
  </script>

  <style>
    #sidebar {
      width: 20rem; /* w-80 */
    }

    #question-panel {
      transition: margin-left 0.3s ease;
    }

    /* Responsive behavior for smaller screens */
    @media (max-width: 1280px) {
      #sidebar {
        width: 18rem;
      }
      #question-panel {
        margin-left: 18rem !important;
      }
    }

    @media (max-width: 1024px) {
      #sidebar {
        width: 16rem;
      }
      #question-panel {
        margin-left: 16rem !important;
      }
    }
  </style>
</Layout>
