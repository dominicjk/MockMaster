---
// src/pages/maths/practice/[id].astro
import Layout from '~/layouts/PageLayout.astro';
import { formatTopicName, formatDifficulty } from '~/utils/question-formatting';

export function getStaticPaths() {
  const ids = [
    'number','algebra','complex-numbers','sequences-and-series','financial-maths','induction',
    'functions','differentiation','integration','the-line','the-circle','geometry','trigonometry',
    'probability','statistics',
  ];
  return ids.map((id) => ({ params: { id } }));
}

const { id } = Astro.params;
const metadata = { title: `Practice - ${id}` };
---

<Layout metadata={metadata}>
  <!-- Loading Screen Overlay -->
  <div id="loading-overlay" class="fixed inset-0 bg-white dark:bg-slate-900 z-50 flex items-center justify-center">
    <div class="text-center">
      <div class="inline-block animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mb-4"></div>
      <h2 class="text-xl font-semibold text-gray-800 dark:text-gray-200 mb-2">Loading Practice Session</h2>
      <p class="text-gray-600 dark:text-gray-400" id="loading-message">Preparing your questions...</p>
    </div>
  </div>

  <!-- Save Attempt Modal -->
  <div id="save-attempt-modal" class="fixed inset-0 bg-black bg-opacity-50 backdrop-blur-sm z-50 flex items-center justify-center hidden">
    <div class="bg-white dark:bg-slate-800 rounded-xl p-6 max-w-md w-full mx-4 shadow-xl">
      <h3 class="text-lg font-semibold text-gray-800 dark:text-gray-200 mb-4">Save Your Attempt</h3>
      
      <!-- Question Title Display -->
      <div class="mb-4">
        <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Question:</label>
        <div id="modal-question-title" class="p-3 bg-gray-50 dark:bg-slate-700 rounded-lg text-gray-800 dark:text-gray-200">
          --
        </div>
      </div>
      
      <!-- Time Display -->
      <div class="mb-4">
        <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Time Taken:</label>
        <div id="modal-time-taken" class="p-3 bg-gray-50 dark:bg-slate-700 rounded-lg font-mono text-gray-800 dark:text-gray-200">
          00:00
        </div>
      </div>
      
      <!-- Notes Input -->
      <div class="mb-6">
        <label for="attempt-notes" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Notes:</label>
        <textarea 
          id="attempt-notes" 
          rows="4" 
          class="w-full p-3 border border-gray-300 dark:border-slate-600 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 dark:bg-slate-700 dark:text-gray-200 resize-none"
          placeholder="Add your notes about this question attempt..."
        ></textarea>
      </div>
      
      <!-- Modal Actions -->
      <div class="flex gap-3">
        <button id="cancel-save-attempt" class="flex-1 px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 dark:bg-slate-600 dark:text-gray-200 dark:hover:bg-slate-500">
          Cancel
        </button>
        <button id="confirm-save-attempt" class="flex-1 px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 dark:bg-blue-600 dark:hover:bg-blue-700">
          Save Attempt
        </button>
      </div>
    </div>
  </div>

  <!-- Report Question Modal -->
  <div id="report-question-modal" class="fixed inset-0 bg-black bg-opacity-50 backdrop-blur-sm z-50 flex items-center justify-center hidden">
    <div class="bg-white dark:bg-slate-800 rounded-xl p-6 max-w-md w-full mx-4 shadow-xl">
      <h3 class="text-lg font-semibold text-gray-800 dark:text-gray-200 mb-4">Report Question</h3>
      
      <!-- Question Title Display -->
      <div class="mb-4">
        <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Question:</label>
        <div id="report-question-title" class="p-3 bg-gray-50 dark:bg-slate-700 rounded-lg text-gray-800 dark:text-gray-200">
          --
        </div>
      </div>
      
      <!-- Report Reason Selection -->
      <div class="mb-4">
        <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-3">Select issue:</label>
        <div class="space-y-2">
          <button class="report-reason-btn w-full p-3 text-left border border-gray-300 dark:border-slate-600 rounded-lg hover:bg-gray-50 dark:hover:bg-slate-700 transition-colors" data-reason="Question too blurry">
            Question too blurry
          </button>
          <button class="report-reason-btn w-full p-3 text-left border border-gray-300 dark:border-slate-600 rounded-lg hover:bg-gray-50 dark:hover:bg-slate-700 transition-colors" data-reason="Question too hard">
            Question too hard
          </button>
          <button class="report-reason-btn w-full p-3 text-left border border-gray-300 dark:border-slate-600 rounded-lg hover:bg-gray-50 dark:hover:bg-slate-700 transition-colors" data-reason="Incorrect solution">
            Incorrect solution
          </button>
          <button class="report-reason-btn w-full p-3 text-left border border-gray-300 dark:border-slate-600 rounded-lg hover:bg-gray-50 dark:hover:bg-slate-700 transition-colors" data-reason="Other">
            Other
          </button>
        </div>
      </div>
      
      <!-- Custom Description (Hidden initially) -->
      <div id="custom-description-section" class="mb-4 hidden">
        <label for="custom-description" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Please describe the issue:</label>
        <textarea 
          id="custom-description" 
          rows="3" 
          class="w-full p-3 border border-gray-300 dark:border-slate-600 rounded-lg focus:ring-2 focus:ring-red-500 focus:border-red-500 dark:bg-slate-700 dark:text-gray-200 resize-none"
          placeholder="Please describe what's wrong with this question..."
        ></textarea>
      </div>
      
      <!-- Selected Reason Display -->
      <div id="selected-reason-section" class="mb-4 hidden">
        <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Issue:</label>
        <div id="selected-reason" class="p-3 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-700 rounded-lg text-red-700 dark:text-red-300">
          --
        </div>
      </div>
      
      <!-- Modal Actions -->
      <div class="flex gap-3">
        <button id="cancel-report" class="flex-1 px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 dark:bg-slate-600 dark:text-gray-200 dark:hover:bg-slate-500">
          Cancel
        </button>
        <button id="submit-report" class="flex-1 px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600 dark:bg-red-600 dark:hover:bg-red-700 disabled:opacity-50 disabled:cursor-not-allowed" disabled>
          Submit Report
        </button>
      </div>
    </div>
  </div>

  <!-- Main Content Container -->
  <div class="min-h-screen pb-24" style="margin-top: 10px;">
    <div class="p-6">
      <div class="flex gap-6 justify-center max-w-7xl mx-auto">
        <!-- Options Panel -->
        <div id="sidebar" class="w-80 bg-white dark:bg-slate-800 border border-gray-200 dark:border-slate-700 rounded-xl shadow-lg overflow-hidden sticky" style="top: calc(var(--navbar-height, 120px) + 1rem); height: calc(100vh - var(--navbar-height, 120px) - 2rem);">
          <!-- Top Toggle Tabs (true top slice of sidebar) -->
          <div class="w-full rounded-t-lg overflow-hidden mb-2" style="background: #e5e7eb;">
            <div class="flex flex-row w-full">
              <button id="tab-question" class="flex-1 py-2 text-center font-semibold text-gray-700 bg-white hover:bg-gray-300 border-r border-gray-300 transition" style="outline:none;">Question</button>
              <button id="tab-solution" class="flex-1 py-2 text-center font-semibold text-gray-700 bg-gray-100 hover:bg-gray-300 transition" style="outline:none;">Solution</button>
            </div>
          </div>
          <div class="p-6 h-full">
        <!-- Question Name Display -->
        <div class="mb-3">
          <div id="question-year" class="text-lg font-semibold text-gray-800 dark:text-gray-200 text-left">--</div>
        </div>
        
        <!-- Favorite Star -->
        <div class="flex items-center justify-between mb-3">
          <!-- Star (favourite) icon on the left -->
          <button id="sidebar-favourite" class="p-2 rounded-xl hover:bg-yellow-100 dark:hover:bg-yellow-900 mr-2" title="Add to Favourites" style="display: block;" >
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
            </svg>
          </button>
          <!-- Zoom controls on the right -->
          <div class="flex items-center gap-1 bg-gray-100 dark:bg-slate-700 rounded px-1 py-1 shadow text-xs ml-auto">
            <button id="zoom-out" class="px-0.5 py-0.5 text-base font-bold rounded hover:bg-gray-200 dark:hover:bg-slate-600" title="Zoom Out" style="min-width:1.5em;">-</button>
            <span id="zoom-level" class="w-8 text-center">100%</span>
            <button id="zoom-in" class="px-0.5 py-0.5 text-base font-bold rounded hover:bg-gray-200 dark:hover:bg-slate-600" title="Zoom In" style="min-width:1.5em;">+</button>
          </div>
        </div>
      <!-- LeetCode-style Options Panel with Top Toggle Slice -->
      <div class="mb-8 sidebar-content">
        <div class="bg-gray-50 dark:bg-slate-700 rounded-b-lg p-4 flex flex-col gap-4">
          <!-- Timer Section -->
          <div class="flex flex-row items-center gap-3">
            <div class="text-xl font-mono font-bold bg-gray-200 dark:bg-slate-600 px-3 py-2 rounded-lg" id="sidebar-timer">00:00</div>
            <button id="timer-start" class="p-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors" title="Start Timer">
              <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24">
                <path d="M8 5v14l11-7z"/>
              </svg>
            </button>
            <button id="timer-reset" class="p-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition-colors" title="Reset Timer">
              <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24">
                <path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/>
              </svg>
            </button>
          </div>
        </div>
      </div>

      <!-- Question Metadata -->
      <div class="mb-8 sidebar-content">
        <div class="space-y-3">
          <div class="w-full">
            <div id="meta-topic" class="font-medium text-base flex flex-wrap items-start gap-1"></div>
          </div>
          <div class="w-full">
            <div class="flex items-center gap-2">
              <span id="meta-difficulty" class="inline-flex items-center px-2 py-0.5 rounded-full text-sm font-medium bg-blue-100 text-blue-700 dark:bg-blue-900 dark:text-blue-300">--</span>
            </div>
          </div>
        </div>
      </div>

      <!-- Navigation -->
      <div class="mb-6 sidebar-content">
        <div class="flex gap-2 mb-4">
          <button id="prev-question" class="flex-1 px-4 py-2 bg-white text-gray-700 border border-gray-300 rounded-xl hover:bg-gray-50 flex items-center justify-center" title="Previous Question">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
            </svg>
          </button>
          <button id="next-question" class="flex-1 px-4 py-2 bg-white text-gray-700 border border-gray-300 rounded-xl hover:bg-gray-50 flex items-center justify-center" title="Next Question">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
            </svg>
          </button>
        </div>
        <button id="skip-question" class="w-full px-4 py-2 bg-gray-200 text-gray-700 rounded-xl hover:bg-gray-300 dark:bg-gray-600 dark:text-gray-200 dark:hover:bg-gray-500">
          Skip Question
        </button>
        <button id="save-attempt" class="w-full px-4 py-2 mt-2 bg-gray-500 text-white rounded-xl hover:bg-gray-600 dark:bg-gray-600 dark:hover:bg-gray-700">
          Save Attempt
        </button>
      </div>

      <!-- Report Section -->
      <div class="sidebar-content">
        <button id="report-question" class="w-full p-3 rounded-lg bg-transparent text-gray-400 hover:text-red-500 hover:bg-red-50 dark:hover:bg-red-900/20 transition-colors flex items-center justify-center gap-2" title="Report Question">
          <svg class="w-5 h-5" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" d="M3 21v-4m0 0V5a2 2 0 0 1 2-2h6.5l1 2H21l-3 6 3 6h-8.5l-1-2H5a2 2 0 0 1-2-2zm9-13.5V9"/>
          </svg>
          <span class="text-sm">Report Question</span>
        </button>
      </div>
        </div>
      </div>

        <!-- Question Panel -->
        <div id="question-panel" class="flex-1 transition-all duration-300 max-w-4xl">
      <!-- Question Container -->
      <div id="question-container" class="border-2 border-gray-300 dark:border-slate-600 rounded-lg overflow-hidden">
        <div class="flex items-center justify-center h-96 text-gray-500 bg-white dark:bg-slate-900">
          Loading question...
        </div>
      </div>

      <!-- Solution Container (Hidden initially) -->
      <div id="solution-container" class="mt-6" style="display: none;">
        <h3 class="text-lg font-semibold mb-3">Solution</h3>
        <div id="solution-content" class="border-2 border-gray-300 dark:border-slate-600 rounded-lg overflow-hidden">
          <!-- Solution will be loaded here -->
        </div>
      </div>
    </div>
  </div>



  <script>
    interface PracticeQuestion {
      id?: string;
      topic?: string;
      subject?: string;
      difficulty?: string | number;
      timeLimitMinute?: number;
      timeLimit?: number;
      tags?: string[];
      questionImageUrl?: string;
      questionImagePath?: string;
      solutionImageUrl?: string;
      solutionImagePath?: string;
      image?: string;
      name?: string;
      // Accept any extra fields (for solutionTifUrl, etc)
      [key: string]: any;
    }

    // Rectangle type for highlights
    type HighlightRect = { x: number, y: number, w: number, h: number };
    let highlightRects: HighlightRect[] = [];
    let questionHistory: Array<{
      question: PracticeQuestion,
      timerSeconds: number,
      zoomLevel: number,
      highlightRects: HighlightRect[],
      showingSolution: boolean
    }> = [];


    let currentQuestion: PracticeQuestion | null = null; // Holds the currently loaded question object from the API
    let timerSeconds = 0;
    let timerInterval: ReturnType<typeof setInterval> | null = null;
    let showingSolution = false;
    let questionCounter = 1; // Global counter starting from 1

    // Client-side formatting functions
    function formatDifficulty(difficulty: number | string | undefined) {
      const difficultyValue = difficulty || 1;
      const difficultyNum = typeof difficultyValue === 'string' ? parseInt(difficultyValue) || 1 : difficultyValue;
      const normalizedDifficulty = Math.min(Math.max(difficultyNum, 1), 3);
      
      const difficultyConfig: { [key: number]: { label: string; color: string } } = {
        1: { label: 'Easy', color: 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-300' },
        2: { label: 'Medium', color: 'bg-orange-100 text-orange-800 dark:bg-orange-900 dark:text-orange-300' },
        3: { label: 'Hard', color: 'bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-300' }
      };
      
      return difficultyConfig[normalizedDifficulty];
    }

    function formatTopicName(topic: string | number | undefined | null): string {
      if (!topic) return '';
      
      const topicStr = String(topic).toLowerCase();
      
      const specialMappings: { [key: string]: string } = {
        'sequences-and-series': 'Sequences & Series',
        'sequences-series': 'Sequences & Series',
        'sequences and series': 'Sequences & Series',
        'prob-stat': 'Probability-Statistics',
        'probability-statistics': 'Probability-Statistics',
        'prob stat': 'Probability-Statistics',
        'the-line': 'The Line',
        'complex-numbers': 'Complex Numbers',
        'complex numbers': 'Complex Numbers',
        'financial-maths': 'Financial Maths',
        'financial maths': 'Financial Maths',
        'compound-interest': 'Compound Interest',
        'compound interest': 'Compound Interest',
        'mathematical-induction': 'Mathematical Induction',
        'mathematical induction': 'Mathematical Induction',
        'proof-by-induction': 'Proof by Induction',
        'proof by induction': 'Proof by Induction',
        'differentiation': 'Differentiation',
        'integration': 'Integration',
        'algebra': 'Algebra',
        'geometry': 'Geometry',
        'trigonometry': 'Trigonometry',
        'statistics': 'Statistics',
        'probability': 'Probability',
        'the-circle': 'The Circle',
        'functions': 'Functions',
        'induction': 'Induction',
        'number': 'Number'
      };
      
      if (specialMappings[topicStr]) {
        return specialMappings[topicStr];
      }
      
      for (const [key, value] of Object.entries(specialMappings)) {
        if (topicStr.includes(key) || key.includes(topicStr)) {
          return value;
        }
      }
      
      return topicStr
        .replace(/[-_]/g, ' ')
        .split(' ')
        .map(word => word.charAt(0).toUpperCase() + word.slice(1))
        .join(' ');
    }

    // Question caching system
    let questionBuffer: PracticeQuestion[] = []; // Cache of 5 validated questions
    let bufferIndex = 0; // Current position in the buffer
    let isLoadingBuffer = false; // Prevent concurrent buffer loads

    // State history for each question
  // (Removed duplicate declaration of questionHistory)

    // Timer functions
    function startTimer() {
      if (!timerInterval) {
        timerInterval = setInterval(() => {
          timerSeconds++;
          updateTimerDisplay();

        }, 1000);
        updateTimerButtons(true);
      }
    }

    function pauseTimer() {
      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
        updateTimerButtons(false);
      }
    }

    function resetTimer() {
      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }
      timerSeconds = 0;
      updateTimerDisplay();
      updateTimerButtons(false);
    }

    // Save Attempt Modal Functions
    function showSaveAttemptModal() {
      // Stop the timer when showing the modal
      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }
      
      // Update modal content
      const modalQuestionTitle = document.getElementById('modal-question-title');
      const modalTimeTaken = document.getElementById('modal-time-taken');
      
      if (modalQuestionTitle && currentQuestion) {
        modalQuestionTitle.textContent = currentQuestion.name || currentQuestion.id || 'Unknown Question';
      }
      
      if (modalTimeTaken) {
        const minutes = Math.floor(timerSeconds / 60);
        const seconds = timerSeconds % 60;
        modalTimeTaken.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      }
      
      // Show the modal
      const modal = document.getElementById('save-attempt-modal');
      if (modal) {
        modal.classList.remove('hidden');
        // Prevent body scroll while modal is open
        document.body.style.overflow = 'hidden';
      }
      
      // Clear previous notes and focus without scrolling
      const notesInput = document.getElementById('attempt-notes') as HTMLTextAreaElement;
      if (notesInput) {
        notesInput.value = '';
        // Focus without scrolling
        setTimeout(() => {
          notesInput.focus({ preventScroll: true });
        }, 100);
      }
    }
    
    function hideSaveAttemptModal() {
      const modal = document.getElementById('save-attempt-modal');
      if (modal) {
        modal.classList.add('hidden');
        // Restore body scroll
        document.body.style.overflow = '';
      }
    }
    
    function saveAttempt() {
      const notesInput = document.getElementById('attempt-notes') as HTMLTextAreaElement;
      const notes = notesInput ? notesInput.value : '';
      
      // Create attempt data
      const attemptData = {
        questionId: currentQuestion?.id || '',
        questionName: currentQuestion?.name || currentQuestion?.id || '',
        timeTaken: timerSeconds,
        notes: notes,
        timestamp: new Date().toISOString(),
        topic: currentQuestion?.topic || '',
        difficulty: currentQuestion?.difficulty || ''
      };
      
      // Store in localStorage (you could also send to backend API)
      const existingAttempts = JSON.parse(localStorage.getItem('questionAttempts') || '[]');
      existingAttempts.push(attemptData);
      localStorage.setItem('questionAttempts', JSON.stringify(existingAttempts));
      
      console.log('Attempt saved:', attemptData);
      
      // Hide modal
      hideSaveAttemptModal();
      
      // Show success message (optional)
      // You can add a status message element if needed
      console.log('Attempt saved successfully!');
      
      // Optionally move to next question
      nextQuestion();
    }

    // Report Question Modal Functions
    let selectedReportReason = '';
    
    function showReportQuestionModal() {
      // Update modal content
      const reportQuestionTitle = document.getElementById('report-question-title');
      
      if (reportQuestionTitle && currentQuestion) {
        reportQuestionTitle.textContent = currentQuestion.name || currentQuestion.id || 'Unknown Question';
      }
      
      // Reset modal state
      selectedReportReason = '';
      const selectedSection = document.getElementById('selected-reason-section');
      const customSection = document.getElementById('custom-description-section');
      const submitBtn = document.getElementById('submit-report') as HTMLButtonElement;
      
      if (selectedSection) selectedSection.classList.add('hidden');
      if (customSection) customSection.classList.add('hidden');
      if (submitBtn) submitBtn.disabled = true;
      
      // Clear custom description
      const customInput = document.getElementById('custom-description') as HTMLTextAreaElement;
      if (customInput) customInput.value = '';
      
      // Reset button styles
      document.querySelectorAll('.report-reason-btn').forEach(btn => {
        btn.classList.remove('bg-red-100', 'dark:bg-red-900/30', 'border-red-300', 'dark:border-red-600');
        btn.classList.add('border-gray-300', 'dark:border-slate-600');
      });
      
      // Show the modal
      const modal = document.getElementById('report-question-modal');
      if (modal) {
        modal.classList.remove('hidden');
        document.body.style.overflow = 'hidden';
      }
    }
    
    function hideReportQuestionModal() {
      const modal = document.getElementById('report-question-modal');
      if (modal) {
        modal.classList.add('hidden');
        document.body.style.overflow = '';
      }
    }
    
    function selectReportReason(reason: string, buttonElement: HTMLElement) {
      selectedReportReason = reason;
      
      // Reset all buttons
      document.querySelectorAll('.report-reason-btn').forEach(btn => {
        btn.classList.remove('bg-red-100', 'dark:bg-red-900/30', 'border-red-300', 'dark:border-red-600');
        btn.classList.add('border-gray-300', 'dark:border-slate-600');
      });
      
      // Highlight selected button
      buttonElement.classList.remove('border-gray-300', 'dark:border-slate-600');
      buttonElement.classList.add('bg-red-100', 'dark:bg-red-900/30', 'border-red-300', 'dark:border-red-600');
      
      const selectedSection = document.getElementById('selected-reason-section');
      const selectedReasonEl = document.getElementById('selected-reason');
      const customSection = document.getElementById('custom-description-section');
      const submitBtn = document.getElementById('submit-report') as HTMLButtonElement;
      
      if (reason === 'Other') {
        // Show custom description input
        if (customSection) customSection.classList.remove('hidden');
        if (selectedSection) selectedSection.classList.add('hidden');
        if (submitBtn) submitBtn.disabled = true; // Will be enabled when text is entered
      } else {
        // Show selected reason
        if (selectedReasonEl) selectedReasonEl.textContent = reason;
        if (selectedSection) selectedSection.classList.remove('hidden');
        if (customSection) customSection.classList.add('hidden');
        if (submitBtn) submitBtn.disabled = false;
      }
    }
    
    function submitReport() {
      let reportReason = selectedReportReason;
      let description = '';
      
      if (selectedReportReason === 'Other') {
        const customInput = document.getElementById('custom-description') as HTMLTextAreaElement;
        description = customInput ? customInput.value.trim() : '';
        reportReason = description;
      }
      
      if (!reportReason) return;
      
      // Create report data
      const reportData = {
        questionId: currentQuestion?.id || '',
        questionName: currentQuestion?.name || currentQuestion?.id || '',
        reason: reportReason,
        description: description,
        timestamp: new Date().toISOString(),
        topic: currentQuestion?.topic || '',
        difficulty: currentQuestion?.difficulty || ''
      };
      
      // Store in localStorage (you could also send to backend API)
      const existingReports = JSON.parse(localStorage.getItem('questionReports') || '[]');
      existingReports.push(reportData);
      localStorage.setItem('questionReports', JSON.stringify(existingReports));
      
      console.log('Question reported:', reportData);
      
      // Hide modal
      hideReportQuestionModal();
      
      // Show success message
      console.log('Question reported successfully!');
    }

    function updateTimerDisplay() {
      const minutes = Math.floor(timerSeconds / 60);
      const seconds = timerSeconds % 60;
      const display = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      const el = document.getElementById('sidebar-timer');
      if (el) el.textContent = display;
    }

    function updateTimerButtons(isRunning) {
      const startButton = document.getElementById('timer-start');
      if (startButton) {
        if (isRunning) {
          startButton.innerHTML = `
            <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24">
              <path d="M6 4h4v16H6V4zm8 0h4v16h-4V4z"/>
            </svg>
          `;
          startButton.title = 'Pause Timer';
          startButton.className = 'p-2 bg-yellow-500 text-white rounded-lg hover:bg-yellow-600 transition-colors';
        } else {
          startButton.innerHTML = `
            <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24">
              <path d="M8 5v14l11-7z"/>
            </svg>
          `;
          startButton.title = 'Start Timer';
          startButton.className = 'p-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors';
        }
      }
    }

    // Question validation function
    async function validateQuestion(question: PracticeQuestion): Promise<boolean> {
      const questionUrl = question.questionTifUrl || question.questionImageUrl || question.questionImagePath || question.tifUrl || question.image || '';
      const solutionUrl = question.solutionTifUrl || question.solutionImageUrl || question.solutionImagePath || '';
      
      if (!questionUrl || !solutionUrl) {
        console.log('Question validation failed: Missing image URLs', { questionUrl, solutionUrl });
        return false;
      }

      try {
        // Validate question image
        const questionImageUrl = questionUrl.startsWith('http') ? questionUrl : `http://localhost:3001${questionUrl}`;
        const questionResponse = await fetch(questionImageUrl, { method: 'HEAD' });
        
        // Validate solution image
        const solutionImageUrl = solutionUrl.startsWith('http') ? solutionUrl : `http://localhost:3001${solutionUrl}`;
        const solutionResponse = await fetch(solutionImageUrl, { method: 'HEAD' });
        
        const isValid = questionResponse.ok && solutionResponse.ok;
        if (!isValid) {
          console.log('Question validation failed: Images not accessible', {
            question: questionResponse.status,
            solution: solutionResponse.status
          });
        }
        return isValid;
      } catch (error) {
        console.log('Question validation failed: Network error', error);
        return false;
      }
    }

    // Buffer management functions
    async function loadQuestionBuffer() {
      if (isLoadingBuffer) return;
      isLoadingBuffer = true;

      try {
        updateLoadingMessage("Loading question set...");
        const topic = window.location.pathname.split('/').pop();
        const response = await fetch('http://localhost:3001/api/topics/questions', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ topics: [topic] })
        });

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        const result = await response.json();
        if (!result.matchingQuestions || result.matchingQuestions.length === 0) {
          throw new Error('No questions available for this topic');
        }

        updateLoadingMessage("Validating questions...");
        
        // Shuffle and validate questions until we have 5 valid ones
        const shuffledQuestions = [...result.matchingQuestions].sort(() => Math.random() - 0.5);
        const validQuestions: PracticeQuestion[] = [];
        
        for (const question of shuffledQuestions) {
          if (validQuestions.length >= 5) break;
          
          updateLoadingMessage(`Validating question ${validQuestions.length + 1}/5...`);
          const isValid = await validateQuestion(question);
          if (isValid) {
            validQuestions.push(question);
          }
        }

        if (validQuestions.length === 0) {
          throw new Error('No valid questions found with accessible images');
        }

        questionBuffer.splice(0, questionBuffer.length, ...validQuestions);
        bufferIndex = 0;
        console.log(`Loaded ${validQuestions.length} validated questions into buffer`);
        
      } catch (error) {
        console.error('Error loading question buffer:', error);
        throw error;
      } finally {
        isLoadingBuffer = false;
      }
    }

    function getNextQuestionFromBuffer(): PracticeQuestion | null {
      if (questionBuffer.length === 0) return null;
      
      const question = questionBuffer[bufferIndex];
      bufferIndex = (bufferIndex + 1) % questionBuffer.length;
      
      // If we've cycled through all questions, trigger a reload for variety
      if (bufferIndex === 0) {
        console.log('Buffer cycled, will reload on next request');
        // Don't await this, let it load in background
        setTimeout(() => loadQuestionBuffer().catch(console.error), 100);
      }
      
      return question;
    }

    // Function to load a specific question by ID using direct API lookup
    async function loadSpecificQuestion(questionId: string): Promise<boolean> {
      try {
        showLoadingScreen("Loading specific question...");
        console.log(`Loading specific question: ${questionId}`);
        
        // Use direct question lookup API - this bypasses topic filtering
        const response = await fetch(`http://localhost:3001/api/questions?id=${encodeURIComponent(questionId)}`);
        
        if (response.ok) {
          const specificQuestion = await response.json();
          console.log('Successfully loaded question via direct lookup:', specificQuestion);
          
          // Verify the question ID matches exactly
          if (specificQuestion.id !== questionId) {
            console.error(`Question ID mismatch! Requested: "${questionId}", Received: "${specificQuestion.id}"`);
            return false;
          }
          
          // Validate the specific question
          updateLoadingMessage("Validating specific question...");
          const isValid = await validateQuestion(specificQuestion);
          if (!isValid) {
            console.log(`Question ${questionId} failed validation, loading random question instead`);
            return false;
          }

          // Set this as the current question
          currentQuestion = specificQuestion;
          showingSolution = false;
          
          // Initialize history with this question
          questionHistory = [{
            question: currentQuestion,
            timerSeconds: 0,
            zoomLevel: 1.0,
            highlightRects: [],
            showingSolution: false
          }];

          updateLoadingMessage("Displaying question...");
          displayQuestion(currentQuestion);
          updateMetadata(currentQuestion);
          updateTabAppearance();
          
          setTimeout(() => {
            hideLoadingScreen();
          }, 300);
          
          console.log(`‚úì Question loaded successfully: ${currentQuestion.name || currentQuestion.id} (ID: ${currentQuestion.id})`);
          return true;
          
        } else if (response.status === 404) {
          console.log(`Question with ID "${questionId}" not found`);
          return false;
        } else {
          console.error('Failed to fetch question, status:', response.status);
          return false;
        }

      } catch (error) {
        console.error('Error loading specific question:', error);
        return false;
      }
    }



    // Initialize buffer on page load
    async function initializeQuestionSystem() {
      try {
        showLoadingScreen("Initializing practice session...");
        await loadQuestionBuffer();
        console.log('Question system initialized successfully');
      } catch (error) {
        console.error('Failed to initialize question system:', error);
        // Continue anyway - loadQuestion will handle the error
      }
    }

    // Loading screen functions
    function showLoadingScreen(message = "Preparing your questions...") {
      const overlay = document.getElementById('loading-overlay');
      const messageEl = document.getElementById('loading-message');
      if (overlay) overlay.style.display = 'flex';
      if (messageEl) messageEl.textContent = message;
    }

    function hideLoadingScreen() {
      const overlay = document.getElementById('loading-overlay');
      if (overlay) {
        overlay.style.opacity = '0';
        setTimeout(() => {
          overlay.style.display = 'none';
        }, 300);
      }
    }

    function updateLoadingMessage(message) {
      const messageEl = document.getElementById('loading-message');
      if (messageEl) messageEl.textContent = message;
    }

    // Question loading and display

    async function loadQuestion({fromHistory = false, historyIndex = null} = {}) {
      if (fromHistory && historyIndex !== null && questionHistory[historyIndex]) {
        // Restore from history
        const state = questionHistory[historyIndex];
        currentQuestion = state.question;
        timerSeconds = state.timerSeconds;
        zoomLevel = state.zoomLevel;
        highlightRects = JSON.parse(JSON.stringify(state.highlightRects || []));
        showingSolution = state.showingSolution;
        updateTimerDisplay();
        updateTimerButtons(false);
        if (showingSolution) {
          displaySolution();
        } else {
          displayQuestion(currentQuestion);
        }
        updateMetadata(currentQuestion);
        updateQuestionTitle();
        updateTabAppearance();
        drawHighlights();
        return;
      }
      
      try {
        // Check if buffer needs loading
        if (questionBuffer.length === 0 && !isLoadingBuffer) {
          await loadQuestionBuffer();
        }
        
        // Get next question from buffer
        const data = getNextQuestionFromBuffer();
        if (!data) {
          throw new Error('No valid questions available in buffer');
        }
        
        currentQuestion = data;

        // Reset solution state
        showingSolution = false;
        const button = document.getElementById('show-solution');
        if (button) {
          button.textContent = 'Show Solution';
        }

        // Save state to history
        questionHistory = questionHistory.slice(0, questionCounter - 1); // Truncate forward history if any
        questionHistory.push({
          question: currentQuestion,
          timerSeconds,
          zoomLevel,
          highlightRects: JSON.parse(JSON.stringify(highlightRects)),
          showingSolution
        });

        updateLoadingMessage("Displaying question...");
        displayQuestion(data);
        updateMetadata(data);
        updateTabAppearance();
        
        // Hide loading screen once everything is loaded
        setTimeout(() => {
          hideLoadingScreen();
        }, 300);

      } catch (error) {
        console.error('Error loading question:', error);
        updateLoadingMessage("Error loading questions");
        setTimeout(() => {
          hideLoadingScreen();
          const qc = document.getElementById('question-container');
          if (qc) qc.innerHTML = '<div class="flex items-center justify-center h-full text-red-500">Error loading question. Please try again.</div>';
        }, 1000);
      }
    }

    let zoomLevel = 1.0;
    function displayQuestion(question) {
      const container = document.getElementById('question-container');
      if (!container) return;
      if (!question) {
        container.innerHTML = '<div class="flex items-center justify-center h-full text-red-500">No question data</div>';
        return;
      }

      // Verify the displayed question matches what was requested (if coming from specific question)
      const urlParams = new URLSearchParams(window.location.search);
      const requestedQuestionId = urlParams.get('q');
      
      if (requestedQuestionId && question.id !== requestedQuestionId) {
        console.error(`üö® QUESTION MISMATCH DETECTED!`);
        console.error(`Expected: ${requestedQuestionId}`);
        console.error(`Got: ${question.id}`);
        console.error('Question object:', question);
        
        // Show warning to user
        container.innerHTML = `
          <div class="flex flex-col items-center justify-center h-full text-center p-8">
            <div class="text-red-500 text-xl mb-4">‚ö†Ô∏è Question Mismatch Detected</div>
            <div class="text-gray-600 mb-2">Expected: <code>${requestedQuestionId}</code></div>
            <div class="text-gray-600 mb-4">Got: <code>${question.id || 'Unknown'}</code></div>
            <button onclick="window.history.back()" class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">
              Go Back to Questions
            </button>
          </div>
        `;
        return;
      }

      // Log successful question display
      if (requestedQuestionId) {
        console.log(`‚úÖ Displaying correct question: ${question.name || question.id} (ID: ${question.id})`);
      }
      // Support legacy and new API fields for image path
      const rawUrl = question.questionTifUrl || question.questionImageUrl || question.questionImagePath || question.tifUrl || question.image || '';
      if (rawUrl) {
        const imageUrl = rawUrl.startsWith('http') ? rawUrl : `http://localhost:3001${rawUrl}`;
        container.innerHTML = `
      <div class="flex justify-center items-start h-full">
        <img id="question-img" src="${imageUrl}" 
          alt="Question Image" 
          class="w-full max-w-[700px] h-auto"
          style="width: 100%; max-width: 1000px; height: auto; transform: scale(${zoomLevel}); transform-origin: top center; transition: transform 0.2s; display: block; margin-top: 0;"
          loading="lazy"
          crossorigin="anonymous"
          onerror="this.closest('div').innerHTML='Failed to load question image';">
      </div>
    `;
    updateZoomDisplay();
    // Scroll 10% down by default
    setTimeout(() => {
      container.scrollTop = container.scrollHeight * 0.1;
    }, 0);
      } else {
        container.innerHTML = '<div class="flex items-center justify-center h-full text-gray-500">No question image available</div>';
      }
    }

    function updateZoomDisplay() {
      const zoomDisplay = document.getElementById('zoom-level');
      if (zoomDisplay) zoomDisplay.textContent = Math.round(zoomLevel * 100) + '%';
      const img = document.getElementById('question-img');
      if (img) img.style.transform = `scale(${zoomLevel})`;
    }



    function updateMetadata(question) {
      // Debug: log the question object to see available fields
      console.log('Question data:', question);
      console.log('Available fields:', Object.keys(question));
      
      // Update year display
      const yearEl = document.getElementById('question-year');
      if (yearEl) {
        const name = question.name || question.Name || question.title || question.Title || '--';
        console.log('Name field value:', name);
        yearEl.textContent = name;
      }
      
      // Only update elements that actually exist in the markup
      const topicEl = document.getElementById('meta-topic');
      const diffEl = document.getElementById('meta-difficulty');
      const timeEl = document.getElementById('meta-time-limit');
      // API returns: id, topic, difficulty, timeLimitMinute, tags
      if (topicEl) {
        // Clear previous content
        topicEl.innerHTML = '';
        let topics = question.topic || question.subject || '--';
        
        // If topics is a string, make it an array for uniform handling
        if (typeof topics === 'string') {
          topics = [topics];
        }
        
        if (Array.isArray(topics)) {
          // Create formatted topic badges (same styling as Questions page)
          topics.forEach(topic => {
            const topicBadge = document.createElement('span');
            topicBadge.className = 'inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium bg-gray-100 text-gray-700 dark:bg-slate-700 dark:text-slate-300 whitespace-nowrap mr-1 mb-1';
            topicBadge.textContent = formatTopicName(String(topic));
            topicEl.appendChild(topicBadge);
          });
        } else {
          // Fallback for unexpected types
          const topicBadge = document.createElement('span');
          topicBadge.className = 'inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium bg-gray-100 text-gray-700 dark:bg-slate-700 dark:text-slate-300 whitespace-nowrap';
          topicBadge.textContent = formatTopicName(String(topics));
          topicEl.appendChild(topicBadge);
        }
      }
      if (diffEl) {
        const difficultyInfo = formatDifficulty(question.difficulty);
        diffEl.textContent = difficultyInfo.label;
        diffEl.className = `inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium ${difficultyInfo.color}`;
      }
      const limit = question.timeLimitMinute || question.timeLimit;
      if (timeEl) timeEl.textContent = limit ? `${limit} min` : '--';
    }

    function updateQuestionTitle() {
      const titleElement = document.getElementById('question-title');
      if (titleElement) {
        titleElement.textContent = `Question ${questionCounter}`;
      }
    }

    function nextQuestion() {
      // Save current state before moving forward
      if (currentQuestion) {
        if (questionHistory.length < questionCounter) {
          questionHistory.push({
            question: currentQuestion,
            timerSeconds,
            zoomLevel,
            highlightRects: JSON.parse(JSON.stringify(highlightRects)),
            showingSolution
          });
        } else {
          questionHistory[questionCounter - 1] = {
            question: currentQuestion,
            timerSeconds,
            zoomLevel,
            highlightRects: JSON.parse(JSON.stringify(highlightRects)),
            showingSolution
          };
        }
      }
      questionCounter++;
      updateQuestionTitle();
      // Reset solution state
      showingSolution = false;
      const button = document.getElementById('show-solution');
      if (button) {
        button.textContent = 'Show Solution';
      }
      // Load a new question
      loadQuestion();
    }


    function skipQuestion() {
      // Save current state before skipping
      if (currentQuestion) {
        if (questionHistory.length < questionCounter) {
          questionHistory.push({
            question: currentQuestion,
            timerSeconds,
            zoomLevel,
            highlightRects: JSON.parse(JSON.stringify(highlightRects)),
            showingSolution
          });
        } else {
          questionHistory[questionCounter - 1] = {
            question: currentQuestion,
            timerSeconds,
            zoomLevel,
            highlightRects: JSON.parse(JSON.stringify(highlightRects)),
            showingSolution
          };
        }
      }
      questionCounter++;
      updateQuestionTitle();
      // Reset solution state
      showingSolution = false;
      const button = document.getElementById('show-solution');
      if (button) {
        button.textContent = 'Show Solution';
      }
      const statusMsg = document.getElementById('status-message');
      if (statusMsg) {
        statusMsg.innerHTML = '<span class="text-yellow-600 font-medium">Question skipped</span>';
      }
      // Load a new question
      loadQuestion();
    }

    function prevQuestion() {
      if (questionCounter <= 1) return;
      // Save current state before moving back
      if (currentQuestion) {
        questionHistory[questionCounter - 1] = {
          question: currentQuestion,
          timerSeconds,
          zoomLevel,
          highlightRects: JSON.parse(JSON.stringify(highlightRects)),
          showingSolution
        };
      }
      questionCounter--;
      updateQuestionTitle();
      // Restore previous state ONLY from history
      const idx = questionCounter - 1;
      if (questionHistory[idx]) {
        const state = questionHistory[idx];
        currentQuestion = state.question;
        timerSeconds = state.timerSeconds;
        zoomLevel = state.zoomLevel;
        highlightRects = JSON.parse(JSON.stringify(state.highlightRects || []));
        showingSolution = state.showingSolution;
        updateTimerDisplay();
        updateTimerButtons(false);
        if (showingSolution) {
          displaySolution();
        } else {
          displayQuestion(currentQuestion);
          // Scroll 10% down by default when restoring
          const container = document.getElementById('question-container');
          if (container) setTimeout(() => { container.scrollTop = container.scrollHeight * 0.1; }, 0);
        }
        updateMetadata(currentQuestion);
        updateQuestionTitle();
        drawHighlights();
      }
      // If no history, do nothing (do not generate a new question)
    }

  function displaySolution() {
    const container = document.getElementById('question-container');
    if (!container || !currentQuestion) return;
    // Accept solutionImageUrl, solutionImagePath, or solutionTifUrl (if present)
    const rawSolutionUrl = currentQuestion.solutionTifUrl || currentQuestion.solutionImageUrl || currentQuestion.solutionImagePath;
    if (rawSolutionUrl) {
      const imageUrl = rawSolutionUrl.startsWith('http') ? rawSolutionUrl : `http://localhost:3001${rawSolutionUrl}`;
      container.innerHTML = `
        <div class="flex justify-center" style="position: relative;">
          <img id="solution-img" src="${imageUrl}" 
               alt="Solution Image" 
               class="max-w-full h-auto rounded"
               style="transform: scale(${zoomLevel}); transform-origin: top center; transition: transform 0.2s; display: block; margin-top: 0;"
               loading="lazy"
               crossorigin="anonymous"
               onerror="this.closest('div').innerHTML='Failed to load solution image';">
          <canvas id="highlight-canvas" style="position: absolute; left: 0; top: 0; pointer-events: none;"></canvas>
        </div>
      `;
      updateZoomDisplay();
      setTimeout(setupHighlighter, 100);
    } else {
      container.innerHTML = '<div class="flex items-center justify-center h-full text-gray-500">No solution available</div>';
    }
  }

  function drawHighlights() {
    const img = document.getElementById('question-img') || document.getElementById('solution-img');
    const canvas = document.getElementById('highlight-canvas') as HTMLCanvasElement | null;
    if (!img || !canvas) return;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    highlightRects.forEach(rect => drawRect(rect, 'rgba(255,255,0,0.3)'));
  }

  function drawRect(rect: HighlightRect, color: string) {
    const canvas = document.getElementById('highlight-canvas') as HTMLCanvasElement | null;
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;
    ctx.save();
    ctx.strokeStyle = 'rgba(255,215,0,0.8)';
    ctx.lineWidth = 2;
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.rect(rect.x, rect.y, rect.w, rect.h);
    ctx.fill();
    ctx.stroke();
    ctx.restore();
  }

  function setupHighlighter() {
    // Dummy function for now, implement as needed for highlight interaction
    // This should set up mouse events for drawing highlights
  }

  function toggleSolution() {
    if (!currentQuestion) return;
    const button = document.getElementById('show-solution');
    const statusMsg = document.getElementById('status-message');
    if (!button) return;
    if (!showingSolution) {
      displaySolution();
      button.textContent = 'Show Question';
      if (statusMsg) statusMsg.innerHTML = '<span class="text-blue-600 font-medium">Solution displayed</span>';
      showingSolution = true;
    } else {
      displayQuestion(currentQuestion);
      button.textContent = 'Show Solution';
      if (statusMsg) statusMsg.innerHTML = '<span class="text-gray-600 font-medium">Question displayed</span>';
      showingSolution = false;
    }
    updateTabAppearance();
  }

  function updateTabAppearance() {
    const questionTab = document.getElementById('tab-question');
    const solutionTab = document.getElementById('tab-solution');
    
    if (questionTab && solutionTab) {
      if (showingSolution) {
        // Solution tab is active (white background)
        questionTab.className = 'flex-1 py-2 text-center font-semibold text-gray-700 bg-gray-100 hover:bg-gray-300 border-r border-gray-300 transition';
        solutionTab.className = 'flex-1 py-2 text-center font-semibold text-gray-700 bg-white hover:bg-gray-300 transition';
      } else {
        // Question tab is active (white background)
        questionTab.className = 'flex-1 py-2 text-center font-semibold text-gray-700 bg-white hover:bg-gray-300 border-r border-gray-300 transition';
        solutionTab.className = 'flex-1 py-2 text-center font-semibold text-gray-700 bg-gray-100 hover:bg-gray-300 transition';
      }
    }
  }

    // Event listeners
  document.addEventListener('DOMContentLoaded', () => {
      // Zoom controls
      const zoomInBtn = document.getElementById('zoom-in');
      const zoomOutBtn = document.getElementById('zoom-out');
      if (zoomInBtn) zoomInBtn.addEventListener('click', () => {
        zoomLevel = Math.min(zoomLevel + 0.1, 3.0);
        updateZoomDisplay();
      });
      if (zoomOutBtn) zoomOutBtn.addEventListener('click', () => {
        zoomLevel = Math.max(zoomLevel - 0.1, 0.2);
        updateZoomDisplay();
      });
      // Update initial question title
      updateQuestionTitle();
      
      // Check for specific question ID in URL parameters
      const urlParams = new URLSearchParams(window.location.search);
      const specificQuestionId = urlParams.get('q');
      
      if (specificQuestionId) {
        console.log(`üéØ Attempting to load specific question with ID: ${specificQuestionId}`);
        
        // Load specific question
        loadSpecificQuestion(specificQuestionId).then((success) => {
          if (!success) {
            // If specific question loading failed, show clear warning and fall back to random
            console.warn(`‚ùå Failed to load specific question "${specificQuestionId}"`);
            console.warn('üîÑ Falling back to random question loading as safety measure');
            
            // Show user notification about fallback
            showLoadingScreen(`Question "${specificQuestionId}" not found. Loading a random question...`);
            setTimeout(() => {
              initializeQuestionSystem().then(() => {
                loadQuestion();
                updateTabAppearance();
              }).catch((error) => {
                console.error('Initialization failed:', error);
                loadQuestion();
                updateTabAppearance();
              });
            }, 2000); // Give user time to see the message
          } else {
            console.log(`‚úÖ Successfully loaded specific question: ${specificQuestionId}`);
            // Successfully loaded specific question, still load buffer for navigation
            initializeQuestionSystem().catch(console.error);
          }
        }).catch((error) => {
          console.error('‚ùå Error during specific question loading:', error);
          console.warn('üîÑ Falling back to random question loading');
          
          // Show user notification about error
          showLoadingScreen('Error loading specific question. Loading a random question...');
          setTimeout(() => {
            initializeQuestionSystem().then(() => {
              loadQuestion();
              updateTabAppearance();
            }).catch((error) => {
              console.error('Initialization failed:', error);
              loadQuestion();
              updateTabAppearance();
            });
          }, 2000);
        });
      } else {
        // Normal initialization - no specific question requested
        initializeQuestionSystem().then(() => {
          loadQuestion();
          updateTabAppearance();
        }).catch((error) => {
          console.error('Initialization failed, falling back to direct load:', error);
          loadQuestion();
          updateTabAppearance();
        });
      }
      
      // Timer controls
      const startBtn = document.getElementById('timer-start');
      if (startBtn) {
        startBtn.addEventListener('click', () => {
          if (timerInterval) {
            pauseTimer();
          } else {
            startTimer();
          }
        });
      }
      const resetBtn = document.getElementById('timer-reset');
      if (resetBtn) resetBtn.addEventListener('click', resetTimer);

      // Favourite (star) button
      const favBtn = document.getElementById('sidebar-favourite');
      if (favBtn) favBtn.addEventListener('click', () => {
        // TODO: Implement add/remove favourite logic here
        favBtn.classList.toggle('text-yellow-400');
        favBtn.classList.toggle('fill-yellow-400');
      });

      // Tab switching
      const questionTab = document.getElementById('tab-question');
      const solutionTab = document.getElementById('tab-solution');
      
      if (questionTab) {
        questionTab.addEventListener('click', () => {
          if (showingSolution && currentQuestion) {
            displayQuestion(currentQuestion);
            showingSolution = false;
            updateTabAppearance();
          }
        });
      }
      
      if (solutionTab) {
        solutionTab.addEventListener('click', () => {
          if (!showingSolution && currentQuestion) {
            displaySolution();
            showingSolution = true;
            updateTabAppearance();
          }
        });
      }

      // Action buttons
      const solutionBtn = document.getElementById('show-solution');
      if (solutionBtn) solutionBtn.addEventListener('click', toggleSolution);

      // Navigation buttons
      const nextBtn = document.getElementById('next-question');
      if (nextBtn) nextBtn.addEventListener('click', nextQuestion);
      const skipBtn = document.getElementById('skip-question');
      if (skipBtn) skipBtn.addEventListener('click', skipQuestion);
      const saveAttemptBtn = document.getElementById('save-attempt');
      if (saveAttemptBtn) saveAttemptBtn.addEventListener('click', showSaveAttemptModal);
      const prevBtn = document.getElementById('prev-question');
      if (prevBtn) prevBtn.addEventListener('click', prevQuestion);

      // Save Attempt Modal event listeners
      const cancelSaveBtn = document.getElementById('cancel-save-attempt');
      if (cancelSaveBtn) cancelSaveBtn.addEventListener('click', hideSaveAttemptModal);
      const confirmSaveBtn = document.getElementById('confirm-save-attempt');
      if (confirmSaveBtn) confirmSaveBtn.addEventListener('click', saveAttempt);

      // Report Question Modal event listeners
      const reportBtn = document.getElementById('report-question');
      if (reportBtn) reportBtn.addEventListener('click', showReportQuestionModal);
      const cancelReportBtn = document.getElementById('cancel-report');
      if (cancelReportBtn) cancelReportBtn.addEventListener('click', hideReportQuestionModal);
      const submitReportBtn = document.getElementById('submit-report');
      if (submitReportBtn) submitReportBtn.addEventListener('click', submitReport);
      
      // Report reason buttons
      document.querySelectorAll('.report-reason-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const reason = btn.getAttribute('data-reason') || '';
          selectReportReason(reason, btn as HTMLElement);
        });
      });
      
      // Custom description input validation
      const customDescInput = document.getElementById('custom-description') as HTMLTextAreaElement;
      if (customDescInput) {
        customDescInput.addEventListener('input', () => {
          const submitBtn = document.getElementById('submit-report') as HTMLButtonElement;
          if (selectedReportReason === 'Other' && submitBtn) {
            submitBtn.disabled = customDescInput.value.trim().length === 0;
          }
        });
      }
    });
  </script>

  <style>
    #sidebar {
      width: 20rem; /* w-80 */
    }

    #question-panel {
      transition: margin-left 0.3s ease;
    }

    #loading-overlay {
      transition: opacity 0.3s ease;
    }

    /* Responsive behavior for smaller screens */
    @media (max-width: 1280px) {
      #sidebar {
        width: 18rem;
      }
      #question-panel {
        margin-left: 18rem !important;
      }
    }

    @media (max-width: 1024px) {
      #sidebar {
        width: 16rem;
      }
      #question-panel {
        margin-left: 16rem !important;
      }
    }
  </style>
</Layout>
