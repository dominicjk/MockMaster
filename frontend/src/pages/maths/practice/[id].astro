---
// src/pages/maths/practice/[id].astro
import Layout from '~/layouts/PageLayout.astro';
// import { PRACTICE_YEAR_FIRST, PRACTICE_YEAR_LAST } from '~/config/practiceDefaults'; // reserved for future dynamic injection
// Removed unused utils imports (local script defines formatting)

export function getStaticPaths() {
  const ids = [
    'all', // All topics practice
    'mixed', // Multiple selected topics practice
    'start', // Handle multi-topic practice sessions (legacy)
    'number','algebra','complex-numbers','sequences-and-series','financial-maths','induction',
    'functions','differentiation','integration','the-line','the-circle','geometry','trigonometry',
    'probability','statistics',
  ];
  return ids.map((id) => ({ params: { id } }));
}

const { id } = Astro.params;
const metadata = { title: `Practice - ${id}` };
// (PRACTICE_YEAR_FIRST / LAST imported for future build-time use if needed)
---

<Layout metadata={metadata}>
  <!-- Loading Screen Overlay -->
  <div id="loading-overlay" class="fixed inset-0 bg-white dark:bg-slate-900 z-50 flex items-center justify-center">
    <div class="text-center">
      <div class="inline-block animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mb-4"></div>
      <h2 class="text-xl font-semibold text-gray-800 dark:text-gray-200 mb-2">Loading Practice Session</h2>
      <p class="text-gray-600 dark:text-gray-400" id="loading-message">Preparing your questions...</p>
    </div>
  </div>

  <!-- Save Attempt Modal -->
  <div id="save-attempt-modal" class="fixed inset-0 bg-black bg-opacity-50 backdrop-blur-sm z-50 flex items-center justify-center hidden">
    <div class="bg-white dark:bg-slate-800 rounded-xl p-6 max-w-md w-full mx-4 shadow-xl">
      <h3 class="text-lg font-semibold text-gray-800 dark:text-gray-200 mb-4">Save Your Attempt</h3>
      
      <!-- Question Title Display -->
      <div class="mb-4">
        <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Question:</label>
        <div id="modal-question-title" class="p-3 bg-gray-50 dark:bg-slate-700 rounded-lg text-gray-800 dark:text-gray-200">
          --
        </div>
      </div>
      
      <!-- Time Display -->
      <div class="mb-4">
        <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Time Taken:</label>
        <div id="modal-time-taken" class="p-3 bg-gray-50 dark:bg-slate-700 rounded-lg font-mono text-gray-800 dark:text-gray-200">
          00:00
        </div>
      </div>
      
      <!-- Notes Input -->
      <div class="mb-6">
        <label for="attempt-notes" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Notes:</label>
        <textarea 
          id="attempt-notes" 
          rows="4" 
          class="w-full p-3 border border-gray-300 dark:border-slate-600 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 dark:bg-slate-700 dark:text-gray-200 resize-none"
          placeholder="Add your notes about this question attempt..."
        ></textarea>
      </div>
      
      <!-- Modal Actions -->
      <div class="flex gap-3">
        <button id="cancel-save-attempt" class="flex-1 px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 dark:bg-slate-600 dark:text-gray-200 dark:hover:bg-slate-500">
          Cancel
        </button>
        <button id="confirm-save-attempt" class="flex-1 px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 dark:bg-blue-600 dark:hover:bg-blue-700">
          Save Attempt
        </button>
      </div>
    </div>
  </div>

  <!-- Report Question Modal -->
  <div id="report-question-modal" class="fixed inset-0 bg-black bg-opacity-50 backdrop-blur-sm z-50 flex items-center justify-center hidden">
    <div class="bg-white dark:bg-slate-800 rounded-xl p-6 max-w-md w-full mx-4 shadow-xl">
      <h3 class="text-lg font-semibold text-gray-800 dark:text-gray-200 mb-4">Report Question</h3>
      
      <!-- Question Title Display -->
      <div class="mb-4">
        <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Question:</label>
        <div id="report-question-title" class="p-3 bg-gray-50 dark:bg-slate-700 rounded-lg text-gray-800 dark:text-gray-200">
          --
        </div>
      </div>
      
      <!-- Report Reason Selection -->
      <div class="mb-4">
        <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-3">Select issue:</label>
        <div class="space-y-2">
          <button class="report-reason-btn w-full p-3 text-left border border-gray-300 dark:border-slate-600 rounded-lg hover:bg-gray-50 dark:hover:bg-slate-700 transition-colors" data-reason="Question too blurry">
            Question Too Blurry
          </button>
          <button class="report-reason-btn w-full p-3 text-left border border-gray-300 dark:border-slate-600 rounded-lg hover:bg-gray-50 dark:hover:bg-slate-700 transition-colors" data-reason="Question too hard">
            Question Too Hard
          </button>
          <button class="report-reason-btn w-full p-3 text-left border border-gray-300 dark:border-slate-600 rounded-lg hover:bg-gray-50 dark:hover:bg-slate-700 transition-colors" data-reason="Incorrect solution">
            Incorrect Solution
          </button>
          <button class="report-reason-btn w-full p-3 text-left border border-gray-300 dark:border-slate-600 rounded-lg hover:bg-gray-50 dark:hover:bg-slate-700 transition-colors" data-reason="Other">
            Other
          </button>
        </div>
      </div>
      
      <!-- Custom Description (Hidden initially) -->
      <div id="custom-description-section" class="mb-4 hidden">
        <label for="custom-description" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Please describe the issue:</label>
        <textarea 
          id="custom-description" 
          rows="3" 
          class="w-full p-3 border border-gray-300 dark:border-slate-600 rounded-lg focus:ring-2 focus:ring-red-500 focus:border-red-500 dark:bg-slate-700 dark:text-gray-200 resize-none"
          placeholder="Please describe what's wrong with this question..."
        ></textarea>
      </div>
      
      <!-- Selected Reason Display -->
      <div id="selected-reason-section" class="mb-4 hidden">
        <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Issue:</label>
        <div id="selected-reason" class="p-3 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-700 rounded-lg text-red-700 dark:text-red-300">
          --
        </div>
      </div>
      
      <!-- Modal Actions -->
      <div class="flex gap-3">
        <button id="cancel-report" class="flex-1 px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 dark:bg-slate-600 dark:text-gray-200 dark:hover:bg-slate-500">
          Cancel
        </button>
        <button id="submit-report" class="flex-1 px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600 dark:bg-red-600 dark:hover:bg-red-700 disabled:opacity-50 disabled:cursor-not-allowed" disabled>
          Submit Report
        </button>
      </div>
    </div>
  </div>

  <!-- Main Content Container -->
  <div class="min-h-screen pb-24" style="margin-top: 10px;">
    <div class="p-6">
      <div class="flex gap-6 justify-center max-w-7xl mx-auto">
        <!-- Options Panel -->
        <div id="sidebar" class="w-80 bg-white dark:bg-slate-800 border border-gray-200 dark:border-slate-700 rounded-xl shadow-lg overflow-hidden sticky" style="top: calc(var(--navbar-height, 120px) + 1rem); height: calc(100vh - var(--navbar-height, 120px) - 2rem);">
          <!-- Top Toggle Tabs (true top slice of sidebar) -->
          <div class="w-full rounded-t-lg overflow-hidden mb-2" style="background: #e5e7eb;">
            <div class="flex flex-row w-full">
              <button id="tab-question" class="flex-1 py-2 text-center font-semibold text-gray-700 bg-white hover:bg-gray-300 border-r border-gray-300 transition" style="outline:none;">Question</button>
              <button id="tab-solution" class="flex-1 py-2 text-center font-semibold text-gray-700 bg-gray-100 hover:bg-gray-300 transition" style="outline:none;">Solution</button>
            </div>
          </div>
          <div class="p-6 h-full">
        <!-- Question Heading (moved here from question panel) -->
        <div id="question-heading" class="mb-3">
          <div class="flex items-center gap-2 leading-tight">
            <span id="qh-year" class="text-sm font-semibold text-gray-600 dark:text-gray-300"></span>
            <span id="qh-paper" class="text-xs tracking-wide uppercase text-gray-500 dark:text-gray-400"></span>
          </div>
          <div id="qh-title" class="text-lg font-bold text-gray-800 dark:text-gray-100 mt-1"></div>
        </div>
        
        <!-- Favorite Star -->
        <div class="flex items-center mb-3 gap-3">
          <!-- Star (favourite) icon -->
          <button id="sidebar-favourite" class="p-2 rounded-xl hover:bg-yellow-100 dark:hover:bg-yellow-900" title="Add to Favourites" style="display: block;" >
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
            </svg>
          </button>
          <!-- Group zoom + timer -->
          <div class="flex items-center gap-1 ml-auto merged-group">
            <div id="zoom-controls" class="flex items-stretch select-none" role="group" aria-label="Zoom controls">
              <button id="zoom-out" title="Zoom Out" aria-label="Zoom Out"
                class="zoom-btn-left font-bold text-xl leading-none" type="button">−</button>
              <div id="zoom-level" class="zoom-level font-semibold" aria-live="polite">100%</div>
              <button id="zoom-in" title="Zoom In" aria-label="Zoom In"
                class="zoom-btn-right font-bold text-xl leading-none" type="button">+</button>
            </div>
            <div id="timer-controls" class="flex items-stretch select-none" role="group" aria-label="Timer controls">
              <button id="timer-start" title="Start Timer" aria-label="Start Timer" class="timer-btn-left" type="button">
                <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
              </button>
              <div id="sidebar-timer" class="timer-display font-semibold" aria-live="polite">00:00</div>
              <button id="timer-reset" title="Reset Timer" aria-label="Reset Timer" class="timer-btn-right" type="button">
                <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 24 24"><path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/></svg>
              </button>
            </div>
          </div>
        </div>
      <!-- Former timer section removed; spacing preserved intentionally -->
      <div class="mb-4 sidebar-content"></div>

      <!-- Question Metadata -->
      <div class="mb-8 sidebar-content">
        <div class="space-y-3">
          <div class="w-full">
            <div id="meta-topic" class="font-medium text-base flex flex-wrap items-start gap-1"></div>
          </div>
          <div class="w-full">
            <div class="flex items-center gap-2">
              <span id="meta-difficulty" class="inline-flex items-center px-2 py-0.5 rounded-full text-sm font-medium bg-blue-100 text-blue-700 dark:bg-blue-900 dark:text-blue-300">--</span>
            </div>
          </div>
        </div>
      </div>

      <!-- Navigation -->
      <div class="mb-6 sidebar-content">
  <div id="nav-controls" class="flex items-center gap-1 mb-4 select-none w-full" role="group" aria-label="Question navigation">
          <button id="prev-question" class="nav-btn flex-1" title="Previous Question" aria-label="Previous Question" type="button">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/></svg>
          </button>
          <button id="next-question" class="nav-btn flex-1" title="Next Question" aria-label="Next Question" type="button">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/></svg>
          </button>
        </div>
        <button id="save-attempt" class="w-full pill-action" type="button">Save Attempt</button>
      </div>

      <!-- Report Section -->
      <div class="sidebar-content">
        <button id="report-question" class="w-full p-3 rounded-lg bg-transparent text-gray-400 hover:text-red-500 hover:bg-red-50 dark:hover:bg-red-900/20 transition-colors flex items-center justify-center gap-2" title="Report Question">
          <svg class="w-5 h-5" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" d="M3 21v-4m0 0V5a2 2 0 0 1 2-2h6.5l1 2H21l-3 6 3 6h-8.5l-1-2H5a2 2 0 0 1-2-2zm9-13.5V9"/>
          </svg>
          <span class="text-sm">Report Question</span>
        </button>
      </div>
        </div>
      </div>

        <!-- Question Panel -->
        <div id="question-panel" class="flex-1 transition-all duration-300 max-w-4xl">
      <!-- Question Container -->
      <div id="question-container" class="border-2 border-gray-300 dark:border-slate-600 rounded-lg overflow-hidden">
        <div class="flex items-center justify-center h-96 text-gray-500 bg-white dark:bg-slate-900">
          Loading question...
        </div>
      </div>

      <!-- Solution Container (Hidden initially) -->
      <div id="solution-container" class="mt-6" style="display: none;">
        <h3 class="text-lg font-semibold mb-3">Solution</h3>
        <div id="solution-content" class="border-2 border-gray-300 dark:border-slate-600 rounded-lg overflow-hidden">
          <!-- Solution will be loaded here -->
        </div>
      </div>
    </div>
  </div>



  <!-- Expose reset URL & year bounds globally (serialized by Astro frontmatter variables) -->
  <script>
    // Practice reset configuration injected from frontmatter
  // NOTE: Hardcoded numeric injection fallback (update alongside config file if year bounds change)
  const YEAR_FIRST = 2024; // keep in sync with practiceDefaults.ts
  const YEAR_LAST = 2012;  // keep in sync with practiceDefaults.ts
  const PRACTICE_RESET_URL = `http://localhost:4321/maths/practice/all?topics=all&examOnly=false&longOnly=false&shortOnly=false&yearFrom=${YEAR_FIRST}&yearTo=${YEAR_LAST}&customOnly=false`;
    interface PracticeQuestion {
      id?: string;
      topic?: string;
      subject?: string;
      difficulty?: string | number;
      timeLimitMinute?: number;
      timeLimit?: number;
      tags?: string[];
      questionImageUrl?: string;
      questionImagePath?: string;
      solutionImageUrl?: string;
      solutionImagePath?: string;
      image?: string;
      name?: string;
      displayName?: string; // derived custom-friendly name
      // Accept any extra fields (for solutionTifUrl, etc)
      [key: string]: unknown;
    }

    // Rectangle type for highlights
    type HighlightRect = { x: number, y: number, w: number, h: number };
    let highlightRects: HighlightRect[] = [];
    let questionHistory: Array<{
      question: PracticeQuestion,
      timerSeconds: number,
      zoomLevel: number,
      highlightRects: HighlightRect[],
      showingSolution: boolean
    }> = [];


    let currentQuestion: PracticeQuestion | null = null; // Holds the currently loaded question object from the API
    let timerSeconds = 0;
    let timerInterval: ReturnType<typeof setInterval> | null = null;
    let showingSolution = false;
    let questionCounter = 1; // Global counter starting from 1

    // --- Ordered sequence mode (when arriving from a questions table) ---
    const initialParams = new URLSearchParams(window.location.search);
    const directQuestionId = initialParams.get('q');
    let sequenceIds: string[] = [];
    const sequenceParam = initialParams.get('sequence') || initialParams.get('ids');
    if (sequenceParam) {
      if (sequenceParam === 'session') {
        try {
          const raw = sessionStorage.getItem('practiceSequence');
          if (raw) {
            const parsed = JSON.parse(raw);
            if (parsed && Array.isArray(parsed.ids)) {
              sequenceIds = parsed.ids.map((s: unknown) => String(s)).filter(Boolean);
              console.log('[sequence] Loaded from sessionStorage', parsed);
            }
          }
        } catch (e) {
          console.warn('[sequence] Failed to load session sequence', e);
        }
      } else {
        sequenceIds = sequenceParam.split(',').map(s => s.trim()).filter(Boolean);
      }
    }
    let sequenceIndex = -1; // Index within sequenceIds for currentQuestion
    const sequenceMode = sequenceIds.length > 0 && !!directQuestionId; // active only if both list and specific id provided

    function updateUrlQuestionId(newId: string) {
      try {
        const u = new URL(window.location.href);
        u.searchParams.set('q', newId);
        // preserve ids/sequence param automatically by replaceState
        window.history.replaceState({}, '', u.toString());
      } catch (e) { console.warn('[sequence] Failed to update URL', e); }
    }

    // --- FAVOURITES (session/local persistence) ---
    function getFavouriteIds(): string[] {
      try { return JSON.parse(localStorage.getItem('favouriteQuestions') || '[]'); } catch { return []; }
    }
    function setFavouriteIds(ids: string[]) {
      try { localStorage.setItem('favouriteQuestions', JSON.stringify(Array.from(new Set(ids)))); }
      catch (e) { console.warn('Failed to persist favourites', e); }
    }
    function isFavourite(id: string | undefined | null): boolean {
      if (!id) return false; return getFavouriteIds().includes(String(id));
    }
    // toggleFavourite moved to database-backed version below
    function updateFavouriteStar() {
      const btn = document.getElementById('sidebar-favourite');
      if (!btn || !currentQuestion?.id) return;
      // Check both database Set and localStorage fallback
      const fav = userFavourites.has(currentQuestion.id) || isFavourite(currentQuestion.id);
      btn.setAttribute('aria-pressed', fav ? 'true' : 'false');
      btn.title = fav ? 'Remove from Favourites' : 'Add to Favourites';
      btn.innerHTML = fav ? `
        <svg class="w-6 h-6 text-yellow-500" fill="currentColor" viewBox="0 0 24 24">
          <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z" />
        </svg>` : `
        <svg class="w-6 h-6 text-gray-400 hover:text-yellow-500 transition-colors" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z" />
        </svg>`;
    }

    // Database-backed favourites management
    let userFavourites: Set<string> = new Set();

    async function loadUserFavourites() {
      try {
        const response = await fetch('http://localhost:3001/api/favourites', {
          credentials: 'include'
        });

        if (response.ok) {
          const data = await response.json();
          userFavourites = new Set(data.favourites.map((f: any) => f.question_id));
          console.log('✅ Loaded favourites from database:', userFavourites.size);
          updateFavouriteStar();
        } else if (response.status === 401) {
          // Not authenticated, use localStorage fallback
          console.log('ℹ️ Not authenticated, using localStorage for favourites');
          userFavourites = new Set(getFavouriteIds());
          updateFavouriteStar();
        }
      } catch (error) {
        console.error('❌ Error loading favourites:', error);
        // Fallback to localStorage
        userFavourites = new Set(getFavouriteIds());
        updateFavouriteStar();
      }
    }

    async function toggleFavourite(questionId: string | null, questionData?: any) {
      if (!questionId) {
        console.warn('⚠️ No question ID provided');
        return;
      }

      const isFav = userFavourites.has(questionId);
      
      console.log('🔄 toggleFavourite called', { questionId, isFav, questionData });
      
      try {
        if (isFav) {
          // Remove from favourites
          console.log(`🗑️ Attempting to remove ${questionId} from favourites...`);
          const response = await fetch(`http://localhost:3001/api/favourites/remove/${encodeURIComponent(questionId)}`, {
            method: 'DELETE',
            credentials: 'include'
          });
          
          console.log('Response status:', response.status, response.statusText);
          
          if (response.ok) {
            userFavourites.delete(questionId);
            console.log(`✅ Removed ${questionId} from favourites`);
            
            // Update localStorage as backup
            const localFavs = getFavouriteIds().filter(id => id !== questionId);
            setFavouriteIds(localFavs);
          } else {
            const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
            console.error('❌ Failed to remove favourite:', errorData);
            throw new Error(errorData.error || 'Failed to remove favourite');
          }
        } else {
          // Add to favourites
          const payload = {
            questionId: questionId,
            questionName: questionData?.name || questionData?.title || questionData?.displayName || '',
            parentTopic: Array.isArray(questionData?.topic) ? questionData.topic[0] : questionData?.topic || '',
            difficulty: questionData?.difficulty || '',
            paper: questionData?.paper || '',
            year: questionData?.year || '',
            questionType: questionData?.questionType || 'state'
          };
          
          console.log('➕ Attempting to add to favourites...', payload);
          
          const response = await fetch('http://localhost:3001/api/favourites/add', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            credentials: 'include',
            body: JSON.stringify(payload)
          });
          
          console.log('Response status:', response.status, response.statusText);
          
          if (response.ok) {
            const data = await response.json();
            console.log('✅ Server response:', data);
            userFavourites.add(questionId);
            console.log(`✅ Added ${questionId} to favourites`);
            
            // Update localStorage as backup
            const localFavs = getFavouriteIds();
            if (!localFavs.includes(questionId)) {
              localFavs.push(questionId);
              setFavouriteIds(localFavs);
            }
          } else {
            const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
            console.error('❌ Failed to add favourite:', errorData);
            throw new Error(errorData.error || 'Failed to add favourite');
          }
        }
        
        // Update UI
        updateFavouriteStar();
        
      } catch (error) {
        console.error('❌ Error toggling favourite:', error);
        alert('Failed to update favourite. Please try again. Check console for details.');
      }
    }

    // Attach favourite toggle listener once DOM is ready
    document.addEventListener('DOMContentLoaded', () => {
      // Load favourites from database on page load
      loadUserFavourites();
    });

    // Client-side formatting functions
    function formatDifficulty(difficulty: number | string | undefined) {
      const difficultyValue = difficulty || 1;
      const difficultyNum = typeof difficultyValue === 'string' ? parseInt(difficultyValue) || 1 : difficultyValue;
      const normalizedDifficulty = Math.min(Math.max(difficultyNum, 1), 3);
      
      const difficultyConfig: { [key: number]: { label: string; color: string } } = {
        1: { label: 'Easy', color: 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-300' },
        2: { label: 'Medium', color: 'bg-orange-100 text-orange-800 dark:bg-orange-900 dark:text-orange-300' },
        3: { label: 'Hard', color: 'bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-300' }
      };
      
      return difficultyConfig[normalizedDifficulty];
    }

    function formatTopicName(topic: string | number | undefined | null): string {
      if (!topic) return '';
      
      const topicStr = String(topic).toLowerCase();
      
      const specialMappings: { [key: string]: string } = {
        'sequences-and-series': 'Sequences & Series',
        'sequences-series': 'Sequences & Series',
        'sequences and series': 'Sequences & Series',
        'prob-stat': 'Probability-Statistics',
        'probability-statistics': 'Probability-Statistics',
        'prob stat': 'Probability-Statistics',
        'the-line': 'The Line',
        'complex-numbers': 'Complex Numbers',
        'complex numbers': 'Complex Numbers',
        'financial-maths': 'Financial Maths',
        'financial maths': 'Financial Maths',
  'financial-mathematics': 'Financial Maths',
  'financial mathematics': 'Financial Maths',
        'compound-interest': 'Compound Interest',
        'compound interest': 'Compound Interest',
        'mathematical-induction': 'Mathematical Induction',
        'mathematical induction': 'Mathematical Induction',
        'proof-by-induction': 'Proof by Induction',
        'proof by induction': 'Proof by Induction',
        'differentiation': 'Differentiation',
        'integration': 'Integration',
        'algebra': 'Algebra',
        'geometry': 'Geometry',
        'trigonometry': 'Trigonometry',
        'statistics': 'Statistics',
        'probability': 'Probability',
        'the-circle': 'The Circle',
        'functions': 'Functions',
        'induction': 'Induction',
        'number': 'Number'
      };
      
      if (specialMappings[topicStr]) {
        return specialMappings[topicStr];
      }
      
      for (const [key, value] of Object.entries(specialMappings)) {
        if (topicStr.includes(key) || key.includes(topicStr)) {
          return value;
        }
      }
      
      return topicStr
        .replace(/[-_]/g, ' ')
        .split(' ')
        .map(word => word.charAt(0).toUpperCase() + word.slice(1))
        .join(' ');
    }

    // Question caching system
  const questionBuffer: PracticeQuestion[] = []; // Cache of 5 validated questions
    let bufferIndex = 0; // Current position in the buffer
    let isLoadingBuffer = false; // Prevent concurrent buffer loads

    // State history for each question
  // (Removed duplicate declaration of questionHistory)

    // Timer functions
    function startTimer() {
      if (!timerInterval) {
        timerInterval = setInterval(() => {
          timerSeconds++;
          updateTimerDisplay();

        }, 1000);
        updateTimerButtons(true);
      }
    }

    function pauseTimer() {
      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
        updateTimerButtons(false);
      }
    }

    function resetTimer() {
      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }
      timerSeconds = 0;
      updateTimerDisplay();
      updateTimerButtons(false);
    }

    // Save Attempt Modal Functions
    function showSaveAttemptModal() {
      // Stop the timer when showing the modal
      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }
      
      // Update modal content
      const modalQuestionTitle = document.getElementById('modal-question-title');
      const modalTimeTaken = document.getElementById('modal-time-taken');
      
      if (modalQuestionTitle && currentQuestion) {
        const customTitle = computeCustomTitle(currentQuestion);
        modalQuestionTitle.textContent = customTitle || currentQuestion.name || currentQuestion.id || 'Unknown Question';
      }
      
      if (modalTimeTaken) {
        const minutes = Math.floor(timerSeconds / 60);
        const seconds = timerSeconds % 60;
        modalTimeTaken.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      }
      
      // Show the modal
      const modal = document.getElementById('save-attempt-modal');
      if (modal) {
        modal.classList.remove('hidden');
        // Prevent body scroll while modal is open
        document.body.style.overflow = 'hidden';
      }
      
      // Clear previous notes and focus without scrolling
      const notesInput = document.getElementById('attempt-notes') as HTMLTextAreaElement;
      if (notesInput) {
        notesInput.value = '';
        // Focus without scrolling
        setTimeout(() => {
          notesInput.focus({ preventScroll: true });
        }, 100);
      }
    }
    
    function hideSaveAttemptModal() {
      const modal = document.getElementById('save-attempt-modal');
      if (modal) {
        modal.classList.add('hidden');
        // Restore body scroll
        document.body.style.overflow = '';
      }
    }
    
    async function ensureAuthenticated() {
      try {
        const r = await fetch('http://localhost:3001/api/user-auth/me', { credentials: 'include' });
        if (r.ok) return true;
  } catch { /* ignore auth probe error */ }
      // Redirect to login with return path
      const returnTo = encodeURIComponent(window.location.pathname + window.location.search);
      window.location.href = `/login?returnTo=${returnTo}`;
      return false;
    }

    function saveAttempt() {
      const notesInput = document.getElementById('attempt-notes') as HTMLTextAreaElement;
      const notes = notesInput ? notesInput.value : '';
      if (!currentQuestion) {
        console.warn('No current question to save');
        return;
      }

      const attemptData = {
        questionId: String(currentQuestion.id || ''),
        questionName: currentQuestion.name || currentQuestion.id || '',
        timeTaken: timerSeconds,
        notes,
        timestamp: new Date().toISOString(),
        topic: (Array.isArray(currentQuestion.topic) ? currentQuestion.topic.join(',') : (currentQuestion.topic || '')),
        difficulty: currentQuestion.difficulty || ''
      };

      // Save to database via new API
      const backendPort = 3001; 
      const backendBase = `http://localhost:${backendPort}`;
      const qid = String(currentQuestion.id || '');
      
      // Extract question metadata for database
      const questionName = currentQuestion.name || currentQuestion.id || '';
      const topicArray = Array.isArray(currentQuestion.topic) ? currentQuestion.topic : (currentQuestion.topic ? [currentQuestion.topic] : []);
      const parentTopic = topicArray.length > 0 ? topicArray[0] : null;
      const relatedTopics = topicArray.length > 0 ? topicArray : null;
      
      // Infer paper from question name (P1 or P2)
      let paper = null;
      if (questionName) {
        if (questionName.includes('P1')) paper = 'P1';
        else if (questionName.includes('P2')) paper = 'P2';
      }
      
      // Infer year from question name (e.g., "2024 P1 Question 1")
      let year = null;
      if (questionName) {
        const yearMatch = questionName.match(/^(\d{4}(?:\s+(?:Deferred|Sample|Preview|[A-Z][a-z]+))?)/);
        if (yearMatch) {
          year = yearMatch[1];
        }
      }
      
      // Infer question type (state if has year, custom if not)
      const questionType = year ? 'state' : 'custom';
      
      fetch(`${backendBase}/api/attempts`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({ 
          questionId: qid, 
          timeTakenSeconds: timerSeconds || null, 
          notes: notes || null,
          questionName: questionName,
          parentTopic: parentTopic,
          relatedTopics: relatedTopics,
          difficulty: currentQuestion.difficulty || null,
          paper: paper,
          year: year,
          questionType: questionType
        })
      }).then(async r => {
        if (!r.ok) {
          console.warn('Backend attempt save failed', r.status);
          
          // If 401 (unauthorized), redirect to login
          if (r.status === 401) {
            const returnTo = encodeURIComponent(window.location.pathname + window.location.search);
            window.location.href = `/login?returnTo=${returnTo}`;
            return;
          }
          
          // Fallback to localStorage if database save fails (for other errors)
          try {
            interface StoredAttempt { questionId: string; [key: string]: unknown }
            const existingAttempts: StoredAttempt[] = JSON.parse(localStorage.getItem('questionAttempts') || '[]');
            const replacedIndex = existingAttempts.findIndex(a => a.questionId === attemptData.questionId);
            if (replacedIndex !== -1) {
              existingAttempts[replacedIndex] = attemptData as unknown as StoredAttempt;
            } else {
              existingAttempts.push(attemptData as unknown as StoredAttempt);
            }
            localStorage.setItem('questionAttempts', JSON.stringify(existingAttempts));
          } catch (e) {
            console.warn('Failed to write attempt to localStorage', e);
          }
          return;
        }
        const json = await r.json();
        console.log('Attempt saved to database', json);
        
        // Also save to localStorage as backup
        try {
          interface StoredAttempt { questionId: string; [key: string]: unknown }
          const existingAttempts: StoredAttempt[] = JSON.parse(localStorage.getItem('questionAttempts') || '[]');
          const replacedIndex = existingAttempts.findIndex(a => a.questionId === attemptData.questionId);
          if (replacedIndex !== -1) {
            existingAttempts[replacedIndex] = attemptData as unknown as StoredAttempt;
          } else {
            existingAttempts.push(attemptData as unknown as StoredAttempt);
          }
          localStorage.setItem('questionAttempts', JSON.stringify(existingAttempts));
        } catch (e) {
          console.warn('Failed to write attempt to localStorage', e);
        }
      }).catch(err => {
        console.warn('Backend attempt save network error, saving to localStorage only', err);
        // Fallback to localStorage on network error
        try {
          interface StoredAttempt { questionId: string; [key: string]: unknown }
          const existingAttempts: StoredAttempt[] = JSON.parse(localStorage.getItem('questionAttempts') || '[]');
          const replacedIndex = existingAttempts.findIndex(a => a.questionId === attemptData.questionId);
          if (replacedIndex !== -1) {
            existingAttempts[replacedIndex] = attemptData as unknown as StoredAttempt;
          } else {
            existingAttempts.push(attemptData as unknown as StoredAttempt);
          }
          localStorage.setItem('questionAttempts', JSON.stringify(existingAttempts));
        } catch (e) {
          console.warn('Failed to write attempt to localStorage', e);
        }
      });

      hideSaveAttemptModal();
      console.log('Attempt saved (local + backend sync attempted):', attemptData);
      nextQuestion();
    }

    // Report Question Modal Functions
    let selectedReportReason = '';
    
    function showReportQuestionModal() {
      // Update modal content
      const reportQuestionTitle = document.getElementById('report-question-title');
      
      if (reportQuestionTitle && currentQuestion) {
        reportQuestionTitle.textContent = currentQuestion.name || currentQuestion.id || 'Unknown Question';
      }
      
      // Reset modal state
      selectedReportReason = '';
      const selectedSection = document.getElementById('selected-reason-section');
      const customSection = document.getElementById('custom-description-section');
      const submitBtn = document.getElementById('submit-report') as HTMLButtonElement;
      
      if (selectedSection) selectedSection.classList.add('hidden');
      if (customSection) customSection.classList.add('hidden');
      if (submitBtn) submitBtn.disabled = true;
      
      // Clear custom description
      const customInput = document.getElementById('custom-description') as HTMLTextAreaElement;
      if (customInput) customInput.value = '';
      
      // Reset button styles
      document.querySelectorAll('.report-reason-btn').forEach(btn => {
        btn.classList.remove('bg-red-100', 'dark:bg-red-900/30', 'border-red-300', 'dark:border-red-600');
        btn.classList.add('border-gray-300', 'dark:border-slate-600');
      });
      
      // Show the modal
      const modal = document.getElementById('report-question-modal');
      if (modal) {
        modal.classList.remove('hidden');
        document.body.style.overflow = 'hidden';
      }
    }
    
    function hideReportQuestionModal() {
      const modal = document.getElementById('report-question-modal');
      if (modal) {
        modal.classList.add('hidden');
        document.body.style.overflow = '';
      }
    }
    
    function selectReportReason(reason: string, buttonElement: HTMLElement) {
      selectedReportReason = reason;
      
      // Reset all buttons
      document.querySelectorAll('.report-reason-btn').forEach(btn => {
        btn.classList.remove('bg-red-100', 'dark:bg-red-900/30', 'border-red-300', 'dark:border-red-600');
        btn.classList.add('border-gray-300', 'dark:border-slate-600');
      });
      
      // Highlight selected button
      buttonElement.classList.remove('border-gray-300', 'dark:border-slate-600');
      buttonElement.classList.add('bg-red-100', 'dark:bg-red-900/30', 'border-red-300', 'dark:border-red-600');
      
      const selectedSection = document.getElementById('selected-reason-section');
      const selectedReasonEl = document.getElementById('selected-reason');
      const customSection = document.getElementById('custom-description-section');
      const submitBtn = document.getElementById('submit-report') as HTMLButtonElement;
      
      if (reason === 'Other') {
        // Show custom description input
        if (customSection) customSection.classList.remove('hidden');
        if (selectedSection) selectedSection.classList.add('hidden');
        if (submitBtn) submitBtn.disabled = true; // Will be enabled when text is entered
      } else {
        // Show selected reason
        if (selectedReasonEl) selectedReasonEl.textContent = reason;
        if (selectedSection) selectedSection.classList.remove('hidden');
        if (customSection) customSection.classList.add('hidden');
        if (submitBtn) submitBtn.disabled = false;
      }
    }
    
    function submitReport() {
      let reportReason = selectedReportReason;
      let description = '';
      
      if (selectedReportReason === 'Other') {
        const customInput = document.getElementById('custom-description') as HTMLTextAreaElement;
        description = customInput ? customInput.value.trim() : '';
        reportReason = description;
      }
      
      if (!reportReason) return;
      
      // Create report data
      const reportData = {
        questionId: currentQuestion?.id || '',
        questionName: currentQuestion?.name || currentQuestion?.id || '',
        reason: reportReason,
        description: description,
        timestamp: new Date().toISOString(),
        topic: currentQuestion?.topic || '',
        difficulty: currentQuestion?.difficulty || ''
      };
      
      // Store in localStorage (you could also send to backend API)
      const existingReports = JSON.parse(localStorage.getItem('questionReports') || '[]');
      existingReports.push(reportData);
      localStorage.setItem('questionReports', JSON.stringify(existingReports));
      
      console.log('Question reported:', reportData);
      
      // Hide modal
      hideReportQuestionModal();
      
      // Show success message
      console.log('Question reported successfully!');
    }

    function updateTimerDisplay() {
      const minutes = Math.floor(timerSeconds / 60);
      const seconds = timerSeconds % 60;
      const display = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      const el = document.getElementById('sidebar-timer');
      if (el) el.textContent = display;
    }

    function updateTimerButtons(isRunning) {
      const startButton = document.getElementById('timer-start');
      if (startButton) {
        if (isRunning) {
          startButton.innerHTML = '<svg class="w-4 h-4" fill="currentColor" viewBox="0 0 24 24"><path d="M6 4h4v16H6V4zm8 0h4v16h-4V4z"/></svg>';
          startButton.title = 'Pause Timer';
          startButton.setAttribute('data-state', 'running');
        } else {
          startButton.innerHTML = '<svg class="w-4 h-4" fill="currentColor" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>';
          startButton.title = 'Start Timer';
          startButton.removeAttribute('data-state');
        }
      }
    }

    // Question validation function
  async function validateQuestion(question: PracticeQuestion): Promise<boolean> {
      // Accept all questions unless fundamental data missing; avoid network HEAD that caused 404 due to wrong origin
      const rawQuestionUrl = question.questionTifUrl || question.questionImageUrl || question.questionImagePath || question.tifUrl || question.image || '';
      const rawSolutionUrl = question.solutionTifUrl || question.solutionImageUrl || question.solutionImagePath || '';
      if (!rawQuestionUrl) return false; // require at least question image
      // Normalize & ensure they point to BACKEND_BASE when relative (images served by backend, not Astro dev server)
      const normalize = (rel: string) => {
        if (!rel) return rel;
        if (rel.startsWith('http')) return rel;
        if (!rel.startsWith('/')) rel = '/' + rel.replace(/^\.\//, '');
        return BACKEND_BASE + rel; // force backend origin
      };
  const qUrl = normalize(String(rawQuestionUrl));
  const sUrl = rawSolutionUrl ? normalize(String(rawSolutionUrl)) : '';
      // Optionally we could do a fetch with {method:'HEAD', mode:'no-cors'} but it provides no reliability; skip.
      // Provide minimal debug
      console.debug('[validateQuestion] accepted', { qUrl, hasSolution: !!sUrl });
      return true;
    }

    // Function to get filter parameters from URL
    function getFilterParams() {
      const urlParams = new URLSearchParams(window.location.search);
      return {
        examOnly: urlParams.get('examOnly') || 'false',
        longOnly: urlParams.get('longOnly') || 'false', 
        shortOnly: urlParams.get('shortOnly') || 'false',
        yearFrom: urlParams.get('yearFrom') || '',
        yearTo: urlParams.get('yearTo') || '',
        topics: urlParams.get('topics') || '',
        customOnly: urlParams.get('customOnly') || 'false'
      };
    }

    // Determine backend base URL with fallback (prefers 3001, legacy 3008)
    const BACKEND_BASE = (() => {
      // Allow global override without strict typing; fallback to env then default port 3001
      const win = window as unknown as { __BACKEND_URL__?: string };
      const explicit = win.__BACKEND_URL__ || (import.meta as unknown as { env?: { PUBLIC_BACKEND_URL?: string } }).env?.PUBLIC_BACKEND_URL;
      if (explicit) return explicit.replace(/\/$/, '');
      // Try common local ports; 3001 is current, 3008 was legacy
      return 'http://localhost:3001';
    })();

    async function fetchWithFallback(path: string, init?: RequestInit) {
      const primary = BACKEND_BASE + path;
      try {
        const res = await fetch(primary, init);
        if (!res.ok) throw new Error('HTTP ' + res.status);
        return res;
      } catch (err) {
        // If already on legacy port or explicit, just rethrow
        if (BACKEND_BASE.includes('3008') || BACKEND_BASE !== 'http://localhost:3001') throw err;
        // Attempt legacy port 3008 once
        const legacy = 'http://localhost:3008' + path;
        try {
          const lr = await fetch(legacy, init);
          if (!lr.ok) throw new Error('HTTP ' + lr.status + ' (legacy)');
          console.warn('[practice] Using legacy backend port 3008 (primary 3001 failed)');
          return lr;
        } catch {
          throw err; // propagate original
        }
      }
    }

    // Buffer management functions
    async function loadQuestionBuffer() {
      if (isLoadingBuffer) return;
      isLoadingBuffer = true;

      try {
        updateLoadingMessage("Loading question set...");
        const topic = window.location.pathname.split('/').pop();
        const filterParams = getFilterParams();
        
        // Determine which topics to query
        let topicsToQuery = [topic];
        if (topic === 'all') {
          topicsToQuery = []; // Empty array means all topics
        } else if (topic === 'mixed' && filterParams.topics) {
          topicsToQuery = filterParams.topics.split(',').map(t => t.trim()).filter(t => t);
        }
        
        // Build query parameters for the API call
        const queryParams = new URLSearchParams();
        if (topicsToQuery.length > 0) {
          queryParams.set('topics', topicsToQuery.join(','));
        }
  if (filterParams.examOnly === 'true') queryParams.set('examOnly', 'true');
        if (filterParams.longOnly === 'true') queryParams.set('longOnly', 'true');
        if (filterParams.shortOnly === 'true') queryParams.set('shortOnly', 'true');
        if (filterParams.yearFrom) queryParams.set('yearFrom', filterParams.yearFrom);
        if (filterParams.yearTo) queryParams.set('yearTo', filterParams.yearTo);
  if (filterParams.customOnly === 'true') queryParams.set('customOnly', 'true');
        queryParams.set('count', '10'); // Request 10 questions to have more to validate
        
  const response = await fetchWithFallback(`/api/questions?${queryParams.toString()}`);

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        const result = await response.json();
        // Handle both single question and array responses
        const questionsArray = Array.isArray(result) ? result : [result];
        
        if (questionsArray.length === 0) {
          throw new Error('No questions available for the selected filters');
        }

        updateLoadingMessage("Validating questions...");
        
        // Shuffle and validate questions until we have 5 valid ones
        const shuffledQuestions = [...questionsArray].sort(() => Math.random() - 0.5);
        const validQuestions: PracticeQuestion[] = [];
        
        for (const question of shuffledQuestions) {
          if (validQuestions.length >= 5) break;
          
          updateLoadingMessage(`Validating question ${validQuestions.length + 1}/5...`);
          const isValid = await validateQuestion(question);
          if (isValid) {
            validQuestions.push(question);
          }
        }

        if (validQuestions.length === 0) {
          throw new Error('No valid questions found with accessible images');
        }

        questionBuffer.splice(0, questionBuffer.length, ...validQuestions);
        bufferIndex = 0;
        console.log(`Loaded ${validQuestions.length} validated questions into buffer`);
        
      } catch (error) {
        console.error('Error loading question buffer:', error);
        throw error;
      } finally {
        isLoadingBuffer = false;
      }
    }

    function getNextQuestionFromBuffer(): PracticeQuestion | null {
      if (questionBuffer.length === 0) return null;
      
      const question = questionBuffer[bufferIndex];
      bufferIndex = (bufferIndex + 1) % questionBuffer.length;
      
      // If we've cycled through all questions, trigger a reload for variety
      if (bufferIndex === 0) {
        console.log('Buffer cycled, will reload on next request');
        // Don't await this, let it load in background
        setTimeout(() => loadQuestionBuffer().catch(console.error), 100);
      }
      
      return question;
    }

    // Function to load a specific question by ID using direct API lookup
    async function loadSpecificQuestion(questionId: string): Promise<boolean> {
      try {
        showLoadingScreen("Loading specific question...");
        console.log(`Loading specific question: ${questionId}`);
        
        // Use direct question lookup API - this bypasses topic filtering
  const response = await fetchWithFallback(`/api/questions?id=${encodeURIComponent(questionId)}`);
        
        if (response.ok) {
          const specificQuestion = await response.json();
          console.log('Successfully loaded question via direct lookup:', specificQuestion);
          // Mismatch check removed (allow fallback IDs from backend if remapped)
          
          // Validate the specific question
          updateLoadingMessage("Validating specific question...");
          const isValid = await validateQuestion(specificQuestion);
          if (!isValid) {
            console.log(`Question ${questionId} failed validation, loading random question instead`);
            return false;
          }

          // Set this as the current question
          currentQuestion = specificQuestion;
          if (!currentQuestion) return false; // safety
          // Override visible name for custom questions
          try {
            const ct = computeCustomTitle(currentQuestion);
            if (ct) {
              currentQuestion.displayName = ct;
              currentQuestion.name = ct;
            }
          } catch (e) { console.warn('Custom title compute failed', e); }
          showingSolution = false;
          
          // Initialize history with this question
          questionHistory = [{
            question: currentQuestion as PracticeQuestion,
            timerSeconds: 0,
            zoomLevel: 1.0,
            highlightRects: [],
            showingSolution: false
          }];

          updateLoadingMessage("Displaying question...");
          displayQuestion(currentQuestion);
          updateMetadata(currentQuestion);
          updateTabAppearance();
          
          setTimeout(() => {
            hideLoadingScreen();
          }, 300);
          
          console.log(`✓ Question loaded successfully: ${(currentQuestion as PracticeQuestion).name || (currentQuestion as PracticeQuestion).id} (ID: ${(currentQuestion as PracticeQuestion).id})`);
          return true;
          
        } else if (response.status === 404) {
          console.log(`Question with ID "${questionId}" not found`);
          return false;
        } else {
          console.error('Failed to fetch question, status:', response.status);
          return false;
        }

      } catch (error) {
        console.error('Error loading specific question:', error);
        return false;
      }
    }



    // Initialize buffer on page load
    async function initializeQuestionSystem() {
      try {
        showLoadingScreen("Initializing practice session...");
        await loadQuestionBuffer();
        console.log('Question system initialized successfully');
      } catch (error) {
        console.error('Failed to initialize question system:', error);
        // Continue anyway - loadQuestion will handle the error
      }
    }

    // Loading screen functions
    function showLoadingScreen(message = "Preparing your questions...") {
      const overlay = document.getElementById('loading-overlay');
      const messageEl = document.getElementById('loading-message');
      if (overlay) overlay.style.display = 'flex';
      if (messageEl) messageEl.textContent = message;
    }

    function hideLoadingScreen() {
      const overlay = document.getElementById('loading-overlay');
      if (overlay) {
        overlay.style.opacity = '0';
        setTimeout(() => {
          overlay.style.display = 'none';
        }, 300);
      }
    }

    function updateLoadingMessage(message) {
      const messageEl = document.getElementById('loading-message');
      if (messageEl) messageEl.textContent = message;
    }

    // Clean error state with overlay (no results)
    function showFriendlyEmptyState(reason = 'No questions available for the current filters.') {
      // Hide the sidebar/options when showing error
      const sidebar = document.getElementById('sidebar');
      if (sidebar) {
        sidebar.style.display = 'none';
      }
      
      // Hide the question panel
      const questionPanel = document.getElementById('question-panel');
      if (questionPanel) {
        questionPanel.style.marginLeft = '0';
      }
      
      const resetUrl = PRACTICE_RESET_URL;
      
      // Create or update error overlay (positioned below navbar, z-index below navbar)
      let errorOverlay = document.getElementById('error-overlay');
      if (!errorOverlay) {
        errorOverlay = document.createElement('div');
        errorOverlay.id = 'error-overlay';
        errorOverlay.className = 'fixed inset-0 bg-white dark:bg-slate-900 z-30 flex items-center justify-center';
        errorOverlay.style.paddingTop = '80px'; // Account for navbar height
        document.body.appendChild(errorOverlay);
      }
      
      errorOverlay.innerHTML = `
        <div class="flex flex-col gap-6 items-center justify-center text-center px-8 py-12 max-w-lg">
          <div class="w-20 h-20 rounded-full bg-gray-100 dark:bg-slate-800 flex items-center justify-center">
            <svg class="w-10 h-10 text-gray-400 dark:text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.172 16.172a4 4 0 015.656 0M9 10h.01M15 10h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
          </div>
          <div>
            <h2 class="text-2xl font-bold text-gray-900 dark:text-gray-100 mb-3">No Questions Found</h2>
            <p class="text-gray-600 dark:text-gray-400 mb-2">${reason}</p>
            <p class="text-sm text-gray-500 dark:text-gray-500">Try changing your filter parameters (topic, year range, question length, or custom toggle) to find available questions.</p>
          </div>
          <div class="flex flex-wrap gap-3 justify-center">
            <button type="button" id="retry-load" class="px-5 py-2.5 rounded-lg bg-blue-600 hover:bg-blue-700 text-white font-medium focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition-colors">
              Retry
            </button>
            <a id="reset-filters-link" data-hard-reset href="${resetUrl}" class="px-5 py-2.5 rounded-lg bg-gray-200 dark:bg-slate-700 hover:bg-gray-300 dark:hover:bg-slate-600 text-gray-800 dark:text-gray-200 font-medium focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-offset-2 transition-colors">
              Reset All Filters
            </a>
          </div>
        </div>`;
      const retryBtn = document.getElementById('retry-load');
      if (retryBtn) {
        retryBtn.addEventListener('click', async () => {
          // Hide error overlay
          const errorOverlay = document.getElementById('error-overlay');
          if (errorOverlay) {
            errorOverlay.style.display = 'none';
          }
          
          // Show sidebar again
          const sidebar = document.getElementById('sidebar');
          if (sidebar) {
            sidebar.style.display = 'block';
          }
          
          // Restore question panel margin
          const questionPanel = document.getElementById('question-panel');
          if (questionPanel) {
            questionPanel.style.marginLeft = '20rem';
          }
          
          showLoadingScreen('Retrying...');
          try {
            await loadQuestion({});
          } finally {
            hideLoadingScreen();
          }
        });
      }
      // Force a hard navigation for reset to avoid slow SPA re-init
      const resetLink = document.getElementById('reset-filters-link');
      if (resetLink) {
        resetLink.addEventListener('click', (e) => {
          e.preventDefault();
          const url = (resetLink as HTMLAnchorElement).href + `&ts=${Date.now()}`;
          // Use location.replace to avoid extra history entries
          window.location.replace(url);
        }, { once: true });
      }
    }

    // Inject slow spin animation once
    (function ensureSpinStyle(){
      const spinStyleId = 'spin-slow-style';
      if (!document.getElementById(spinStyleId)) {
        const style = document.createElement('style');
        style.id = spinStyleId;
        style.textContent = '@keyframes spin-slower { from { transform: rotate(0deg);} to { transform: rotate(360deg);} } .animate-spin-slow { animation: spin-slower 18s linear infinite; }';
        document.head.appendChild(style);
      }
    })();

  // Question loading and display

  async function loadQuestion({fromHistory = false, historyIndex = null} = {}) {
      if (fromHistory && historyIndex !== null && questionHistory[historyIndex]) {
        // Restore from history
        const state = questionHistory[historyIndex];
        currentQuestion = state.question;
        timerSeconds = state.timerSeconds;
        zoomLevel = state.zoomLevel;
        highlightRects = JSON.parse(JSON.stringify(state.highlightRects || []));
        showingSolution = state.showingSolution;
        updateTimerDisplay();
        updateTimerButtons(false);
        if (showingSolution) {
          displaySolution();
        } else {
          displayQuestion(currentQuestion);
        }
        updateMetadata(currentQuestion);
        updateQuestionTitle();
        updateTabAppearance();
        drawHighlights();
        return;
      }
      
      try {
        // Check if buffer needs loading
        if (questionBuffer.length === 0 && !isLoadingBuffer) {
          await loadQuestionBuffer();
        }
        
        // Get next question from buffer (with retry if race emptied buffer)
        let data = getNextQuestionFromBuffer();
        if (!data) {
          console.warn('[practice] Buffer empty on first attempt, reloading...');
          if (!isLoadingBuffer) {
            await loadQuestionBuffer().catch(e => console.error('Reload buffer failed', e));
            data = getNextQuestionFromBuffer();
          }
        }
        if (!data) {
          console.error('[practice] No valid questions available after reload attempt');
          showFriendlyEmptyState();
          hideLoadingScreen();
          return;
        }
        
        currentQuestion = data;
        // Override visible name for custom questions
        try {
          const ct = computeCustomTitle(currentQuestion);
          if (ct) {
            currentQuestion.displayName = ct;
            currentQuestion.name = ct;
          }
        } catch (e) { console.warn('Custom title compute failed', e); }
        updateFavouriteStar();

        // Reset solution state
        showingSolution = false;
        const button = document.getElementById('show-solution');
        if (button) {
          button.textContent = 'Show Solution';
        }

        // Save state to history
        questionHistory = questionHistory.slice(0, questionCounter - 1); // Truncate forward history if any
        questionHistory.push({
          question: currentQuestion,
          timerSeconds,
          zoomLevel,
          highlightRects: JSON.parse(JSON.stringify(highlightRects)),
          showingSolution
        });

        updateLoadingMessage("Displaying question...");
        displayQuestion(data);
        updateMetadata(data);
        updateTabAppearance();
  updateFavouriteStar();
        
        // Hide loading screen once everything is loaded
        setTimeout(() => {
          hideLoadingScreen();
        }, 300);

      } catch (error) {
        console.error('Error loading question:', error);
        updateLoadingMessage("Error loading questions");
        setTimeout(() => {
          hideLoadingScreen();
          showFriendlyEmptyState('Error loading question. Please retry or adjust parameters.');
        }, 1000);
      }
    }

    let zoomLevel = 1.0;
    function displayQuestion(question) {
      const container = document.getElementById('question-container');
      if (!container) return;
      if (!question) {
        container.innerHTML = '<div class="flex items-center justify-center h-full text-red-500">No question data</div>';
        return;
      }

      // (Mismatch check removed) – Always display the loaded question; optionally log if IDs differ
      const urlParams = new URLSearchParams(window.location.search);
      const requestedQuestionId = urlParams.get('q');
      if (requestedQuestionId && question.id !== requestedQuestionId) {
        console.log(`[sequence] Loaded question ID (${question.id}) differs from requested (${requestedQuestionId}); displaying anyway.`);
      }
      // Support legacy and new API fields for image path
      const rawUrl = question.questionTifUrl || question.questionImageUrl || question.questionImagePath || question.tifUrl || question.image || '';
      if (rawUrl) {
        const imageUrl = rawUrl.startsWith('http') ? rawUrl : `${BACKEND_BASE}${rawUrl}`;
        // Treat first displayed question (or any custom forced) as a high-priority image to avoid Chrome's automatic lazy placeholder
        const isFirstQuestion = questionCounter <= 1; // questionCounter starts at 1 before increment elsewhere
        // We add width/height placeholders to give the browser layout stability; real natural size will adjust automatically
        const imgAttrs = {
          loading: isFirstQuestion ? 'eager' : 'lazy',
          fetchpriority: isFirstQuestion ? 'high' : 'auto',
          decoding: 'async'
        };
        const preloadId = 'question-image-preload-link';
        if (isFirstQuestion && !document.getElementById(preloadId)) {
          try {
            const l = document.createElement('link');
            l.id = preloadId;
            l.rel = 'preload';
            l.as = 'image';
            l.href = imageUrl;
            l.crossOrigin = 'anonymous';
            document.head.appendChild(l);
          } catch { /* noop */ }
        }
        container.innerHTML = `
          <div class="flex justify-center items-start h-full">
            <img id="question-img"
              src="${imageUrl}"
              alt="Question Image"
              class="w-full max-w-[700px] h-auto"
              width="700" height="1000"
              style="width:100%;max-width:1000px;height:auto;transform:scale(${zoomLevel});transform-origin:top center;transition:transform .2s;display:block;margin-top:0;"
              loading="${imgAttrs.loading}"
              fetchpriority="${imgAttrs.fetchpriority}"
              decoding="${imgAttrs.decoding}"
              crossorigin="anonymous"
              onload="this.dataset.loaded='1';"
              onerror="this.closest('div').innerHTML='Failed to load question image';"
            >
          </div>
        `;
    updateZoomDisplay();
    // Scroll 10% down by default
    setTimeout(() => {
      container.scrollTop = container.scrollHeight * 0.1;
    }, 0);
      } else {
        showFriendlyEmptyState('The selected question has no image available.');
      }
    }

    function updateZoomDisplay() {
      const zoomDisplay = document.getElementById('zoom-level');
      if (zoomDisplay) zoomDisplay.textContent = Math.round(zoomLevel * 100) + '%';
      const img = document.getElementById('question-img');
      if (img) img.style.transform = `scale(${zoomLevel})`;
    }



    // Build a custom title for non-exam (custom) questions like alg-0001 -> Custom Algebra 1
    function computeCustomTitle(q) {
      if (!q || !q.id) return null;
      // Accept ids with final numeric segment (>=3 digits); custom if leading zero
      const parts = String(q.id).split('-');
      const last = parts[parts.length - 1];
      if (!/^\d{3,}$/.test(last)) return null;
      if (!last.startsWith('0')) return null; // not custom
      const numeric = last;
      // Derive topic(s) portion by removing last segment
      const topicPart = parts.slice(0, -1).join('-') || 'custom';
      let rawTopic = Array.isArray(q.topic) ? (q.topic[0] || topicPart) : (q.topic || topicPart);
      rawTopic = String(rawTopic).replace(/_/g, '-');
      const topicPretty = rawTopic
        .split(/[-\s]/)
        .filter(Boolean)
        .map(w => w.charAt(0).toUpperCase() + w.slice(1))
        .join(' ');
      const number = parseInt(numeric, 10); // numeric without leading zeros
      return `Custom ${topicPretty} ${number}`;
    }

    function parseQuestionName(rawName) {
      if (!rawName) return { yearLine: '', paperLine: '', titleLine: rawName || '' };
      const tokens = String(rawName).trim().split(/\s+/);
      if (tokens.length < 2) return { yearLine: '', paperLine: '', titleLine: rawName };
      const yearToken = tokens[0];
      if (!/^\d{4}$/.test(yearToken)) return { yearLine: '', paperLine: '', titleLine: rawName };
      // Find paper token (P1 / P2)
      let paperIndex = -1;
      for (let i = 1; i < tokens.length; i++) {
        if (/^P[12]$/i.test(tokens[i])) { paperIndex = i; break; }
      }
      if (paperIndex === -1) return { yearLine: yearToken, paperLine: '', titleLine: rawName.replace(/^\d{4}\s*/, '') };
      const descriptorTokens = tokens.slice(1, paperIndex); // may be [] or ['Deferred'] etc.
      const yearLine = [yearToken, descriptorTokens.join(' ')].filter(Boolean).join(' ');
      const paperNum = tokens[paperIndex].replace(/^[Pp]/,'');
      const paperLine = `Paper ${paperNum}`;
      // Remaining tokens after paper may start with 'Question'
      let remaining = tokens.slice(paperIndex + 1).join(' ');
      // Normalize 'Question' label capitalization
      remaining = remaining.replace(/^question/i, match => match.charAt(0).toUpperCase() + match.slice(1).toLowerCase());
      // If empty, just use original
      const titleLine = remaining || rawName;
      return { yearLine, paperLine, titleLine };
    }

    function updateMetadata(question) {
      // Debug: log the question object to see available fields
      console.log('Question data:', question);
      console.log('Available fields:', Object.keys(question));
      
      // Update year display
      const baseName = question.name || question.Name || question.title || question.Title || '';
      const customTitle = computeCustomTitle(question);
      const finalName = customTitle || baseName;
      const parsed = parseQuestionName(baseName); // use original exam-style name for parsing
      // Populate new heading area above question image
      const qhYear = document.getElementById('qh-year');
      const qhPaper = document.getElementById('qh-paper');
      const qhTitle = document.getElementById('qh-title');
      if (customTitle) {
        // Custom questions have no exam year/paper; keep those blank
        if (qhYear) qhYear.textContent = '';
        if (qhPaper) qhPaper.textContent = '';
        if (qhTitle) qhTitle.textContent = finalName;
      } else {
        if (qhYear) qhYear.textContent = parsed.yearLine;
        if (qhPaper) qhPaper.textContent = parsed.paperLine;
        if (qhTitle) qhTitle.textContent = parsed.titleLine || finalName;
      }
      
      // Only update elements that actually exist in the markup
      const topicEl = document.getElementById('meta-topic');
      const diffEl = document.getElementById('meta-difficulty');
      const timeEl = document.getElementById('meta-time-limit');
      // API returns: id, topic, difficulty, timeLimitMinute, tags
      if (topicEl) {
        // Clear previous content
        topicEl.innerHTML = '';
        let topics = question.topic || question.subject || '--';
        
        // If topics is a string, make it an array for uniform handling
        if (typeof topics === 'string') {
          topics = [topics];
        }
        
        if (Array.isArray(topics)) {
          // Create formatted topic badges (same styling as Questions page)
          topics.forEach(topic => {
            const topicBadge = document.createElement('span');
            topicBadge.className = 'inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium bg-gray-100 text-gray-700 dark:bg-slate-700 dark:text-slate-300 whitespace-nowrap mr-1 mb-1';
            topicBadge.textContent = formatTopicName(String(topic));
            topicEl.appendChild(topicBadge);
          });
        } else {
          // Fallback for unexpected types
          const topicBadge = document.createElement('span');
          topicBadge.className = 'inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium bg-gray-100 text-gray-700 dark:bg-slate-700 dark:text-slate-300 whitespace-nowrap';
          topicBadge.textContent = formatTopicName(String(topics));
          topicEl.appendChild(topicBadge);
        }
      }
      if (diffEl) {
        const difficultyInfo = formatDifficulty(question.difficulty);
        diffEl.textContent = difficultyInfo.label;
        diffEl.className = `inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium ${difficultyInfo.color}`;
      }
      const limit = question.timeLimitMinute || question.timeLimit;
      if (timeEl) timeEl.textContent = limit ? `${limit} min` : '--';
    }

    function updateQuestionTitle() {
      const titleElement = document.getElementById('question-title');
      if (titleElement) {
        titleElement.textContent = `Question ${questionCounter}`;
      }
    }

    function nextQuestion() {
      if (sequenceMode) {
        if (sequenceIndex === -1 && currentQuestion?.id) {
          sequenceIndex = sequenceIds.indexOf(String(currentQuestion.id));
        }
        const nextIdx = sequenceIndex + 1;
        if (nextIdx >= sequenceIds.length) {
          console.info('[sequence] End of sequence');
          return;
        }
        const nextId = sequenceIds[nextIdx];
        sequenceIndex = nextIdx;
        loadSpecificQuestion(nextId).then(ok => {
          if (ok) {
            updateUrlQuestionId(nextId);
            questionCounter++;
            updateQuestionTitle();
          }
        });
        return;
      }
      // Random / buffered mode fallback
      if (currentQuestion) {
        if (questionHistory.length < questionCounter) {
          questionHistory.push({ question: currentQuestion, timerSeconds, zoomLevel, highlightRects: JSON.parse(JSON.stringify(highlightRects)), showingSolution });
        } else {
          questionHistory[questionCounter - 1] = { question: currentQuestion, timerSeconds, zoomLevel, highlightRects: JSON.parse(JSON.stringify(highlightRects)), showingSolution };
        }
      }
      questionCounter++;
      updateQuestionTitle();
      showingSolution = false;
      const button = document.getElementById('show-solution');
      if (button) button.textContent = 'Show Solution';
      loadQuestion();
    }
    function prevQuestion() {
      if (sequenceMode) {
        if (sequenceIndex === -1 && currentQuestion?.id) sequenceIndex = sequenceIds.indexOf(String(currentQuestion.id));
        const prevIdx = sequenceIndex - 1;
        if (prevIdx < 0) {
          console.info('[sequence] Start of sequence');
          return;
        }
        const prevId = sequenceIds[prevIdx];
        sequenceIndex = prevIdx;
        loadSpecificQuestion(prevId).then(ok => {
          if (ok) {
            updateUrlQuestionId(prevId);
            questionCounter = Math.max(1, questionCounter - 1);
            updateQuestionTitle();
          }
        });
        return;
      }
      if (questionCounter <= 1) return;
      if (currentQuestion) {
        questionHistory[questionCounter - 1] = { question: currentQuestion, timerSeconds, zoomLevel, highlightRects: JSON.parse(JSON.stringify(highlightRects)), showingSolution };
      }
      questionCounter--;
      updateQuestionTitle();
      const idx = questionCounter - 1;
      if (questionHistory[idx]) {
        const state = questionHistory[idx];
        currentQuestion = state.question;
        timerSeconds = state.timerSeconds;
        zoomLevel = state.zoomLevel;
        highlightRects = JSON.parse(JSON.stringify(state.highlightRects || []));
        showingSolution = state.showingSolution;
        updateTimerDisplay();
        updateTimerButtons(false);
        if (showingSolution) {
          displaySolution();
        } else {
          displayQuestion(currentQuestion);
          const container = document.getElementById('question-container');
          if (container) setTimeout(() => { container.scrollTop = container.scrollHeight * 0.1; }, 0);
        }
        updateMetadata(currentQuestion);
        updateQuestionTitle();
        drawHighlights();
      }
    }

  function displaySolution() {
    const container = document.getElementById('question-container');
    if (!container || !currentQuestion) return;
    // Accept solutionImageUrl, solutionImagePath, or solutionTifUrl (if present)
    const rawSolutionUrl = currentQuestion.solutionTifUrl || currentQuestion.solutionImageUrl || currentQuestion.solutionImagePath;
    if (rawSolutionUrl) {
      const rawSolutionUrlStr = String(rawSolutionUrl);
      const imageUrl = rawSolutionUrlStr.startsWith('http') ? rawSolutionUrlStr : `${BACKEND_BASE}${rawSolutionUrlStr}`;
      container.innerHTML = `
        <div class="flex justify-center" style="position: relative;">
          <img id="solution-img" src="${imageUrl}" 
               alt="Solution Image" 
               class="max-w-full h-auto rounded"
               style="transform: scale(${zoomLevel}); transform-origin: top center; transition: transform 0.2s; display: block; margin-top: 0;"
               loading="lazy"
               crossorigin="anonymous"
               onerror="this.closest('div').innerHTML='Failed to load solution image';">
          <canvas id="highlight-canvas" style="position: absolute; left: 0; top: 0; pointer-events: none;"></canvas>
        </div>
      `;
      updateZoomDisplay();
      setTimeout(setupHighlighter, 100);
    } else {
      container.innerHTML = '<div class="flex items-center justify-center h-full text-gray-500">No solution available</div>';
    }
  }

  function drawHighlights() {
    const img = document.getElementById('question-img') || document.getElementById('solution-img');
    const canvas = document.getElementById('highlight-canvas') as HTMLCanvasElement | null;
    if (!img || !canvas) return;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    highlightRects.forEach(rect => drawRect(rect, 'rgba(255,255,0,0.3)'));
  }

  function drawRect(rect: HighlightRect, color: string) {
    const canvas = document.getElementById('highlight-canvas') as HTMLCanvasElement | null;
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;
    ctx.save();
    ctx.strokeStyle = 'rgba(255,215,0,0.8)';
    ctx.lineWidth = 2;
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.rect(rect.x, rect.y, rect.w, rect.h);
    ctx.fill();
    ctx.stroke();
    ctx.restore();
  }

  function setupHighlighter() {
    // Dummy function for now, implement as needed for highlight interaction
    // This should set up mouse events for drawing highlights
  }

  function toggleSolution() {
    if (!currentQuestion) return;
    const button = document.getElementById('show-solution');
    const statusMsg = document.getElementById('status-message');
    if (!button) return;
    if (!showingSolution) {
      displaySolution();
      button.textContent = 'Show Question';
      if (statusMsg) statusMsg.innerHTML = '<span class="text-blue-600 font-medium">Solution displayed</span>';
      showingSolution = true;
    } else {
      displayQuestion(currentQuestion);
      button.textContent = 'Show Solution';
      if (statusMsg) statusMsg.innerHTML = '<span class="text-gray-600 font-medium">Question displayed</span>';
      showingSolution = false;
    }
    updateTabAppearance();
  }

  function updateTabAppearance() {
    const questionTab = document.getElementById('tab-question');
    const solutionTab = document.getElementById('tab-solution');
    
    if (questionTab && solutionTab) {
      if (showingSolution) {
        // Solution tab is active (white background)
        questionTab.className = 'flex-1 py-2 text-center font-semibold text-gray-700 bg-gray-100 hover:bg-gray-300 border-r border-gray-300 transition';
        solutionTab.className = 'flex-1 py-2 text-center font-semibold text-gray-700 bg-white hover:bg-gray-300 transition';
      } else {
        // Question tab is active (white background)
        questionTab.className = 'flex-1 py-2 text-center font-semibold text-gray-700 bg-white hover:bg-gray-300 border-r border-gray-300 transition';
        solutionTab.className = 'flex-1 py-2 text-center font-semibold text-gray-700 bg-gray-100 hover:bg-gray-300 transition';
      }
    }
  }

    // Initialize page function (guard against double init from DOMContentLoaded + astro:page-load)
  interface PracticeInitFlag { started: boolean }
  const w = window as unknown as { __practiceInit?: PracticeInitFlag };
  w.__practiceInit = w.__practiceInit || { started: false };
    async function initializePage() {
  if (w.__practiceInit && w.__practiceInit.started) { console.debug('[practice] initializePage skipped (already started)'); return; }
  if (w.__practiceInit) w.__practiceInit.started = true;
      // Authentication logic removed. Proceed without user gating.
      // If future auth reintroduced, restore checks here.
  // (user variable removed; no auth-dependent logic below)

      // Zoom controls
      const zoomInBtn = document.getElementById('zoom-in');
      const zoomOutBtn = document.getElementById('zoom-out');
      if (zoomInBtn) zoomInBtn.addEventListener('click', () => {
        zoomLevel = Math.min(zoomLevel + 0.1, 3.0);
        updateZoomDisplay();
      });
      if (zoomOutBtn) zoomOutBtn.addEventListener('click', () => {
        zoomLevel = Math.max(zoomLevel - 0.1, 0.2);
        updateZoomDisplay();
      });
      // Update initial question title
      updateQuestionTitle();
      
      // Check for specific question ID in URL parameters
      const urlParams = new URLSearchParams(window.location.search);
      const specificQuestionId = urlParams.get('q');
      
      if (specificQuestionId) {
        console.log(`🎯 Attempting to load specific question with ID: ${specificQuestionId}`);
        
        // Load specific question
        loadSpecificQuestion(specificQuestionId).then((success) => {
          if (!success) {
            // If specific question loading failed, show clear warning and fall back to random
            console.warn(`❌ Failed to load specific question "${specificQuestionId}"`);
            console.warn('🔄 Falling back to random question loading as safety measure');
            
            // Show user notification about fallback
            showLoadingScreen(`Question "${specificQuestionId}" not found. Loading a random question...`);
            setTimeout(() => {
              initializeQuestionSystem().then(() => {
                loadQuestion();
                updateTabAppearance();
              }).catch((error) => {
                console.error('Initialization failed:', error);
                loadQuestion();
                updateTabAppearance();
              });
            }, 2000); // Give user time to see the message
          } else {
            console.log(`✅ Successfully loaded specific question: ${specificQuestionId}`);
            if (sequenceMode) {
              // In ordered sequence mode, locate index and skip random buffer init
              sequenceIndex = sequenceIds.indexOf(String(specificQuestionId));
              if (sequenceIndex === -1) console.warn('[sequence] Provided list does not contain current question id');
            } else {
              // Load buffer for traditional random navigation
              initializeQuestionSystem().catch(console.error);
            }
          }
        }).catch((error) => {
          console.error('❌ Error during specific question loading:', error);
          console.warn('🔄 Falling back to random question loading');
          
          // Show user notification about error
          showLoadingScreen('Error loading specific question. Loading a random question...');
          setTimeout(() => {
            initializeQuestionSystem().then(() => {
              loadQuestion();
              updateTabAppearance();
            }).catch((error) => {
              console.error('Initialization failed:', error);
              loadQuestion();
              updateTabAppearance();
            });
          }, 2000);
        });
      } else {
        // Normal initialization - no specific question requested
        initializeQuestionSystem().then(() => {
          loadQuestion();
          updateTabAppearance();
        }).catch((error) => {
          console.error('Initialization failed, falling back to direct load:', error);
          loadQuestion();
          updateTabAppearance();
        });
      }
      
      // Timer controls
      const startBtn = document.getElementById('timer-start');
      if (startBtn) {
        startBtn.addEventListener('click', () => {
          if (timerInterval) {
            pauseTimer();
          } else {
            startTimer();
          }
        });
      }
      const resetBtn = document.getElementById('timer-reset');
      if (resetBtn) resetBtn.addEventListener('click', resetTimer);

      // Favourite (star) button
      const favBtn = document.getElementById('sidebar-favourite');
      if (favBtn) favBtn.addEventListener('click', async () => {
        if (!currentQuestion || !currentQuestion.id) {
          console.warn('⚠️ No current question to favourite');
          return;
        }
        
        await toggleFavourite(currentQuestion.id, currentQuestion);
      });

      // Tab switching
      const questionTab = document.getElementById('tab-question');
      const solutionTab = document.getElementById('tab-solution');
      
      if (questionTab) {
        questionTab.addEventListener('click', () => {
          if (showingSolution && currentQuestion) {
            displayQuestion(currentQuestion);
            showingSolution = false;
            updateTabAppearance();
          }
        });
      }
      
      if (solutionTab) {
        solutionTab.addEventListener('click', () => {
          if (!showingSolution && currentQuestion) {
            displaySolution();
            showingSolution = true;
            updateTabAppearance();
          }
        });
      }

      // Action buttons
      const solutionBtn = document.getElementById('show-solution');
      if (solutionBtn) solutionBtn.addEventListener('click', toggleSolution);

      // Navigation buttons
  const nextBtn = document.getElementById('next-question');
  if (nextBtn) nextBtn.addEventListener('click', nextQuestion);
      const saveAttemptBtn = document.getElementById('save-attempt');
      if (saveAttemptBtn) saveAttemptBtn.addEventListener('click', async () => {
        const authed = await ensureAuthenticated();
        if (authed) {
          showSaveAttemptModal();
        }
      });
      const prevBtn = document.getElementById('prev-question');
      if (prevBtn) prevBtn.addEventListener('click', prevQuestion);

      // Save Attempt Modal event listeners
      const cancelSaveBtn = document.getElementById('cancel-save-attempt');
      if (cancelSaveBtn) cancelSaveBtn.addEventListener('click', hideSaveAttemptModal);
      const confirmSaveBtn = document.getElementById('confirm-save-attempt');
      if (confirmSaveBtn) confirmSaveBtn.addEventListener('click', saveAttempt);

      // Report Question Modal event listeners
      const reportBtn = document.getElementById('report-question');
      if (reportBtn) reportBtn.addEventListener('click', showReportQuestionModal);
      const cancelReportBtn = document.getElementById('cancel-report');
      if (cancelReportBtn) cancelReportBtn.addEventListener('click', hideReportQuestionModal);
      const submitReportBtn = document.getElementById('submit-report');
      if (submitReportBtn) submitReportBtn.addEventListener('click', submitReport);
      
      // Report reason buttons
      document.querySelectorAll('.report-reason-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const reason = btn.getAttribute('data-reason') || '';
          selectReportReason(reason, btn as HTMLElement);
        });
      });
      
      // Custom description input validation
      const customDescInput = document.getElementById('custom-description') as HTMLTextAreaElement;
      if (customDescInput) {
        customDescInput.addEventListener('input', () => {
          const submitBtn = document.getElementById('submit-report') as HTMLButtonElement;
          if (selectedReportReason === 'Other' && submitBtn) {
            submitBtn.disabled = customDescInput.value.trim().length === 0;
          }
        });
      }
    }

    // Event listeners - support both DOMContentLoaded and Astro navigation
    document.addEventListener('DOMContentLoaded', initializePage);
    
    // Support Astro View Transitions - this fires on client-side navigation
    document.addEventListener('astro:page-load', initializePage);
  </script>

  <style>
  /* Removed pink practice background override */
    /* Shared pill border color variable for quick theme experimentation */
    :root { --pill-border-color: #9ca3af; }
    .dark :root { --pill-border-color: #9ca3af; }
    #sidebar {
      width: 20rem; /* w-80 */
    }

    #question-panel {
      transition: margin-left 0.3s ease;
    }

    #loading-overlay {
      transition: opacity 0.3s ease;
    }

    /* Composite zoom control */
  /* Ultra-compact size */
  #zoom-controls { height: 2rem; width: 6.5rem; }
    #zoom-controls .zoom-btn-left,
    #zoom-controls .zoom-btn-right,
    #zoom-controls .zoom-level { height: 100%; }
    #zoom-controls .zoom-btn-left,
    #zoom-controls .zoom-btn-right {
      width: 1.75rem; /* narrowed */
      background: #ffffff;
      color: #000000;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 1px solid var(--pill-border-color);
      cursor: pointer;
      user-select: none;
      transition: background .15s, color .15s, transform .1s;
      font-family: inherit;
      font-size: 0.8rem;
      line-height: 1;
      outline: none;
    }
    #zoom-controls .zoom-btn-left { border-right: none; border-radius: 9999px 0 0 9999px; }
    #zoom-controls .zoom-btn-right { border-left: none; border-radius: 0 9999px 9999px 0; }
    #zoom-controls .zoom-level {
      padding: 0 0.45rem; /* slightly narrower */
      background: #ffffff;
      color: #000000;
      display: flex;
      align-items: center;
      justify-content: center;
      border-top: 1px solid var(--pill-border-color);
      border-bottom: 1px solid var(--pill-border-color);
      font-family: inherit;
      font-size: 0.78rem; /* slightly reduced per request */
      flex: 1 1 auto; min-width: 0; /* allow flexible center to equalize pill width */
      outline: none;
    }
  #zoom-controls .zoom-btn-left:hover,
  #zoom-controls .zoom-btn-right:hover { background:#e5e5e5; color:#000; }
  #zoom-controls .zoom-btn-left:active,
  #zoom-controls .zoom-btn-right:active { transform: scale(0.9); }
  #zoom-controls .zoom-btn-left:focus,
  #zoom-controls .zoom-btn-right:focus { outline:none; }
  .dark #zoom-controls .zoom-btn-left,
  .dark #zoom-controls .zoom-btn-right,
  .dark #zoom-controls .zoom-level { background:#ffffff; color:#000000; }
  .dark #zoom-controls .zoom-btn-left:hover,
  .dark #zoom-controls .zoom-btn-right:hover { background:#d4d4d4; color:#000; }

    /* Timer controls - match zoom control styling */
  #timer-controls { height: 2rem; width: 6.5rem; /* match zoom controls total width */ }
    #timer-controls .timer-btn-left,
    #timer-controls .timer-btn-right,
    #timer-controls .timer-display { height: 100%; }
    #timer-controls .timer-btn-left,
    #timer-controls .timer-btn-right {
      width: 1.75rem;
      background:#ffffff; color:#000000; display:flex; align-items:center; justify-content:center;
      border:1px solid var(--pill-border-color); cursor:pointer; user-select:none; transition: background .15s, color .15s, transform .1s;
      font-family: inherit; font-size:0.8rem; line-height:1; outline:none;
    }
    #timer-controls .timer-btn-left { border-right:none; border-radius:9999px 0 0 9999px; }
    #timer-controls .timer-btn-right { border-left:none; border-radius:0 9999px 9999px 0; }
    #timer-controls .timer-display {
      padding:0 0.45rem; background:#ffffff; color:#000000; display:flex; align-items:center; justify-content:center;
      border-top:1px solid var(--pill-border-color); border-bottom:1px solid var(--pill-border-color); font-size:0.78rem; flex:1 1 auto; min-width:0; line-height:1; outline:none; font-family:inherit;
    }
  #timer-controls .timer-btn-left:hover,
  #timer-controls .timer-btn-right:hover { background:#e5e5e5; color:#000; }
    #timer-controls .timer-btn-left:active,
    #timer-controls .timer-btn-right:active { transform:scale(0.9); }
  #timer-controls .timer-btn-left:focus,
  #timer-controls .timer-btn-right:focus { outline:none; }
    .dark #timer-controls .timer-btn-left,
    .dark #timer-controls .timer-btn-right,
    .dark #timer-controls .timer-display { background:#ffffff; color:#000000; }
  .dark #timer-controls .timer-btn-left:hover,
  .dark #timer-controls .timer-btn-right:hover { background:#d4d4d4; color:#000; }

  /* Merge zoom + timer into one visual pill: flatten touching inner corners */
  .merged-group { gap:0.25rem; }
  .merged-group #zoom-controls .zoom-btn-right { border-radius:0; }
  .merged-group #timer-controls .timer-btn-left { border-radius:0; }
  /* Restore inner borders so each pill retains black edge */
  .merged-group #zoom-controls .zoom-btn-right { border-right:1px solid var(--pill-border-color); }
  .merged-group #timer-controls .timer-btn-left { border-left:1px solid var(--pill-border-color); }
  /* Ensure consistent vertical alignment */
  .merged-group #zoom-controls, .merged-group #timer-controls { display:flex; align-items:stretch; height:2rem; }

  /* Navigation pill controls */
  #nav-controls { height:2rem; }
  #nav-controls .nav-btn { height:100%; background:#ffffff; color:#000; display:flex; align-items:center; justify-content:center; border:1px solid var(--pill-border-color); cursor:pointer; user-select:none; transition:background .15s, color .15s, transform .1s; font-size:0.8rem; line-height:1; outline:none; min-width:0; }
  #nav-controls .nav-btn:first-child { border-radius:9999px 0 0 9999px; }
  #nav-controls .nav-btn:last-child { border-radius:0 9999px 9999px 0; }
  #nav-controls .nav-btn:hover { background:#000; color:#fff; }
  #nav-controls .nav-btn:active { transform:scale(.9); }
  #nav-controls .nav-btn:focus { outline:none; }
  .dark #nav-controls .nav-btn { background:#ffffff; color:#000; }
  .dark #nav-controls .nav-btn:hover { background:#000; color:#ffffff; }

  /* Save Attempt pill */
  #save-attempt.pill-action { height:2rem; background:#e5e5e5; color:#000; border:1px solid var(--pill-border-color); border-radius:9999px; display:flex; align-items:center; justify-content:center; font-size:0.8rem; font-weight:600; letter-spacing:.25px; cursor:pointer; user-select:none; transition:background .15s, color .15s, transform .1s, border-color .15s; }
  #save-attempt.pill-action:hover { background:#f3f3f3; color:#000; border-color:var(--pill-border-color); }
  #save-attempt.pill-action:active { transform:scale(.96); }
  #save-attempt.pill-action:focus { outline:none; }
  .dark #save-attempt.pill-action { background:#e5e5e5; color:#000; }
  .dark #save-attempt.pill-action:hover { background:#000; color:#fff; }

    /* Responsive behavior for smaller screens */
    @media (max-width: 1280px) {
      #sidebar {
        width: 18rem;
      }
      #question-panel {
        margin-left: 18rem !important;
      }
    }

    @media (max-width: 1024px) {
      #sidebar {
        width: 16rem;
      }
      #question-panel {
        margin-left: 16rem !important;
      }
    }
  </style>
</Layout>
